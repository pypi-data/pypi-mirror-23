"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CleanHtmlParser = exports.FlatListCleanerNode = exports.NoTextCleanerNode = exports.CleanerNode = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _htmlparser = require("htmlparser2");

var _htmlparser2 = _interopRequireDefault(_htmlparser);

var _utils = require("./utils");

var _TypeConvert = require("../utils/TypeConvert");

var _TypeConvert2 = _interopRequireDefault(_TypeConvert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CleanerNode = exports.CleanerNode = function () {
    function CleanerNode(options, parentNode, tagName) {
        var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

        _classCallCheck(this, CleanerNode);

        this._inlineWrapperNode = null;
        this.options = options;
        this.parentNode = parentNode;
        this.originalTagName = tagName;
        this.originalAttributes = attributes;
        this.tagName = this.cleanTagName();
        this.attributes = this.cleanAttributes();
        this.children = [];
    }

    _createClass(CleanerNode, [{
        key: "getClosestParentWithTagName",
        value: function getClosestParentWithTagName(tagName) {
            if (this.parentNode == null || this.parentNode.tagName == null) {
                return null;
            }
            if (this.parentNode.tagName == tagName) {
                return this.parentNode;
            } else {
                return this.parentNode.getClosestParentWithTagName(tagName);
            }
        }
    }, {
        key: "transformTagName",
        value: function transformTagName() {
            if (this.originalTagName != null && this.options.transformTagsMap.has(this.originalTagName)) {
                return this.options.transformTagsMap.get(this.originalTagName);
            }
            return this.originalTagName;
        }
    }, {
        key: "cleanTagName",
        value: function cleanTagName() {
            var tagName = this.transformTagName();
            if (tagName != null && this.options.allowedTagsSet.has(tagName)) {
                return tagName;
            }
            return null;
        }
    }, {
        key: "cleanAttributes",
        value: function cleanAttributes() {
            var cleanedAttributes = {};
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Object.keys(this.originalAttributes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var attributeName = _step.value;

                    if (this.options.isAllowedAttributeForTagName(this.tagName, attributeName)) {
                        cleanedAttributes[attributeName] = this.originalAttributes[attributeName];
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return cleanedAttributes;
        }
    }, {
        key: "shouldWrapStandaloneInlineTags",
        value: function shouldWrapStandaloneInlineTags() {
            return this.parentNode == null && this.options.wrapStandaloneInlineTagName != null;
        }
    }, {
        key: "getStandaloneInlineTagWrapper",
        value: function getStandaloneInlineTagWrapper() {
            if (this._inlineWrapperNode == null) {
                var node = this.makeChildNode(this.options.wrapStandaloneInlineTagName, this.options.wrapStandaloneInlineTagAttributes);
                this._inlineWrapperNode = node;
                this.children.push(node);
            }
            return this._inlineWrapperNode;
        }
    }, {
        key: "stopWrappingStandaloneInlineTags",
        value: function stopWrappingStandaloneInlineTags() {
            this._inlineWrapperNode = null;
        }
    }, {
        key: "addText",
        value: function addText(text) {
            if (this.shouldWrapStandaloneInlineTags()) {
                this.getStandaloneInlineTagWrapper().addText(text);
            } else {
                this.children.push(text);
            }
        }
    }, {
        key: "makeChildNode",
        value: function makeChildNode(tagName, attributes) {
            var cleanerNodeClass = this.options.getCleanerNodeClassForTagName(tagName);
            return new cleanerNodeClass(this.options, this, tagName, attributes);
        }
    }, {
        key: "isInlineTag",
        value: function isInlineTag() {
            return (0, _utils.isInlineTag)(this.tagName);
        }
    }, {
        key: "addChildNode",
        value: function addChildNode(node) {
            if (this.shouldWrapStandaloneInlineTags() && node.isInlineTag()) {
                this.getStandaloneInlineTagWrapper().addChildNode(node);
            } else {
                this.stopWrappingStandaloneInlineTags();
                this.children.push(node);
            }
        }
    }, {
        key: "addChildNodeFromTag",
        value: function addChildNodeFromTag(tagName, attributes) {
            var node = this.makeChildNode(tagName, attributes);
            this.addChildNode(node);
            return node;
        }
    }, {
        key: "shouldRenderTag",
        value: function shouldRenderTag() {
            if (this.tagName == null) {
                return false;
            }
            var closestParentNodeWithSameTag = this.getClosestParentWithTagName(this.tagName);
            if (closestParentNodeWithSameTag == null) {
                return true;
            }
            return this.options.allowNestedWithinSameTagSet.has(this.tagName);
        }
    }, {
        key: "makeStartTag",
        value: function makeStartTag() {
            if (this.shouldRenderTag()) {
                return (0, _utils.makeHtmlStartTag)(this.tagName, this.attributes);
            }
            return '';
        }
    }, {
        key: "makeEndTag",
        value: function makeEndTag() {
            if (this.shouldRenderTag()) {
                return (0, _utils.makeHtmlEndTag)(this.tagName);
            }
            return '';
        }
    }, {
        key: "childrenToHtml",
        value: function childrenToHtml() {
            var html = '';
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var child = _step2.value;

                    if (typeof child == 'string') {
                        html += child;
                    } else {
                        html += child.toHtml();
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return html;
        }
    }, {
        key: "toHtml",
        value: function toHtml() {
            return "" + this.makeStartTag() + this.childrenToHtml() + this.makeEndTag(this.tagName);
        }
    }, {
        key: "toString",
        value: function toString() {
            return this.toHtml();
        }
    }]);

    return CleanerNode;
}();

// Should be the default for nodes that can not contain
// text as a direct child, such as UL, OL, TABLE, ...
// and all the self-closing tags.


var NoTextCleanerNode = exports.NoTextCleanerNode = function (_CleanerNode) {
    _inherits(NoTextCleanerNode, _CleanerNode);

    function NoTextCleanerNode() {
        _classCallCheck(this, NoTextCleanerNode);

        return _possibleConstructorReturn(this, (NoTextCleanerNode.__proto__ || Object.getPrototypeOf(NoTextCleanerNode)).apply(this, arguments));
    }

    _createClass(NoTextCleanerNode, [{
        key: "addText",
        value: function addText(text) {}
    }]);

    return NoTextCleanerNode;
}(CleanerNode);

var FlatListCleanerNode = exports.FlatListCleanerNode = function (_NoTextCleanerNode) {
    _inherits(FlatListCleanerNode, _NoTextCleanerNode);

    function FlatListCleanerNode() {
        _classCallCheck(this, FlatListCleanerNode);

        return _possibleConstructorReturn(this, (FlatListCleanerNode.__proto__ || Object.getPrototypeOf(FlatListCleanerNode)).apply(this, arguments));
    }

    _createClass(FlatListCleanerNode, [{
        key: "shouldRenderTag",
        value: function shouldRenderTag() {
            if (this.tagName == null) {
                return false;
            }
            var closestUlParentNode = this.getClosestParentWithTagName(this.tagName);
            return closestUlParentNode == null;
        }
    }, {
        key: "addChildNode",
        value: function addChildNode(node) {
            var closestListParentNode = this.getClosestParentWithTagName(this.tagName);
            if (closestListParentNode == null) {
                _get(FlatListCleanerNode.prototype.__proto__ || Object.getPrototypeOf(FlatListCleanerNode.prototype), "addChildNode", this).call(this, node);
            } else {
                closestListParentNode.addChildNode(node);
            }
        }
    }]);

    return FlatListCleanerNode;
}(NoTextCleanerNode);

/*
Handle paste:

    <p>Hello PASTEHERE</p>
    <ul>
        <li>Item PASTEHERE</li>
    </ul>

Handle force single parent element (ul).
Handle &nbsp; (should be removed)

2 options:
- Clean everything after paste, and handle invalid nesting in the cleaner.
- Know where we are cleaning.

*/

var CleanHtmlParser = exports.CleanHtmlParser = function () {
    function CleanHtmlParser(html, options) {
        _classCallCheck(this, CleanHtmlParser);

        this.options = options;
        this._parse(html);
        if (this._isWrappingStandaloneInline) {
            this.endWrappingStandaloneInline();
        }
    }

    _createClass(CleanHtmlParser, [{
        key: "_parse",
        value: function _parse(html) {
            var _this3 = this;

            this._rootNode = new this.options.rootCleanerNodeClass(this.options, null, // parentNode
            this.options.rootCleanerNodeTagName, this.options.rootCleanerNodeAttributes);
            this._currentNode = this._rootNode;
            var parser = new _htmlparser2.default.Parser({
                onopentag: function onopentag() {
                    _this3.onOpenTag.apply(_this3, arguments);
                },
                ontext: function ontext() {
                    _this3.onText.apply(_this3, arguments);
                },
                onclosetag: function onclosetag() {
                    _this3.onCloseTag.apply(_this3, arguments);
                }
            }, { decodeEntities: true });
            parser.write(html);
            parser.end();
        }
    }, {
        key: "onOpenTag",
        value: function onOpenTag(tagName, attributes) {
            var node = this._currentNode.addChildNodeFromTag(tagName, attributes);
            // console.log(`${tagName}: ${node.toString()}`);
            this._currentNode = node;
        }
    }, {
        key: "onText",
        value: function onText(text) {
            this._currentNode.addText(text);
        }
    }, {
        key: "onCloseTag",
        value: function onCloseTag(tagName) {
            this._currentNode = this._currentNode.parentNode;
        }
    }, {
        key: "rootNode",
        get: function get() {
            return this._rootNode;
        }
    }]);

    return CleanHtmlParser;
}();

var CleanHtmlOptions = function () {
    function CleanHtmlOptions() {
        _classCallCheck(this, CleanHtmlOptions);

        this._allowedTagsSet = new Set();
        this._allowedAttributesMap = new Map();
        this._allowNestedWithinSameTagSet = new Set();
        this._transformTagsMap = new Map();
        this.defaultCleanerNodeClass = CleanerNode;
        this.rootCleanerNodeClass = CleanerNode;
        this.rootCleanerNodeTagName = null;
        this.rootCleanerNodeAttributes = {};
        this._tagNameToCleanerNodeClassMap = new Map();
        this.wrapStandaloneInlineTagName = null;
        this.wrapStandaloneInlineTagAttributes = {};
    }

    _createClass(CleanHtmlOptions, [{
        key: "isAllowedAttributeForTagName",
        value: function isAllowedAttributeForTagName(tagName, attributeName) {
            if (this._allowedAttributesMap.has(tagName)) {
                return this._allowedAttributesMap.get(tagName).has(attributeName);
            }
            return false;
        }
    }, {
        key: "getCleanerNodeClassForTagName",
        value: function getCleanerNodeClassForTagName(tagName) {
            if (this._tagNameToCleanerNodeClassMap.has(tagName)) {
                return this._tagNameToCleanerNodeClassMap.get(tagName);
            } else {
                return this.defaultCleanerNodeClass;
            }
        }
    }, {
        key: "setCleanerNodeClassForTagName",
        value: function setCleanerNodeClassForTagName(tagName, cleanerNodeClass) {
            this._tagNameToCleanerNodeClassMap.set(tagName, cleanerNodeClass);
        }

        // updateFromObject(optionsObject) {
        //     if(typeof optionsObject.allowedTagsSet != 'undefined') {
        //         this.allowedTagsSet = optionsObject.allowedTagsSet;
        //     }
        //     if(typeof optionsObject.allowedAttributesMap != 'undefined') {
        //         this.allowedAttributesMap = optionsObject.allowedAttributesMap;
        //     }
        //     if(typeof optionsObject.transformTagsMap != 'undefined') {
        //         this.transformTagsMap = optionsObject.transformTagsMap;
        //     }
        // }

    }, {
        key: "allowedTagsSet",
        get: function get() {
            return this._allowedTagsSet;
        },
        set: function set(allowedTagsSet) {
            this._allowedTagsSet = _TypeConvert2.default.toSet(allowedTagsSet);
        }
    }, {
        key: "allowedAttributesMap",
        get: function get() {
            return this._allowedAttributesMap;
        },
        set: function set(allowedAttributesMap) {
            this._allowedAttributesMap = _TypeConvert2.default.toMapOfSets(allowedAttributesMap);
        }
    }, {
        key: "transformTagsMap",
        set: function set(transformTagsMap) {
            this._transformTagsMap = _TypeConvert2.default.toMap(transformTagsMap);
        },
        get: function get() {
            return this._transformTagsMap;
        }
    }, {
        key: "allowNestedWithinSameTagSet",
        get: function get() {
            return this._allowNestedWithinSameTagSet;
        },
        set: function set(allowNestedWithinSameTagSet) {
            this._allowNestedWithinSameTagSet = _TypeConvert2.default.toSet(allowNestedWithinSameTagSet);
        }
    }, {
        key: "tagNameToCleanerNodeClassMap",
        set: function set(tagNameToCleanerNodeClassMap) {
            this._tagNameToCleanerNodeClassMap = _TypeConvert2.default.toMap(tagNameToCleanerNodeClassMap);
        },
        get: function get() {
            return this._tagNameToCleanerNodeClassMap;
        }
    }]);

    return CleanHtmlOptions;
}();

/**
 * HTML cleaner with extra post cleaning that makes it
 * suitable for cleaning input typed and pasted into
 * contenteditable editors.
 */


var CleanHtml = function () {
    function CleanHtml() {
        _classCallCheck(this, CleanHtml);

        this.options = new CleanHtmlOptions();
    }

    /**
     * Called at the beginning of {@link CleanHtml#clean}
     * before performing the default cleaning.
     *
     * Subclasses can override this to perform additional
     * cleaning pre-cleaning.
     *
     * @param {string} html The HTML to pre-clean.
     * @returns {string} The pre-cleaned HTML. Defaults to returning
     *    the provided ``html`` unchanged.
     */


    _createClass(CleanHtml, [{
        key: "preClean",
        value: function preClean(html) {
            return html;
        }

        /**
         * Called at the end of {@link CleanHtml#clean}
         * after performing the default cleaning.
         *
         * Subclasses can override this to perform additional
         * cleaning post-cleaning.
         *
         * @param {string} html The HTML to post-clean.
         * @returns {string} The cleaned HTML. Defaults to returning
         *    the provided ``html`` unchanged.
         */

    }, {
        key: "postClean",
        value: function postClean(html) {
            return html;
        }
    }, {
        key: "_clean",
        value: function _clean(html) {
            return new CleanHtmlParser(html, this.options).rootNode.toHtml();
        }

        /**
         * Clean the provided html.
         *
         * @param {string} html The HTML to clean.
         * @returns {string} The cleaned HTML.
         */

    }, {
        key: "clean",
        value: function clean(html) {
            var cleanedHtml = this.preClean(html);
            cleanedHtml = this._clean(cleanedHtml);
            cleanedHtml = this.postClean(cleanedHtml);
            return cleanedHtml;
        }
    }]);

    return CleanHtml;
}();

exports.default = CleanHtml;