'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Query-string creator and parser.
 *
 * @example <caption>Basics - build a querystring</caption>
 * const querystring = new QueryString();
 * querystring.set('name', 'Peter');
 * querystring.setIterable('tags', ['person', 'male']);
 * const encodedQuerystring = querystring.urlencode();
 * // encodedQuerystring === 'name=Peter&tags=person&tags=male'  // order may vary
 *
 * @example <caption>Parse a querystring</caption>
 * const querystring = new QueryString('name=Peter&tags=person&tags=male');
 * const name = querystring.get('name');
 * const tags = querystring.getArray('tags');
 * const firstTag = querystring.get('tags');
 *
 * @example <caption>Parse and modify a querystring</caption>
 * const querystring = new QueryString('name=Peter&tags=person&tags=male');
 * querystring.set('name', 'John');
 * querystring.append('tags', 'important');
 * // querystring.urlencode() === 'name=John&tags=person&tags=male&tags=important'
 * querystring.setIterable('tags', ['male']);
 * // querystring.urlencode() === 'name=John&tags=male'
 */
var QueryString = function () {
    /**
     *
     * @param {string} querystring Optional input querystring to parse.
     */
    function QueryString(querystring) {
        _classCallCheck(this, QueryString);

        this._queryStringMap = new Map();
        if (typeof querystring !== 'undefined') {
            if (typeof querystring !== 'string') {
                throw new TypeError('The querystring argument must be a string.');
            }
            this._parseQueryString(querystring);
        }
    }

    /**
     * Returns ``true`` if the querystring is empty, otherwise ``false``.
     *
     * @returns {boolean}
     */


    _createClass(QueryString, [{
        key: 'isEmpty',
        value: function isEmpty() {
            return this._queryStringMap.size === 0;
        }

        /**
         * Remove all keys and values from the QueryString.
         */

    }, {
        key: 'clear',
        value: function clear() {
            this._queryStringMap.clear();
        }
    }, {
        key: '_parseQueryStringItem',
        value: function _parseQueryStringItem(querystringItem) {
            var splitPair = querystringItem.split('=');
            var key = decodeURIComponent(splitPair[0]);
            var value = decodeURIComponent(splitPair[1]);
            this.append(key, value);
        }
    }, {
        key: '_parseQueryString',
        value: function _parseQueryString(querystring) {
            var splitQueryString = querystring.split('&');
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = splitQueryString[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var querystringItem = _step.value;

                    this._parseQueryStringItem(querystringItem);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }, {
        key: '_addToKey',
        value: function _addToKey(key, value) {
            if (typeof key !== 'string') {
                throw new TypeError('All keys added to a QueryString must be strings.');
            }
            if (typeof value !== 'string') {
                throw new TypeError('All values added to a QueryString must be strings.');
            }
            this._queryStringMap.get(key).push(value);
        }
    }, {
        key: '_setKeyToEmptyArray',
        value: function _setKeyToEmptyArray(key) {
            this._queryStringMap.set(key, []);
        }

        /**
         * Set value from an iterable.
         *
         * @param {string} key The key to set.
         * @param iterable Something that can be iterated with a
         *      ``for(const value of iterable)`` loop.
         *      All the values in the iterable must be strings.
         *      If the iterable is empty the key will be removed
         *      from the QueryString.
         *
         * @example
         * const querystring = QueryString();
         * querystring.setIterable('names', ['Peter', 'Jane']);
         */

    }, {
        key: 'setIterable',
        value: function setIterable(key, iterable) {
            this._setKeyToEmptyArray(key);
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var value = _step2.value;

                    this._addToKey(key, value);
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            if (this._queryStringMap.get(key).length === 0) {
                this.remove(key);
            }
        }

        /**
         * Set a value.
         *
         * @param {string} key The key to store the value as.
         * @param {string} value The value to set.
         *
         * @example
         * const querystring = QueryString();
         * querystring.set('name', 'Peter');
         */

    }, {
        key: 'set',
        value: function set(key, value) {
            this.setIterable(key, [value]);
        }

        /**
         * Get a value.
         *
         * @param {string} key The key to get the value for.
         * @param {string} fallback An optional fallback value if the key is
         *      not in the QueryString. Defaults to ``undefined``.
         */

    }, {
        key: 'get',
        value: function get(key, fallback) {
            var value = this._queryStringMap.get(key);
            if (typeof value === 'undefined') {
                return fallback;
            } else {
                return value[0];
            }
        }

        /**
         * Append a value to a key.
         *
         * @param {string} key The key to append a value to.
         * @param {string} value The value to append.
         *
         * @example
         * const querystring = QueryString();
         * querystring.append('names', 'Jane');
         * querystring.append('names', 'Joe');
         * // querystring.urlencode() === 'names=Jane&names=Joe'
         */

    }, {
        key: 'append',
        value: function append(key, value) {
            if (!this._queryStringMap.has(key)) {
                this._setKeyToEmptyArray(key);
            }
            this._addToKey(key, value);
        }

        /**
         * Get the values for the specified key as an array.
         *
         * Always returns an array, even if the value was set
         * with {@link QueryString#set}.
         *
         * @param {string} key The key to get the values for.
         * @param {Array} fallback An optional fallback value if they
         *      key is not in the QueryString. Defaults to an empty array.
         * @returns {Array}
         */

    }, {
        key: 'getArray',
        value: function getArray(key, fallback) {
            if (this._queryStringMap.has(key)) {
                var valueArray = this._queryStringMap.get(key);
                return Array.from(valueArray);
            }
            if (typeof falback !== 'undefined') {
                return [];
            }
            return fallback;
        }

        /**
         * Remove the specified key from the QueryString.
         *
         * @param {string} key The key to remove.
         */

    }, {
        key: 'remove',
        value: function remove(key) {
            this._queryStringMap.delete(key);
        }

        /**
         * Check if the QueryString contains the given key.
         *
         * @param {string} key The key to check for.
         * @returns {boolean}
         */

    }, {
        key: 'has',
        value: function has(key) {
            return this._queryStringMap.has(key);
        }
    }, {
        key: '_encodeKeyValue',
        value: function _encodeKeyValue(key, value) {
            return encodeURIComponent(key) + '=' + encodeURIComponent(value);
        }

        /**
         * Get the QueryString object as a string in query-string format.
         *
         * @example
         * const querystring = QueryString();
         * querystring.set('next', '/a&b/');
         * querystring.set('name', 'john');
         * let urlEncodedQuerystring = querystring.urlencode();
         * // urlEncodedQuerystring === 'name=john&next=%2Fa%26b%2F'  // order may vary
         */

    }, {
        key: 'urlencode',
        value: function urlencode() {
            var urlEncodedArray = [];
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = this._queryStringMap[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var _step3$value = _slicedToArray(_step3.value, 2),
                        key = _step3$value[0],
                        valueArray = _step3$value[1];

                    var _iteratorNormalCompletion4 = true;
                    var _didIteratorError4 = false;
                    var _iteratorError4 = undefined;

                    try {
                        for (var _iterator4 = valueArray[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                            var value = _step4.value;

                            urlEncodedArray.push(this._encodeKeyValue(key, value));
                        }
                    } catch (err) {
                        _didIteratorError4 = true;
                        _iteratorError4 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                _iterator4.return();
                            }
                        } finally {
                            if (_didIteratorError4) {
                                throw _iteratorError4;
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return urlEncodedArray.join('&');
        }
    }]);

    return QueryString;
}();

exports.default = QueryString;