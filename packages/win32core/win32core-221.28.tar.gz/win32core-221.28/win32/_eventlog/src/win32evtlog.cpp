/*
 * FILE : C:\projects\pypiwin32\win32\src\win32evtlog_swig.cpp
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */

#define SWIGCODE
/* Implementation : PYTHON */

#define SWIGPYTHON
#include <string.h>
#include <stdlib.h>
/***********************************************************************
 * $Header$
 * swig_lib/python/python.cfg
 *
 * This file contains coded needed to add variable linking to the
 * Python interpreter.   C variables are added as a new kind of Python
 * datatype.
 *
 * Also contains supporting code for building python under Windows
 * and things like that.
 *
 * $Log$
 * Revision 1.1  2000/03/14 23:34:06  mhammond
 * Needed to modify a standard Swig file to avoid the 'extern "C"' around Python.h (which gets upset when it tries to include whcar.h as part of the new Unicode patches)
 *
 ************************************************************************/

#include "Python.h"

/* Definitions for Windows/Unix exporting */
#if defined(__WIN32__)
#if defined(_MSC_VER)
#define SWIGEXPORT(a, b) __declspec(dllexport) a b
#else
#if defined(__BORLANDC__)
#define SWIGEXPORT(a, b) a _export b
#else
#define SWIGEXPORT(a, b) a b
#endif
#endif
#else
#define SWIGEXPORT(a, b) a b
#endif

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

#ifdef NEED_SWIG_VARLINK

typedef struct
{
	char *name;
	PyObject *(*get_attr)(void);
	int (*set_attr)(PyObject *);
} swig_globalvar;

typedef struct swig_varlinkobject
{
	PyObject_HEAD
		swig_globalvar **vars;
	int nvars;
	int maxvars;
} swig_varlinkobject;

/* ----------------------------------------------------------------------
   swig_varlink_repr()

   Function for python repr method
   ---------------------------------------------------------------------- */

static PyObject *
swig_varlink_repr(swig_varlinkobject *v)
{
	v = v;
	return PyString_FromString("<Global variables>");
}

/* ---------------------------------------------------------------------
   swig_varlink_print()

   Print out all of the global variable names
   --------------------------------------------------------------------- */

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags)
{

	int i = 0;
	flags = flags;
	fprintf(fp, "Global variables { ");
	while (v->vars[i])
	{
		fprintf(fp, "%s", v->vars[i]->name);
		i++;
		if (v->vars[i])
			fprintf(fp, ", ");
	}
	fprintf(fp, " }\n");
	return 0;
}

/* --------------------------------------------------------------------
   swig_varlink_getattr
 
   This function gets the value of a variable and returns it as a
   PyObject.   In our case, we'll be looking at the datatype and
   converting into a number or string
   -------------------------------------------------------------------- */

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n)
{
	int i = 0;
	char temp[128];

	while (v->vars[i])
	{
		if (strcmp(v->vars[i]->name, n) == 0)
		{
			return (*v->vars[i]->get_attr)();
		}
		i++;
	}
	sprintf(temp, "C global variable %s not found.", n);
	PyErr_SetString(PyExc_NameError, temp);
	return NULL;
}

/* -------------------------------------------------------------------
   swig_varlink_setattr()

   This function sets the value of a variable.
   ------------------------------------------------------------------- */

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p)
{
	char temp[128];
	int i = 0;
	while (v->vars[i])
	{
		if (strcmp(v->vars[i]->name, n) == 0)
		{
			return (*v->vars[i]->set_attr)(p);
		}
		i++;
	}
	sprintf(temp, "C global variable %s not found.", n);
	PyErr_SetString(PyExc_NameError, temp);
	return 1;
}

statichere PyTypeObject varlinktype = {
	/*  PyObject_HEAD_INIT(&PyType_Type)  Note : This doesn't work on some machines */
	PyObject_HEAD_INIT(0) 0,
	"varlink",						   /* Type name    */
	sizeof(swig_varlinkobject),		   /* Basic size   */
	0,								   /* Itemsize     */
	0,								   /* Deallocator  */
	(printfunc)swig_varlink_print,	 /* Print        */
	(getattrfunc)swig_varlink_getattr, /* get attr     */
	(setattrfunc)swig_varlink_setattr, /* Set attr     */
	0,								   /* tp_compare   */
	(reprfunc)swig_varlink_repr,	   /* tp_repr      */
	0,								   /* tp_as_number */
	0,								   /* tp_as_mapping*/
	0,								   /* tp_hash      */
};

/* Create a variable linking object for use later */

SWIGSTATIC PyObject *
SWIG_newvarlink(void)
{
	swig_varlinkobject *result = 0;
	result = PyMem_NEW(swig_varlinkobject, 1);
	varlinktype.ob_type = &PyType_Type; /* Patch varlinktype into a PyType */
	result->ob_type = &varlinktype;
	/*  _Py_NewReference(result);  Does not seem to be necessary */
	result->nvars = 0;
	result->maxvars = 64;
	result->vars = (swig_globalvar **)malloc(64 * sizeof(swig_globalvar *));
	result->vars[0] = 0;
	Py_XINCREF((PyObject *)result);
	return ((PyObject *)result);
}

SWIGSTATIC void
SWIG_addvarlink(PyObject *p, char *name,
				PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p))
{
	swig_varlinkobject *v;
	v = (swig_varlinkobject *)p;

	if (v->nvars >= v->maxvars - 1)
	{
		v->maxvars = 2 * v->maxvars;
		v->vars = (swig_globalvar **)realloc(v->vars, v->maxvars * sizeof(swig_globalvar *));
		if (v->vars == NULL)
		{
			fprintf(stderr, "SWIG : Fatal error in initializing Python module.\n");
			exit(1);
		}
	}
	v->vars[v->nvars] = (swig_globalvar *)malloc(sizeof(swig_globalvar));
	v->vars[v->nvars]->name = (char *)malloc(strlen(name) + 1);
	strcpy(v->vars[v->nvars]->name, name);
	v->vars[v->nvars]->get_attr = get_attr;
	v->vars[v->nvars]->set_attr = set_attr;
	v->nvars++;
	v->vars[v->nvars] = 0;
}

#else
#define SWIG_newvarlink() Py_None
#endif /* SWIG_NEED_VARLINK */
#ifdef NEED_SWIG_PTR
/*****************************************************************************
 * $Header$
 *
 * swigptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is typically used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer which is assumed to hold enough space for the result.
 *
 * char * SWIG_GetPtr(char *buffer, void **ptr, char *type)
 *
 *      Gets a pointer value from a string.  If there is a type-mismatch, returns
 *      a character string to the received type.  On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

/* SWIG pointer structure */

typedef struct SwigPtrType
{
	char *name;				  /* Datatype name                  */
	int len;				  /* Length (used for optimization) */
	void *(*cast)(void *);	/* Pointer casting function       */
	struct SwigPtrType *next; /* Linked list pointer            */
} SwigPtrType;

/* Pointer cache structure */

typedef struct
{
	int stat;		  /* Status (valid) bit             */
	SwigPtrType *tp;  /* Pointer to type structure      */
	char name[256];   /* Given datatype name            */
	char mapped[256]; /* Equivalent name                */
} SwigCacheType;

/* Some variables  */

static int SwigPtrMax = 64; /* Max entries that can be currently held */
							/* This value may be adjusted dynamically */
static int SwigPtrN = 0;	/* Current number of entries              */
static int SwigPtrSort = 0; /* Status flag indicating sort            */
static int SwigStart[256];  /* Starting positions of types            */

/* Pointer table */
static SwigPtrType *SwigPtrTable = 0; /* Table containing pointer equivalences  */

/* Cached values */

#define SWIG_CACHESIZE 8
#define SWIG_CACHEMASK 0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2)
{
	SwigPtrType *d1 = (SwigPtrType *)data1;
	SwigPtrType *d2 = (SwigPtrType *)data2;
	return strcmp(d1->name, d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data)
{
	char *k = (char *)key;
	SwigPtrType *d = (SwigPtrType *)data;
	return strncmp(k, d->name, d->len);
}

/* Register a new datatype with the type-checker */

SWIGSTATIC
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *))
{

	int i;
	SwigPtrType *t = 0, *t1;

	/* Allocate the pointer table if necessary */

	if (!SwigPtrTable)
	{
		SwigPtrTable = (SwigPtrType *)malloc(SwigPtrMax * sizeof(SwigPtrType));
		SwigPtrN = 0;
	}
	/* Grow the table */
	if (SwigPtrN >= SwigPtrMax)
	{
		SwigPtrMax = 2 * SwigPtrMax;
		SwigPtrTable = (SwigPtrType *)realloc((char *)SwigPtrTable, SwigPtrMax * sizeof(SwigPtrType));
	}
	for (i = 0; i < SwigPtrN; i++)
		if (strcmp(SwigPtrTable[i].name, origtype) == 0)
		{
			t = &SwigPtrTable[i];
			break;
		}
	if (!t)
	{
		t = &SwigPtrTable[SwigPtrN];
		t->name = origtype;
		t->len = strlen(t->name);
		t->cast = 0;
		t->next = 0;
		SwigPtrN++;
	}

	/* Check for existing entry */

	while (t->next)
	{
		if ((strcmp(t->name, newtype) == 0))
		{
			if (cast)
				t->cast = cast;
			return;
		}
		t = t->next;
	}

	/* Now place entry (in sorted order) */

	t1 = (SwigPtrType *)malloc(sizeof(SwigPtrType));
	t1->name = newtype;
	t1->len = strlen(t1->name);
	t1->cast = cast;
	t1->next = 0;
	t->next = t1;
	SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC
void SWIG_MakePtr(char *_c, const void *_ptr, char *type)
{
	static char _hex[16] =
		{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		 'a', 'b', 'c', 'd', 'e', 'f'};
	unsigned long _p, _s;
	char _result[20], *_r; /* Note : a 64-bit hex number = 16 digits */
	_r = _result;
	_p = (unsigned long)_ptr;
	if (_p > 0)
	{
		while (_p > 0)
		{
			_s = _p & 0xf;
			*(_r++) = _hex[_s];
			_p = _p >> 4;
		}
		*_r = '_';
		while (_r >= _result)
			*(_c++) = *(_r--);
	}
	else
	{
		strcpy(_c, "NULL");
	}
	if (_ptr)
		strcpy(_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex SWIG_MakePtr

/* Function for getting a pointer value */

SWIGSTATIC
char *SWIG_GetPtr(char *_c, void **ptr, char *_t)
{
	unsigned long _p;
	char temp_type[256];
	char *name;
	int i, len;
	SwigPtrType *sp, *tp;
	SwigCacheType *cache;
	int start, end;
	_p = 0;

	/* Pointer values must start with leading underscore */
	if (*_c == '_')
	{
		_c++;
		/* Extract hex value from pointer */
		while (*_c)
		{
			if ((*_c >= '0') && (*_c <= '9'))
				_p = (_p << 4) + (*_c - '0');
			else if ((*_c >= 'a') && (*_c <= 'f'))
				_p = (_p << 4) + ((*_c - 'a') + 10);
			else
				break;
			_c++;
		}

		if (_t)
		{
			if (strcmp(_t, _c))
			{
				if (!SwigPtrSort)
				{
					qsort((void *)SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);
					for (i = 0; i < 256; i++)
					{
						SwigStart[i] = SwigPtrN;
					}
					for (i = SwigPtrN - 1; i >= 0; i--)
					{
						SwigStart[(int)(SwigPtrTable[i].name[1])] = i;
					}
					for (i = 255; i >= 1; i--)
					{
						if (SwigStart[i - 1] > SwigStart[i])
							SwigStart[i - 1] = SwigStart[i];
					}
					SwigPtrSort = 1;
					for (i = 0; i < SWIG_CACHESIZE; i++)
						SwigCache[i].stat = 0;
				}

				/* First check cache for matches.  Uses last cache value as starting point */
				cache = &SwigCache[SwigLastCache];
				for (i = 0; i < SWIG_CACHESIZE; i++)
				{
					if (cache->stat)
					{
						if (strcmp(_t, cache->name) == 0)
						{
							if (strcmp(_c, cache->mapped) == 0)
							{
								cache->stat++;
								*ptr = (void *)_p;
								if (cache->tp->cast)
									*ptr = (*(cache->tp->cast))(*ptr);
								return (char *)0;
							}
						}
					}
					SwigLastCache = (SwigLastCache + 1) & SWIG_CACHEMASK;
					if (!SwigLastCache)
						cache = SwigCache;
					else
						cache++;
				}
				/* We have a type mismatch.  Will have to look through our type
	     mapping table to figure out whether or not we can accept this datatype */

				start = SwigStart[(int)_t[1]];
				end = SwigStart[(int)_t[1] + 1];
				sp = &SwigPtrTable[start];
				while (start < end)
				{
					if (swigcmp(_t, sp) == 0)
						break;
					sp++;
					start++;
				}
				if (start >= end)
					sp = 0;
				/* Try to find a match for this */
				if (sp)
				{
					while (swigcmp(_t, sp) == 0)
					{
						name = sp->name;
						len = sp->len;
						tp = sp->next;
						/* Try to find entry for our given datatype */
						while (tp)
						{
							if (tp->len >= 255)
							{
								return _c;
							}
							strncpy(temp_type, tp->name, 255);
							strncat(temp_type, _t + len, 255 - tp->len);
							if (strcmp(_c, temp_type) == 0)
							{

								strcpy(SwigCache[SwigCacheIndex].mapped, _c);
								strcpy(SwigCache[SwigCacheIndex].name, _t);
								SwigCache[SwigCacheIndex].stat = 1;
								SwigCache[SwigCacheIndex].tp = tp;
								SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;

								/* Get pointer value */
								*ptr = (void *)_p;
								if (tp->cast)
									*ptr = (*(tp->cast))(*ptr);
								return (char *)0;
							}
							tp = tp->next;
						}
						sp++;
						/* Hmmm. Didn't find it this time */
					}
				}
				/* Didn't find any sort of match for this data.  
	     Get the pointer value and return the received type */
				*ptr = (void *)_p;
				return _c;
			}
			else
			{
				/* Found a match on the first try.  Return pointer value */
				*ptr = (void *)_p;
				return (char *)0;
			}
		}
		else
		{
			/* No type specified.  Good luck */
			*ptr = (void *)_p;
			return (char *)0;
		}
	}
	else
	{
		if (strcmp(_c, "NULL") == 0)
		{
			*ptr = (void *)0;
			return (char *)0;
		}
		*ptr = (void *)0;
		return _c;
	}
}

/* Compatibility mode */

#define _swig_get_hex SWIG_GetPtr

#else
#define SWIG_RegisterMapping(a, b, c)
#endif // NEED_SWIG_PTR
#define SWIG_init initwin32evtlog

#define SWIG_name "win32evtlog"

static PyObject *t_output_helper(PyObject *target, PyObject *o)
{
	PyObject *o2;
	PyObject *o3;

	if (!target)
	{
		target = o;
	}
	else if (target == Py_None)
	{
		Py_DECREF(Py_None);
		target = o;
	}
	else
	{
		if (!PyTuple_Check(target))
		{
			o2 = target;
			target = PyTuple_New(1);
			PyTuple_SetItem(target, 0, o2);
		}
		o3 = PyTuple_New(1);
		PyTuple_SetItem(o3, 0, o);

		o2 = target;
		target = PySequence_Concat(o2, o3);
		Py_DECREF(o2);
		Py_DECREF(o3);
	}
	return target;
}

#include "win32types.h"
#ifdef NEED_PYWINOBJECTS_H
#include "PyWinObjects.h"
#endif
#include "tchar.h"
typedef BOOL BOOLAPI;
typedef DWORD DWORDAPI;

#define PyHANDLE HANDLE // Use a #define so we can undef it later if we need the true defn.
//typedef HANDLE PyHKEY;

#include <structmember.h>

#undef PyHANDLE
#include "PyWinObjects.h"
#include "WinEvt.h"

// @object PyEVTLOG_HANDLE|Object representing a handle to the windows event log.
//   Identical to <o PyHANDLE>, but calls CloseEventLog() on destruction
class PyEVTLOG_HANDLE : public PyHANDLE
{
  public:
	PyEVTLOG_HANDLE(HANDLE hInit) : PyHANDLE(hInit) {}
	virtual BOOL Close(void)
	{
		BOOL ok = m_handle ? CloseEventLog(m_handle) : TRUE;
		m_handle = 0;
		if (!ok)
			PyWin_SetAPIError("CloseEventLog");
		return ok;
	}
	virtual const char *GetTypeName()
	{
		return "PyEVTLOG_HANDLE";
	}
};

// @object PyEVT_HANDLE|Handle to an event log, session, query, or any other object used with
//	the Evt* event log functions on Vista and later.
//	When the object is destroyed, EvtClose is called.
class PyEVT_HANDLE : public PyHANDLE
{
  public:
	PyEVT_HANDLE(HANDLE hInit, PyObject *context) : PyHANDLE(hInit)
	{
		callback_objects = context;
		Py_XINCREF(callback_objects);
	}
	virtual BOOL Close(void)
	{
		BOOL ret = EvtClose(m_handle);
		if (!ret)
			PyWin_SetAPIError("EvtClose");
		m_handle = 0;
		Py_XDECREF(callback_objects);
		callback_objects = NULL;
		return ret;
	}
	virtual const char *GetTypeName()
	{
		return "PyEVT_HANDLE";
	}
	// Only used with push subscription handles.  Will be a 2-tuple
	// that keeps references to the callback function and context object
	PyObject *callback_objects;
};

#define PyHANDLE HANDLE

PyObject *PyWinObject_FromEVTLOG_HANDLE(HANDLE h)
{
	PyObject *ret = new PyEVTLOG_HANDLE(h);
	if (!ret)
		PyErr_NoMemory();
	return ret;
}

PyObject *PyWinObject_FromEVT_HANDLE(HANDLE h, PyObject *context = NULL)
{
	PyObject *ret = new PyEVT_HANDLE(h, context);
	if (ret == NULL)
	{
		EvtClose(h);
		PyErr_NoMemory();
	}
	return ret;
}

#define PyEVTLOG_HANDLE HANDLE

// @object PyEventLogRecord|An object containing the data in an EVENTLOGRECORD.
class PyEventLogRecord : public PyObject
{
  public:
	PyEventLogRecord(EVENTLOGRECORD *pEvt);
	~PyEventLogRecord(void);

	static void deallocFunc(PyObject *ob);
	static struct PyMemberDef members[];

  protected:
	DWORD Reserved;
	DWORD RecordNumber;
	PyObject *TimeGenerated;
	PyObject *TimeWritten;
	DWORD EventID;
	WORD EventType;
	PyObject *SourceName;
	PyObject *StringInserts;
	WORD EventCategory;
	WORD ReservedFlags;
	DWORD ClosingRecordNumber;
	PyObject *Sids;
	PyObject *Data;
	PyObject *ComputerName;
};

/*
PyObject *PyWinMethod_NewEventLogRecord(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":EventLogRecord"))
		return NULL;
	return new PyEventLogRecord();
}
*/

PyTypeObject PyEventLogRecordType =
	{
		PYWIN_OBJECT_HEAD
		"PyEventLogRecord",
		sizeof(PyEventLogRecord),
		0,
		PyEventLogRecord::deallocFunc, /* tp_dealloc */
		0,							   /* tp_print */
		0,							   /* tp_getattr */
		0,							   /* tp_setattr */
		0,							   /* tp_compare */
		0,							   /* tp_repr */
		0,							   /* tp_as_number */
		0,							   /* tp_as_sequence */
		0,							   /* tp_as_mapping */
		0,							   /* tp_hash */
		0,							   /* tp_call */
		0,							   /* tp_str */
		PyObject_GenericGetAttr,	   /* tp_getattro */
		PyObject_GenericSetAttr,	   /* tp_setattro */
		0,							   /*tp_as_buffer*/
		Py_TPFLAGS_DEFAULT,			   /* tp_flags */
		0,							   /* tp_doc */
		0,							   /* tp_traverse */
		0,							   /* tp_clear */
		0,							   /* tp_richcompare */
		0,							   /* tp_weaklistoffset */
		0,							   /* tp_iter */
		0,							   /* tp_iternext */
		0,							   /* tp_methods */
		PyEventLogRecord::members,	 /* tp_members */
		0,							   /* tp_getset */
		0,							   /* tp_base */
		0,							   /* tp_dict */
		0,							   /* tp_descr_get */
		0,							   /* tp_descr_set */
		0,							   /* tp_dictoffset */
		0,							   /* tp_init */
		0,							   /* tp_alloc */
		0,							   /* tp_new */
};

#define OFF(e) offsetof(PyEventLogRecord, e)

/*static*/ struct PyMemberDef PyEventLogRecord::members[] = {
	{"Reserved", T_INT, OFF(Reserved)},						  // @prop integer|Reserved|
	{"RecordNumber", T_INT, OFF(RecordNumber)},				  // @prop integer|RecordNumber|
	{"TimeGenerated", T_OBJECT, OFF(TimeGenerated)},		  // @prop <o PyTime>|TimeGenerated|
	{"TimeWritten", T_OBJECT, OFF(TimeWritten)},			  // @prop <o PyTime>|TimeWritten|
	{"EventID", T_INT, OFF(EventID)},						  // @prop integer|EventID|
	{"EventType", T_SHORT, OFF(EventType)},					  // @prop integer|EventType|
	{"EventCategory", T_SHORT, OFF(EventCategory)},			  // @prop integer|EventCategory|
	{"ReservedFlags", T_SHORT, OFF(ReservedFlags)},			  // @prop integer|ReservedFlags|
	{"ClosingRecordNumber", T_INT, OFF(ClosingRecordNumber)}, // @prop integer|ClosingRecordNumber|
	{"SourceName", T_OBJECT, OFF(SourceName)},				  // @prop <o PyUnicode>|SourceName|
	{"StringInserts", T_OBJECT, OFF(StringInserts)},		  // @prop (<o PyUnicode>,...)|StringInserts|
	{"Sid", T_OBJECT, OFF(Sids)},							  // @prop <o PySID>|Sid|
	{"Data", T_OBJECT, OFF(Data)},							  // @prop string|Data|
	{"ComputerName", T_OBJECT, OFF(ComputerName)},			  // @prop <o PyUnicode>|ComputerName|
	{NULL}};

PyEventLogRecord::PyEventLogRecord(EVENTLOGRECORD *pEvt)
{
	ob_type = &PyEventLogRecordType;
	_Py_NewReference(this);
	Reserved = RecordNumber = EventID = ClosingRecordNumber = 0;
	TimeWritten = TimeGenerated = SourceName = ComputerName = StringInserts = Sids = Data = NULL;
	EventType = EventCategory = ReservedFlags = 0;
	if (pEvt == NULL) // Empty one.
		return;

	Reserved = pEvt->Reserved;
	RecordNumber = pEvt->RecordNumber;
	EventID = pEvt->EventID;
	EventType = pEvt->EventType;
	EventCategory = pEvt->EventCategory;
	ReservedFlags = pEvt->ReservedFlags;
	ClosingRecordNumber = pEvt->ClosingRecordNumber;

	if (pEvt->NumStrings == 0)
	{
		StringInserts = Py_None;
		Py_INCREF(Py_None);
	}
	else
	{
		StringInserts = PyTuple_New(pEvt->NumStrings);
		if (StringInserts)
		{
			WCHAR *stringOffset = (WCHAR *)(((BYTE *)pEvt) + pEvt->StringOffset);
			for (DWORD stringNo = 0; stringNo < pEvt->NumStrings; stringNo++)
			{
				PyTuple_SET_ITEM(StringInserts, (int)stringNo, PyWinObject_FromWCHAR(stringOffset));
				stringOffset = stringOffset + (wcslen(stringOffset)) + 1;
			}
		}
	}

	TimeGenerated = PyWinTimeObject_Fromtime_t((time_t)pEvt->TimeGenerated);
	TimeWritten = PyWinTimeObject_Fromtime_t((time_t)pEvt->TimeWritten);

	if (pEvt->UserSidLength == 0)
	{
		Sids = Py_None; // No SID in this record.
		Py_INCREF(Sids);
	}
	else
	{
		Sids = PyWinObject_FromSID((PSID)(((BYTE *)pEvt) + pEvt->UserSidOffset));
	}

	Data = PyString_FromStringAndSize(((char *)pEvt) + pEvt->DataOffset, pEvt->DataLength);

	WCHAR *szSourceName = (WCHAR *)(((BYTE *)pEvt) + sizeof(EVENTLOGRECORD));
	SourceName = PyWinObject_FromWCHAR(szSourceName);

	ComputerName = PyWinObject_FromWCHAR(szSourceName + wcslen(szSourceName) + 1);
}

PyEventLogRecord::~PyEventLogRecord(void)
{
	Py_XDECREF(TimeWritten);
	Py_XDECREF(TimeGenerated);
	Py_XDECREF(SourceName);
	Py_XDECREF(StringInserts);
	Py_XDECREF(Sids);
	Py_XDECREF(Data);
	Py_XDECREF(ComputerName);
}

/*static*/ void PyEventLogRecord::deallocFunc(PyObject *ob)
{
	delete (PyEventLogRecord *)ob;
}

PyObject *MakeEventLogObject(BYTE *buf, DWORD numBytes)
{
	PyObject *ret = PyList_New(0);
	if (ret == NULL)
		return NULL;
	while (numBytes > 0)
	{
		EVENTLOGRECORD *pEvt = (EVENTLOGRECORD *)buf;
		PyObject *subItem = new PyEventLogRecord(pEvt);
		if (subItem == NULL)
		{
			Py_DECREF(ret);
			PyErr_SetString(PyExc_MemoryError, "Allocating EventLogRecord object");
			return NULL;
		}
		PyList_Append(ret, subItem);
		Py_DECREF(subItem);
		buf = buf + pEvt->Length;
		numBytes -= pEvt->Length;
	}
	return ret;
}

PyObject *_MyReadEventLog(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, DWORD nNumberOfBytesToRead)
{
	DWORD needed = nNumberOfBytesToRead, read;
	BYTE *buf;
	BOOL ok;
	while (1)
	{
		buf = (BYTE *)malloc(needed);
		if (buf == NULL)
		{
			PyErr_SetString(PyExc_MemoryError, "Allocating initial buffer");
			return NULL;
		}
		Py_BEGIN_ALLOW_THREADS
			ok = ReadEventLogW(hEventLog, dwReadFlags, dwRecordOffset, buf, needed, &read, &needed);
		Py_END_ALLOW_THREADS if (!ok)
		{
			DWORD err = GetLastError();
			if (err == ERROR_HANDLE_EOF)
			{
				read = 0; // pretend everything is OK...
				break;
			}
			else if (err == ERROR_INSUFFICIENT_BUFFER)
			{
				free(buf);
				continue; // try again.
			}
			else
			{
				free(buf);
				return PyWin_SetAPIError("ReadEventLog");
			}
		}
		else break;
	}
	// Convert the object.
	PyObject *ret = MakeEventLogObject(buf, read);
	free(buf);
	return ret;
}

#define EVTLOG_READ_BUF_LEN_MAX 0x7ffff
#define EVTLOG_READ_BUF_LEN_DEFAULT 0x1000

// @pyswig [object,...]|ReadEventLog|Reads some event log records.
// @rdesc If there are no event log records available, then an empty list is returned.
PyObject *MyReadEventLog(PyObject *self, PyObject *args)
{
	HANDLE hEventLog = INVALID_HANDLE_VALUE;
	DWORD dwReadFlags, dwRecordOffset, nNumberOfBytesToRead = EVTLOG_READ_BUF_LEN_DEFAULT;
	if (!PyArg_ParseTuple(args, "O&kk|k:ReadEventLog",
						  PyWinObject_AsHANDLE, &hEventLog, // @pyparm <o Py_HANDLE>|Handle||Handle to a an opened event log (see <om win32evtlog.OpenEventLog>)
						  &dwReadFlags,						// @pyparm int|Flags||Reading flags
						  &dwRecordOffset,					// @pyparm int|Offset||Record offset to read (in SEEK mode).
						  &nNumberOfBytesToRead))			// @pyparm int|Size|4096|Output buffer size.
		return NULL;
	if (nNumberOfBytesToRead == 0)
		nNumberOfBytesToRead = EVTLOG_READ_BUF_LEN_DEFAULT;
	if (nNumberOfBytesToRead > EVTLOG_READ_BUF_LEN_MAX)
		nNumberOfBytesToRead = EVTLOG_READ_BUF_LEN_MAX;
	return _MyReadEventLog(hEventLog, dwReadFlags, dwRecordOffset, nNumberOfBytesToRead);
}

PyObject *MyReportEvent(HANDLE hEventLog,
						WORD wType,			 // event type to log
						WORD wCategory,		 // event category
						DWORD dwEventID,	 // event identifier
						PyObject *obSID,	 // user security identifier object (optional)
						PyObject *obStrings, // insert strings
						PyObject *obData)	// raw data
{
	PyObject *rc = NULL;
	DWORD numStrings = 0;
	WCHAR **pStrings = NULL;
	DWORD dataSize = 0;
	void *pData;
	PSID sid;
	if (!PyWinObject_AsSID(obSID, &sid, TRUE))
		return NULL;
	if (!PyWinObject_AsReadBuffer(obData, &pData, &dataSize, TRUE))
		return NULL;
	if (!PyWinObject_AsWCHARArray(obStrings, &pStrings, &numStrings, TRUE))
		return NULL;
	if (numStrings > USHRT_MAX)
	{
		PyErr_Format(PyExc_ValueError, "String inserts can contain at most %d strings", USHRT_MAX);
		goto cleanup;
	}
	BOOL ok;
	Py_BEGIN_ALLOW_THREADS
		ok = ReportEventW(hEventLog, wType, wCategory, dwEventID, sid, (WORD)numStrings, dataSize, (const WCHAR **)pStrings, pData);
	Py_END_ALLOW_THREADS

		if (!ok)
	{
		PyWin_SetAPIError("ReportEvent");
		goto cleanup;
	}
	Py_INCREF(Py_None);
	rc = Py_None;
cleanup:
	PyWinObject_FreeWCHARArray(pStrings, numStrings);
	return rc;
}

// New event log functions available on Vista and later
// @pyswig <o PyEVT_HANDLE>|EvtOpenChannelEnum|Begins an enumeration of event channels
// @comm Accepts keyword args
static PyObject *PyEvtOpenChannelEnum(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Session", "Flags", NULL};
	EVT_HANDLE session = NULL, enum_handle;
	DWORD flags = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O&k:EvtOpenChannelEnum", keywords,
									 PyWinObject_AsHANDLE, &session, // @pyparm <o PyEVT_HANDLE>|Session|None|Handle to a remote session (see <om win32evtlog.EvtOpenSession>), or None for local machine.
									 &flags))						 // @pyparm int|Flags|0|Reserved, use only 0
		return NULL;
	Py_BEGIN_ALLOW_THREADS
		enum_handle = EvtOpenChannelEnum(session, flags);
	Py_END_ALLOW_THREADS if (enum_handle == NULL) return PyWin_SetAPIError("EvtOpenChannelEnum");
	return PyWinObject_FromEVT_HANDLE(enum_handle);
}
PyCFunction pfnPyEvtOpenChannelEnum = (PyCFunction)PyEvtOpenChannelEnum;

// @pyswig str|EvtNextChannelPath|Retrieves a channel path from an enumeration
// @rdesc Returns None at end of enumeration
// @comm Accepts keyword args
static PyObject *PyEvtNextChannelPath(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"ChannelEnum", NULL};
	EVT_HANDLE enum_handle;
	DWORD allocated_size = 256, returned_size, err;
	WCHAR *buf = NULL;
	PyObject *ret = NULL;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&:EvtNextChannelPath", keywords,
									 PyWinObject_AsHANDLE, &enum_handle)) // @pyparm <o PyEVT_HANDLE>|ChannelEnum||Handle to an enumeration as returned by <om win32evtlog.EvtOpenChannelEnum>
		return NULL;
	BOOL bsuccess;
	while (true)
	{
		if (buf)
			free(buf);
		// MSDN docs say sizes are in bytes, but it doesn't seem to be so ???
		WCHAR *buf = (WCHAR *)malloc(allocated_size * sizeof(WCHAR));
		if (!buf)
			return NULL;

		Py_BEGIN_ALLOW_THREADS
			bsuccess = EvtNextChannelPath(enum_handle, allocated_size, buf, &returned_size);
		Py_END_ALLOW_THREADS if (bsuccess)
		{
			ret = PyWinObject_FromWCHAR(buf);
			break;
		}
		err = GetLastError();
		if (err == ERROR_INSUFFICIENT_BUFFER)
		{
			allocated_size = returned_size;
			continue;
		}
		if (err == ERROR_NO_MORE_ITEMS)
		{
			Py_INCREF(Py_None);
			ret = Py_None;
			break;
		}
		PyWin_SetAPIError("EvtNextChannelPath", err);
		break;
	}
	if (buf)
		free(buf);
	return ret;
}
PyCFunction pfnPyEvtNextChannelPath = (PyCFunction)PyEvtNextChannelPath;

// @pyswig <o PyEVT_HANDLE>|EvtOpenLog|Opens an event log or exported log archive
// @comm Accepts keyword args
static PyObject *PyEvtOpenLog(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Path", "Flags", "Session", NULL};
	EVT_HANDLE session = NULL, log_handle;
	DWORD flags = 0;
	WCHAR *path;
	PyObject *obpath;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Ok|O&:EvtOpenLog", keywords,
									 &obpath,						  // @pyparm str|Path||Event log name or Path of an export file
									 &flags,						  // @pyparm int|Flags||EvtOpenChannelPath (1) or EvtOpenFilePath (2)
									 PyWinObject_AsHANDLE, &session)) // @pyparm <o PyEVT_HANDLE>|Session|None|Handle to a remote session (see <om win32evtlog.EvtOpenSession>), or None for local machine.
		return NULL;
	if (!PyWinObject_AsWCHAR(obpath, &path, FALSE))
		return NULL;
	Py_BEGIN_ALLOW_THREADS
		log_handle = EvtOpenLog(session, path, flags);
	Py_END_ALLOW_THREADS
		PyWinObject_FreeWCHAR(path);
	if (log_handle == NULL)
		return PyWin_SetAPIError("EvtOpenLog");
	return PyWinObject_FromEVT_HANDLE(log_handle);
}
PyCFunction pfnPyEvtOpenLog = (PyCFunction)PyEvtOpenLog;

// @pyswig |EvtClearLog|Clears an event log and optionally exports events to an archive
// @comm Accepts keyword args
static PyObject *PyEvtClearLog(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"ChannelPath", "TargetFilePath", "Session", "Flags", NULL};
	EVT_HANDLE session = NULL;
	DWORD flags = 0;
	TmpWCHAR path, export_path;
	PyObject *obpath, *obexport_path = Py_None;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|OO&k:EvtClearLog", keywords,
									 &obpath,						 // @pyparm str|ChannelPath||Name of event log to be cleared
									 &obexport_path,				 // @pyparm str|TargetFilePath|None|Name of file in which cleared events will be archived, or None
									 PyWinObject_AsHANDLE, &session, // @pyparm <o PyEVT_HANDLE>|Session|None|Handle to a remote session (see <om win32evtlog.EvtOpenSession>), or None for local machine.
									 &flags))						 // @pyparm int|Flags|0|Reserved, use only 0
		return NULL;
	if (!PyWinObject_AsWCHAR(obpath, &path, FALSE))
		return NULL;
	if (!PyWinObject_AsWCHAR(obexport_path, &export_path, TRUE))
		return NULL;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtClearLog(session, path, export_path, flags);
	Py_END_ALLOW_THREADS if (bsuccess)
	{
		Py_INCREF(Py_None);
		return Py_None;
	}
	return PyWin_SetAPIError("EvtClearLog");
}
PyCFunction pfnPyEvtClearLog = (PyCFunction)PyEvtClearLog;

// @pyswig |EvtExportLog|Exports events from a channel or log file
// @comm Accepts keyword args
static PyObject *PyEvtExportLog(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Path", "TargetFilePath", "Flags", "Query", "Session", NULL};
	EVT_HANDLE session = NULL;
	DWORD flags = 0;
	TmpWCHAR path, query, export_path;
	PyObject *obpath, *obexport_path, *obquery = Py_None;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOk|OO&:EvtExportLog", keywords,
									 &obpath,						  // @pyparm str|Path||Path of a live event log channel or exported log file
									 &obexport_path,				  // @pyparm str|TargetFilePath||File to create, cannot already exist
									 &flags,						  // @pyparm int|Flags||Combination of EvtExportLog* flags specifying the type of path
									 &obquery,						  // @pyparm str|Query|None|Selects specific events to export
									 PyWinObject_AsHANDLE, &session)) // @pyparm <o PyEVT_HANDLE>|Session|None|Handle to a remote session (see <om win32evtlog.EvtOpenSession>), or None for local machine.
		return NULL;
	if (!PyWinObject_AsWCHAR(obpath, &path, FALSE))
		return NULL;
	if (!PyWinObject_AsWCHAR(obexport_path, &export_path, FALSE))
		return NULL;
	if (!PyWinObject_AsWCHAR(obquery, &query, TRUE))
		return NULL;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtExportLog(session, path, query, export_path, flags);
	Py_END_ALLOW_THREADS if (bsuccess)
	{
		Py_INCREF(Py_None);
		return Py_None;
	}
	return PyWin_SetAPIError("EvtExportLog");
}
PyCFunction pfnPyEvtExportLog = (PyCFunction)PyEvtExportLog;

// @pyswig |EvtArchiveExportedLog|Localizes an exported event log file
// @comm Accepts keyword args
static PyObject *PyEvtArchiveExportedLog(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"LogFilePath", "Locale", "Session", "Flags", NULL};
	EVT_HANDLE session = NULL;
	DWORD flags = 0;
	TmpWCHAR path;
	LCID lcid;
	PyObject *obpath;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Ol|O&k:EvtArchiveExportedLog", keywords,
									 &obpath,						 // @pyparm str|LogFilePath||Filename of an exported log file
									 &lcid,							 // @pyparm int|Locale||Locale id
									 PyWinObject_AsHANDLE, &session, // @pyparm <o PyEVT_HANDLE>|Session|None|Handle to a remote session (see <om win32evtlog.EvtOpenSession>), or None for local machine.
									 &flags))						 // @pyparm int|Flags|0|Reserved
		return NULL;
	if (!PyWinObject_AsWCHAR(obpath, &path, FALSE))
		return NULL;

	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtArchiveExportedLog(session, path, lcid, flags);
	Py_END_ALLOW_THREADS if (bsuccess)
	{
		Py_INCREF(Py_None);
		return Py_None;
	}
	return PyWin_SetAPIError("EvtArchiveExportedLog");
}
PyCFunction pfnPyEvtArchiveExportedLog = (PyCFunction)PyEvtArchiveExportedLog;

// @pyswig str|EvtGetExtendedStatus|Returns additional error info from last Evt* call
static PyObject *PyEvtGetExtendedStatus(PyObject *self, PyObject *args)
{
	DWORD buflen = 0, bufneeded = 1024;
	WCHAR *msg = NULL;
	PyObject *ret = NULL;
	if (!PyArg_ParseTuple(args, ":EvtGetExtendedStatus"))
		return NULL;

	BOOL bsuccess;
	while (1)
	{
		if (msg)
			free(msg);
		buflen = bufneeded;
		msg = (WCHAR *)malloc(buflen * sizeof(WCHAR));
		if (msg == NULL)
		{
			PyErr_NoMemory();
			return NULL;
		}
		Py_BEGIN_ALLOW_THREADS
			bsuccess = EvtGetExtendedStatus(buflen, msg, &bufneeded);
		Py_END_ALLOW_THREADS if (bsuccess)
		{
			ret = PyWinObject_FromWCHAR(msg, bufneeded);
			break;
		}
		if (bufneeded <= buflen)
		{
			PyWin_SetAPIError("EvtGetExtendedStatus");
			break;
		}
	}
	if (msg)
		free(msg);
	return ret;
}

// @pyswig <o PyEVT_HANDLE>|EvtQuery|Opens a query over a log channel or exported log file
// @comm Accepts keyword args
static PyObject *PyEvtQuery(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Path", "Flags", "Query", "Session", NULL};
	EVT_HANDLE ret, session = NULL;
	DWORD flags;
	TmpWCHAR path, query;
	PyObject *obpath, *obquery = Py_None;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Ol|OO&:EvtQuery", keywords,
									 &obpath,						  // @pyparm str|Path||Log channel or exported log file, depending on Flags
									 &flags,						  // @pyparm int|Flags||Combination of EVT_QUERY_FLAGS (EvtQuery*)
									 &obquery,						  // @pyparm str|Query|None|Selects events to return, None or '*' for all events
									 PyWinObject_AsHANDLE, &session)) // @pyparm <o PyEVT_HANDLE>|Session|None|Handle to a remote session (see <om win32evtlog.EvtOpenSession>), or None for local machine.
		return NULL;
	if (!PyWinObject_AsWCHAR(obpath, &path, FALSE))
		return NULL;
	if (!PyWinObject_AsWCHAR(obquery, &query, TRUE))
		return NULL;
	Py_BEGIN_ALLOW_THREADS
		ret = EvtQuery(session, path, query, flags);
	Py_END_ALLOW_THREADS if (ret == NULL) return PyWin_SetAPIError("EvtQuery");
	return PyWinObject_FromEVT_HANDLE(ret);
}
PyCFunction pfnPyEvtQuery = (PyCFunction)PyEvtQuery;

// @pyswig (<o PyEVT_HANDLE>,...)|EvtNext|Returns events from a query
// @rdesc Returns a tuple of handles to events.  If no items are available, returns
//	an empty tuple instead of raising an exception.
// @comm Accepts keyword args
static PyObject *PyEvtNext(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"ResultSet", "Count", "Timeout", "Flags", NULL};
	EVT_HANDLE query;
	EVT_HANDLE *events = NULL;
	DWORD nbr_requested, nbr_returned, flags = 0, timeout = (DWORD)-1;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&k|kk:EvtNext", keywords,
									 PyWinObject_AsHANDLE, &query, // @pyparm <o PyEVT_HANDLE>|ResultSet||Handle to event query or subscription
									 &nbr_requested,			   // @pyparm int|Count||Number of events to return
									 &timeout,					   // @pyparm int|Timeout|-1|Time to wait in milliseconds, use -1 for infinite
									 &flags))					   // @pyparm int|Flags|0|Reserved, use only 0
		return NULL;
	events = (EVT_HANDLE *)malloc(nbr_requested * sizeof(EVT_HANDLE *));
	if (events == NULL)
	{
		PyErr_NoMemory();
		return NULL;
	}
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtNext(query, nbr_requested, events, timeout, flags, &nbr_returned);
	Py_END_ALLOW_THREADS if (!bsuccess)
	{
		free(events);
		DWORD err = GetLastError();
		if (err == ERROR_NO_MORE_ITEMS)
			return PyTuple_New(0);
		return PyWin_SetAPIError("EvtNext", err);
	}

	// If tuple construction fails, any handle not yet wrapped in a PyEVT_HANDLE
	// will be orphaned and remain open.  Should be a rare occurence, though.
	PyObject *ret = PyTuple_New(nbr_returned);
	if (ret)
	{
		for (DWORD i = 0; i < nbr_returned; i++)
		{
			PyObject *obevt = PyWinObject_FromEVT_HANDLE(events[i]);
			if (obevt == NULL)
			{
				Py_DECREF(ret);
				ret = NULL;
				break;
			}
			PyTuple_SET_ITEM(ret, i, obevt);
		}
	}
	free(events);
	return ret;
}
PyCFunction pfnPyEvtNext = (PyCFunction)PyEvtNext;

// @pyswig |EvtSeek|Changes the current position in a result set
// @comm Accepts keyword args
static PyObject *PyEvtSeek(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"ResultSet", "Position", "Flags", "Bookmark", "Timeout", NULL};
	EVT_HANDLE query, bookmark = NULL;
	DWORD flags, timeout = 0;
	LONGLONG position;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&Lk|O&k:EvtSeek", keywords,
									 PyWinObject_AsHANDLE, &query,	// @pyparm <o PyEVT_HANDLE>|ResultSet||Handle to event query or subscription
									 &position,						  // @pyparm int|Position||Offset (base from which to seek is specified by Flags)
									 &flags,						  // @pyparm int|Flags||EvtSeekRelative* flag indicating seek origin
									 PyWinObject_AsHANDLE, &bookmark, // @pyparm <o PyEVT_HANDLE>|Bookmark|None|Used as seek origin only if Flags contains EvtSeekRelativeToBookmark
									 &timeout))						  // @pyparm int|Timeout|0|Reserved, use only 0
		return NULL;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtSeek(query, position, bookmark, timeout, flags);
	Py_END_ALLOW_THREADS if (!bsuccess) return PyWin_SetAPIError("EvtSeek");
	Py_INCREF(Py_None);
	return Py_None;
	;
}
PyCFunction pfnPyEvtSeek = (PyCFunction)PyEvtSeek;

// @pyswig str|EvtRender|Formats an event into XML text
// @comm Accepts keyword args
// @comm Rendering event values (Flags=EvtRenderEventValues) is not currently supported
static PyObject *PyEvtRender(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Event", "Flags", NULL};
	EVT_HANDLE event;
	void *buf = NULL;
	DWORD flags, bufsize = 2048, bufneeded, propcount;
	PyObject *ret = NULL;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&k:EvtRender", keywords,
									 PyWinObject_AsHANDLE, &event, // @pyparm <o PyEVT_HANDLE>|Event||Handle to an event or bookmark
									 &flags))					   // @pyparm int|Flags||EvtRenderEventXml or EvtRenderBookmark indicating type of handle
		return NULL;
	if (flags == EvtRenderEventValues)
	{
		// Requires yet another type of VARIANT
		PyErr_Format(PyExc_NotImplementedError, "Rendering values is not yet supported");
		return NULL;
	}
	BOOL bsuccess;
	while (1)
	{
		if (buf)
			free(buf);
		buf = malloc(bufsize);
		if (buf == NULL)
		{
			PyErr_NoMemory();
			return NULL;
		}

		Py_BEGIN_ALLOW_THREADS
			bsuccess = EvtRender(NULL, event, flags, bufsize, buf, &bufneeded, &propcount);
		Py_END_ALLOW_THREADS if (bsuccess)
		{
			ret = PyWinObject_FromWCHAR((WCHAR *)buf);
			break;
		}
		DWORD err = GetLastError();
		if (err == ERROR_INSUFFICIENT_BUFFER)
			bufsize = bufneeded;
		else
		{
			PyWin_SetAPIError("EvtRender", err);
			break;
		}
	}
	free(buf);
	return ret;
}
PyCFunction pfnPyEvtRender = (PyCFunction)PyEvtRender;

DWORD CALLBACK PyEvtSubscribe_callback(
	EVT_SUBSCRIBE_NOTIFY_ACTION action,
	void *context,
	EVT_HANDLE event)
{
	CEnterLeavePython celp;
	DWORD err = 0;
	PyObject *func = PyTuple_GET_ITEM((PyObject *)context, 0);
	PyObject *obcontext = PyTuple_GET_ITEM((PyObject *)context, 1);
	PyObject *args = Py_BuildValue("kOO", action, obcontext, PyWinLong_FromHANDLE(event));
	if (args == NULL)
	{
		// ??? Docs don't specify what happens when you return an error from callback
		// Need to check if subscription handle is closed ???
		PyErr_Print();
		return ERROR_OUTOFMEMORY;
	}
	PyObject *ret = PyObject_Call(func, args, NULL);
	if (ret == NULL)
	{
		// Nothing to be done about an exception raised by the python callback
		PyErr_Print();
		err = ERROR_OUTOFMEMORY;
	}
	else if (ret != Py_None)
	{
		// Allow the callback to return an error
		err = PyLong_AsUnsignedLong(ret);
		if (err == (DWORD)-1 && PyErr_Occurred())
		{
			PyErr_Print();
			err = 0;
		}
	}

	Py_DECREF(args);
	Py_XDECREF(ret);
	return err;
}

// @pyswig <o PyEVT_HANDLE>|EvtSubscribe|Requests notification for events
// @comm Accepts keyword args
// @comm The method used to receive events is determined by the parameters passed in.
//	To create a push subscription, define a callback function that will be called with each event.
//	The function will receive 3 args:
//		First is an integer specifying why the function was called (EvtSubscribeActionError or EvtSubscribeActionDeliver)
//		Second is the context object passed to EvtSubscribe.
//		Third is the handle to an event log record (if not called due to an error)
//	If an event handle is passed in, a pull subscription is created.  The event handle will be
//	signalled when events are available, and the subscription handle can be
//	passed to <om win32evtlog.EvtNext> to obtain the events.

static PyObject *PyEvtSubscribe(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"ChannelPath", "Flags", "SignalEvent", "Callback", "Context",
							   "Query", "Session", "Bookmark", NULL};
	EVT_HANDLE session = NULL, bookmark = NULL, ret;
	HANDLE signalevent = NULL;
	TmpWCHAR path, query;
	PyObject *obpath, *obcallback = Py_None, *obquery = Py_None, *obcontext = Py_None;
	TmpPyObject obuserdata; // actual context passed to C++ callback - tuple of (function, context object)
	DWORD flags;
	EVT_SUBSCRIBE_CALLBACK pfncallback = NULL;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Ok|O&OOOO&O&:EvtSubscribe", keywords,
									 &obpath,							 // @pyparm str|ChannelPath||Name of an event log channel
									 &flags,							 // @pyparm int|Flags||Combination of EvtSubscribe* flags determining how subscription is initiated
									 PyWinObject_AsHANDLE, &signalevent, // @pyparm <o Py_HANDLE>|SignalEvent|None|An event handle to be set when events are available (see <om win32event.CreateEvent>)
									 &obcallback,						 // @pyparm function|Callback|None|Python function to be called with each event
									 &obcontext,						 // @pyparm object|Context|None|Arbitrary object to be passed to the callback function
									 &obquery,							 // @pyparm str|Query|None|XML query used to select specific events, use None or '*' for all events
									 PyWinObject_AsHANDLE, &session,	 // @pyparm <o PyEVT_HANDLE>|Session|None|Handle to a session on another machine, or None for local
									 PyWinObject_AsHANDLE, &bookmark))   // @pyparm <o PyEVT_HANDLE>|Bookmark|None|If Flags contains EvtSubscribeStartAfterBookmark, used as starting point
		return NULL;

	if (!PyWinObject_AsWCHAR(obpath, &path, FALSE))
		return NULL;
	if (!PyWinObject_AsWCHAR(obquery, &query, TRUE))
		return NULL;
	if (obcallback != Py_None)
	{
		pfncallback = PyEvtSubscribe_callback;
		obuserdata = Py_BuildValue("OO", obcallback, obcontext);
		if (obuserdata == NULL)
			return NULL;
	}
	Py_BEGIN_ALLOW_THREADS
		ret = EvtSubscribe(session, signalevent, path, query, bookmark,
						   (void *)obuserdata, pfncallback, flags);
	Py_END_ALLOW_THREADS if (ret == NULL) return PyWin_SetAPIError("EvtSubscribe");
	return PyWinObject_FromEVT_HANDLE(ret, obuserdata);
}
PyCFunction pfnPyEvtSubscribe = (PyCFunction)PyEvtSubscribe;

// @pyswig <o PyEVT_HANDLE>|EvtCreateBookmark|Creates a bookmark
// @comm Accepts keyword args
static PyObject *PyEvtCreateBookmark(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"BookmarkXML", NULL};
	EVT_HANDLE ret;
	TmpWCHAR xml;
	PyObject *obxml = Py_None;
	// @pyparm str|BookmarkXML|None|XML representation of a bookmark as returned by <om win32evtlog.EvtRender>, or None for a new bookmark
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:EvtCreateBookmark", keywords,
									 &obxml))
		return NULL;
	if (!PyWinObject_AsWCHAR(obxml, &xml, TRUE))
		return NULL;
	Py_BEGIN_ALLOW_THREADS
		ret = EvtCreateBookmark(xml);
	Py_END_ALLOW_THREADS if (ret == NULL) return PyWin_SetAPIError("EvtCreateBookmark");
	return PyWinObject_FromEVT_HANDLE(ret);
}
PyCFunction pfnPyEvtCreateBookmark = (PyCFunction)PyEvtCreateBookmark;

// @pyswig <o PyEVT_HANDLE>|EvtUpdateBookmark|Repositions a bookmark to an event
// @comm Accepts keyword args
static PyObject *PyEvtUpdateBookmark(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Bookmark", "Event", NULL};
	EVT_HANDLE bookmark, evt;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&O&:EvtUpdateBookmark", keywords,
									 PyWinObject_AsHANDLE, &bookmark, // @pyparm <o PyEVT_HANDLE>|Bookmark||Handle to a bookmark
									 PyWinObject_AsHANDLE, &evt))	 // @pyparm <o PyEVT_HANDLE>|Event||Handle to an event
		return NULL;

	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtUpdateBookmark(bookmark, evt);
	Py_END_ALLOW_THREADS if (!bsuccess) return PyWin_SetAPIError("EvtUpdateBookmark");
	Py_INCREF(Py_None);
	return Py_None;
}
PyCFunction pfnPyEvtUpdateBookmark = (PyCFunction)PyEvtUpdateBookmark;

PyObject *PyWinObject_FromEVT_VARIANT(PEVT_VARIANT val)
{
	if (val->Type & EVT_VARIANT_TYPE_ARRAY)
	{
		PyErr_SetString(PyExc_NotImplementedError, "EVT_VARIANT arrays not supported yet");
		return NULL;
	}
	DWORD val_type = val->Type & EVT_VARIANT_TYPE_MASK;
	PyObject *obval = NULL;
	switch (val_type)
	{
	case EvtVarTypeNull:
		Py_INCREF(Py_None);
		obval = Py_None;
		break;
	case EvtVarTypeString:
		obval = PyWinObject_FromWCHAR(val->StringVal);
		break;
	case EvtVarTypeAnsiString:
		obval = PyWinCoreString_FromString(val->AnsiStringVal);
		break;
	case EvtVarTypeSByte:
		obval = PyLong_FromLong(val->SByteVal);
		break;
	case EvtVarTypeByte:
		obval = PyLong_FromUnsignedLong(val->ByteVal);
		break;
	case EvtVarTypeInt16:
		obval = PyLong_FromLong(val->Int16Val);
		break;
	case EvtVarTypeUInt16:
		obval = PyLong_FromUnsignedLong(val->UInt16Val);
		break;
	case EvtVarTypeInt32:
		obval = PyLong_FromLong(val->Int32Val);
		break;
	case EvtVarTypeUInt32:
		obval = PyLong_FromUnsignedLong(val->UInt32Val);
		break;
	case EvtVarTypeInt64:
		obval = PyLong_FromLongLong(val->Int64Val);
		break;
	case EvtVarTypeUInt64:
		obval = PyLong_FromUnsignedLongLong(val->UInt64Val);
		break;
	case EvtVarTypeSingle:
		obval = PyFloat_FromDouble(val->SingleVal);
		break;
	case EvtVarTypeDouble:
		obval = PyFloat_FromDouble(val->DoubleVal);
		break;
	case EvtVarTypeBoolean:
		obval = PyBool_FromLong(val->BooleanVal);
		break;
	case EvtVarTypeBinary:
		obval = PyString_FromStringAndSize((char *)val->BinaryVal, val->Count);
		break;
	case EvtVarTypeGuid:
		obval = PyWinObject_FromIID(*val->GuidVal);
		break;
	case EvtVarTypeSizeT:
		obval = PyInt_FromSsize_t(val->SizeTVal);
		break;
	case EvtVarTypeFileTime:
	{
		// FileTimeVal is defined as ULONGLONG for unknown reasons
		LARGE_INTEGER timestamp;
		timestamp.QuadPart = val->FileTimeVal;
		obval = PyWinObject_FromTimeStamp(timestamp);
		break;
	}
	case EvtVarTypeSysTime:
		obval = PyWinObject_FromSYSTEMTIME(*val->SysTimeVal);
		break;
	case EvtVarTypeSid:
		obval = PyWinObject_FromSID(val->SidVal);
		break;
	// case EvtVarTypeHexInt32:
	// case EvtVarTypeHexInt64:
	case EvtVarTypeEvtHandle:
		obval = PyWinObject_FromEVT_HANDLE(val->EvtHandleVal);
		break;
	case EvtVarTypeEvtXml:
		obval = PyWinObject_FromWCHAR(val->XmlVal);
		break;
	default:
		PyErr_Format(PyExc_NotImplementedError, "EVT_VARIANT_TYPE %d not supported yet", val_type);
	}
	if (obval == NULL)
		return NULL;
	return Py_BuildValue("Nk", obval, val->Type);
}

// @pyswig (object, int)|EvtGetChannelConfigProperty|Retreives channel configuration information
// @comm Accepts keyword args
// @comm Returns the value and type of value (EvtVarType*)
static PyObject *PyEvtGetChannelConfigProperty(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"ChannelConfig", "PropertyId", "Flags", NULL};
	EVT_HANDLE config_handle;
	EVT_CHANNEL_CONFIG_PROPERTY_ID prop_id;
	DWORD flags = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i|k:EvtGetChannelConfigProperty", keywords,
									 PyWinObject_AsHANDLE, &config_handle, // @pyparm <o PyEVT_HANDLE>|ChannelConfig||Config handle as returned by <om win32evtlog.EvtOpenChannelConfig>
									 &prop_id,							   // @pyparm int|PropertyId||Property to retreive, one of EvtChannel* constants
									 &flags))							   // @pyparm int|Flags|0|Reserved, use only 0
		return NULL;

	PEVT_VARIANT val = NULL;
	DWORD buf_size = 0, buf_needed, err;
	Py_BEGIN_ALLOW_THREADS
		EvtGetChannelConfigProperty(config_handle, prop_id, flags, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		err = GetLastError();
	if (err != ERROR_INSUFFICIENT_BUFFER)
		return PyWin_SetAPIError("EvtGetChannelConfigProperty", err);
	val = (PEVT_VARIANT)malloc(buf_needed);
	if (val == NULL)
		return PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", buf_needed);
	buf_size = buf_needed;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtGetChannelConfigProperty(config_handle, prop_id, flags, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		PyObject *ret = NULL;
	if (!bsuccess)
		PyWin_SetAPIError("EvtGetChannelConfigProperty");
	else
		ret = PyWinObject_FromEVT_VARIANT(val);
	free(val);
	return ret;
}
PyCFunction pfnPyEvtGetChannelConfigProperty = (PyCFunction)PyEvtGetChannelConfigProperty;

// @pyswig <o PyEVT_HANDLE>|EvtOpenChannelConfig|Opens channel configuration
// @comm Accepts keyword args
static PyObject *PyEvtOpenChannelConfig(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"ChannelPath", "Session", "Flags", NULL};
	EVT_HANDLE session = NULL, ret;
	PyObject *obchannel;
	TmpWCHAR channel;
	DWORD flags = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O&k:EvtOpenChannelConfig", keywords,
									 &obchannel,					 // @pyparm str|ChannelPath||Channel to be opened
									 PyWinObject_AsHANDLE, &session, // @pyparm <o PyEVT_HANDLE>|Session|None|Session handle as returned by <om win32evtlog.EvtOpenSession>, or None for local machine
									 &flags))						 // @pyparm int|Flags|0|Reserved, use only 0
		return NULL;
	if (!PyWinObject_AsWCHAR(obchannel, &channel, FALSE))
		return NULL;
	Py_BEGIN_ALLOW_THREADS
		ret = EvtOpenChannelConfig(session, channel, flags);
	Py_END_ALLOW_THREADS if (ret == NULL) return PyWin_SetAPIError("EvtOpenChannelConfig");
	return PyWinObject_FromEVT_HANDLE(ret);
}
PyCFunction pfnPyEvtOpenChannelConfig = (PyCFunction)PyEvtOpenChannelConfig;

void PyWinObject_FreeEVT_RPC_LOGIN(EVT_RPC_LOGIN *erl)
{
	PyWinObject_FreeWCHAR(erl->Server);
	PyWinObject_FreeWCHAR(erl->User);
	PyWinObject_FreeWCHAR(erl->Domain);
	PyWinObject_FreeWCHAR(erl->Password);
}

// @object PyEVT_RPC_LOGIN|Tuple containing login credentials for a remote Event Log connection
// @comm To use current login credentials, pass None for User, Domain, and Password
// @tupleitem 0|string|Server|Machine to connect to (only required item)
// @tupleitem 1|string|User|User account to login with, defaults to None
// @tupleitem 2|string|Domain|Domain of account, defaults to None
// @tupleitem 3|string|Password|Password, defaults to None
// @tupleitem 4|int|Flags|Type of authentication, EvtRpcLogin*.  Default is EvtRpcLoginAuthDefault
BOOL PyWinObject_AsEVT_RPC_LOGIN(PyObject *ob, EVT_RPC_LOGIN *erl)
{
	ZeroMemory(erl, sizeof(*erl));
	if (!PyTuple_Check(ob))
	{
		PyErr_Format(PyExc_TypeError, "PyEVT_RPC_LOGIN must be a tuple instead of %s", ob->ob_type->tp_name);
		return FALSE;
	}
	PyObject *observer, *obuser = Py_None, *obdomain = Py_None, *obpassword = Py_None;
	if (!PyArg_ParseTuple(ob, "O|OOOk", &observer, &obuser, &obdomain, &obpassword, &erl->Flags))
		return FALSE;
	if (PyWinObject_AsWCHAR(observer, &erl->Server, FALSE) &&
		PyWinObject_AsWCHAR(obuser, &erl->User, TRUE) &&
		PyWinObject_AsWCHAR(obdomain, &erl->Domain, TRUE) &&
		PyWinObject_AsWCHAR(obpassword, &erl->Password, TRUE))
		return TRUE;

	PyWinObject_FreeEVT_RPC_LOGIN(erl);
	return FALSE;
}

// @pyswig <o PyEVT_HANDLE>|EvtOpenSession|Creates a session used to access the Event Log on another machine
// @comm Accepts keyword args
static PyObject *PyEvtOpenSession(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Login", "LoginClass", "Timeout", "Flags", NULL};
	EVT_RPC_LOGIN login = {NULL};
	EVT_HANDLE ret;
	PyObject *oblogin;
	EVT_LOGIN_CLASS loginclass = EvtRpcLogin;
	DWORD flags = 0, timeout = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|ikk:EvtOpenSession", keywords,
									 &oblogin,	// @pyparm <o PyEVT_RPC_LOGIN>|Login||Credentials to be used to access remote machine
									 &loginclass, // @pyparm int|LoginClass|EvtRpcLogin|Type of login to perform, EvtRpcLogin is only defined value
									 &timeout,	// @pyparm int|Timeout|0|Reserved, use only 0
									 &flags))	 // @pyparm int|Flags|0|Reserved, use only 0
		return NULL;

	if (!PyWinObject_AsEVT_RPC_LOGIN(oblogin, &login))
		return NULL;
	Py_BEGIN_ALLOW_THREADS
		ret = EvtOpenSession(loginclass, &login, timeout, flags);
	Py_END_ALLOW_THREADS
		PyWinObject_FreeEVT_RPC_LOGIN(&login);
	if (ret == NULL)
		return PyWin_SetAPIError("EvtOpenSession");
	return PyWinObject_FromEVT_HANDLE(ret);
}
PyCFunction pfnPyEvtOpenSession = (PyCFunction)PyEvtOpenSession;

// @pyswig <o PyEVT_HANDLE>|EvtOpenPublisherEnum|Begins an enumeration of event publishers
// @comm Accepts keyword args
static PyObject *PyEvtOpenPublisherEnum(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Session", "Flags", NULL};
	EVT_HANDLE session = NULL, enum_handle;
	DWORD flags = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O&k:EvtOpenPublisherEnum", keywords,
									 PyWinObject_AsHANDLE, &session, // @pyparm <o PyEVT_HANDLE>|Session|None|Handle to a remote session (see <om win32evtlog.EvtOpenSession>), or None for local machine.
									 &flags))						 // @pyparm int|Flags|0|Reserved, use only 0
		return NULL;
	Py_BEGIN_ALLOW_THREADS
		enum_handle = EvtOpenPublisherEnum(session, flags);
	Py_END_ALLOW_THREADS if (enum_handle == NULL) return PyWin_SetAPIError("EvtOpenPublisherEnum");
	return PyWinObject_FromEVT_HANDLE(enum_handle);
}
PyCFunction pfnPyEvtOpenPublisherEnum = (PyCFunction)PyEvtOpenPublisherEnum;

// @pyswig str|EvtNextPublisherId|Returns the next publisher from an enumeration
// @rdesc Returns None at end of enumeration
// @comm Accepts keyword args
static PyObject *PyEvtNextPublisherId(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"PublisherEnum", NULL};
	EVT_HANDLE enum_handle;
	DWORD allocated_size = 256, returned_size, err;
	WCHAR *buf = NULL;
	PyObject *ret = NULL;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&:EvtNextPublisherId", keywords,
									 PyWinObject_AsHANDLE, &enum_handle)) // @pyparm <o PyEVT_HANDLE>|PublisherEnum||Handle to an enumeration as returned by <om win32evtlog.EvtOpenPublisherEnum>
		return NULL;
	BOOL bsuccess;
	while (true)
	{
		if (buf)
			free(buf);
		WCHAR *buf = (WCHAR *)malloc(allocated_size * sizeof(WCHAR));
		if (!buf)
			return NULL;

		Py_BEGIN_ALLOW_THREADS
			bsuccess = EvtNextPublisherId(enum_handle, allocated_size, buf, &returned_size);
		Py_END_ALLOW_THREADS if (bsuccess)
		{
			ret = PyWinObject_FromWCHAR(buf);
			break;
		}
		err = GetLastError();
		if (err == ERROR_INSUFFICIENT_BUFFER)
		{
			allocated_size = returned_size;
			continue;
		}
		if (err == ERROR_NO_MORE_ITEMS)
		{
			Py_INCREF(Py_None);
			ret = Py_None;
			break;
		}
		PyWin_SetAPIError("EvtNextPublisherId", err);
		break;
	}
	if (buf)
		free(buf);
	return ret;
}
PyCFunction pfnPyEvtNextPublisherId = (PyCFunction)PyEvtNextPublisherId;

// @pyswig <o PyEVT_HANDLE>|EvtOpenPublisherMetadata|Opens a publisher to retrieve properties using <om win32evtlog.EvtGetPublisherMetadataProperty>
// @comm Accepts keyword args
static PyObject *PyEvtOpenPublisherMetadata(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"PublisherIdentity", "Session", "LogFilePath", "Locale", "Flags", NULL};
	PyObject *obpublisher, *oblogfile = Py_None;
	TmpWCHAR publisher, logfile;
	EVT_HANDLE session = NULL;
	LCID locale = 0;
	DWORD flags = 0;
	EVT_HANDLE ret;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O&Okk:EvtOpenPublisherMetadata", keywords,
									 &obpublisher,					 // @pyparm str|PublisherIdentity||Publisher id as returned by <om win32evtlog.EvtNextPublisherId>
									 PyWinObject_AsHANDLE, &session, // @pyparm <o PyEVT_HANDLE>|Session|None|Handle to remote session, or None for local machine
									 &oblogfile,					 // @pyparm str|LogFilePath|None|Log file from which to retrieve publisher, or None for locally registered publisher
									 &locale,						 // @pyparm int|Locale|0|Locale to use for retrieved properties, use 0 for current locale
									 &flags))						 // @pyparm int|Flags|0|Reserved, use only 0
		return NULL;
	if (!PyWinObject_AsWCHAR(obpublisher, &publisher, FALSE))
		return NULL;
	if (!PyWinObject_AsWCHAR(oblogfile, &logfile, TRUE))
		return NULL;

	Py_BEGIN_ALLOW_THREADS
		ret = EvtOpenPublisherMetadata(session, publisher, logfile, locale, flags);
	Py_END_ALLOW_THREADS if (ret == NULL) return PyWin_SetAPIError("EvtOpenPublisherMetadata");
	return PyWinObject_FromEVT_HANDLE(ret);
}
PyCFunction pfnPyEvtOpenPublisherMetadata = (PyCFunction)PyEvtOpenPublisherMetadata;

// @pyswig (object, int)|EvtGetPublisherMetadataProperty|Retrieves a property from an event publisher
// @comm Accepts keyword args
// @rdesc Returns the value and type of value (EvtVarType*)
// Some properties return a handle (type EvtVarTypeEvtHandle) which can be iterated using
// <om win32evtlog.EvtGetObjectArraySize> and <om win32evtlog.EvtGetObjectArrayProperty>.
static PyObject *PyEvtGetPublisherMetadataProperty(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"PublisherMetadata", "PropertyId", "Flags", NULL};
	EVT_HANDLE hpublisher;
	EVT_PUBLISHER_METADATA_PROPERTY_ID prop_id;
	DWORD flags = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i|k:EvtGetPublisherMetadataProperty", keywords,
									 PyWinObject_AsHANDLE, &hpublisher, // @pyparm <o PyEVT_HANDLE>|PublisherMetadata||Publisher handle as returned by <om win32evtlog.EvtOpenPublisherMetadata>
									 &prop_id,							// @pyparm int|PropertyId||Property to retreive, EvtPublisherMetadata*
									 &flags))							// @pyparm int|Flags|0|Reserved, use only 0
		return NULL;

	PEVT_VARIANT val = NULL;
	DWORD buf_size = 0, buf_needed, err;
	Py_BEGIN_ALLOW_THREADS
		EvtGetPublisherMetadataProperty(hpublisher, prop_id, flags, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		err = GetLastError();
	if (err != ERROR_INSUFFICIENT_BUFFER)
		return PyWin_SetAPIError("EvtGetPublisherMetadataProperty", err);
	val = (PEVT_VARIANT)malloc(buf_needed);
	if (val == NULL)
		return PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", buf_needed);
	buf_size = buf_needed;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtGetPublisherMetadataProperty(hpublisher, prop_id, flags, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		PyObject *ret = NULL;
	if (!bsuccess)
		PyWin_SetAPIError("EvtGetPublisherMetadataProperty");
	else
		ret = PyWinObject_FromEVT_VARIANT(val);
	free(val);
	return ret;
}
PyCFunction pfnPyEvtGetPublisherMetadataProperty = (PyCFunction)PyEvtGetPublisherMetadataProperty;

// @pyswig <o PyEVT_HANDLE>|EvtOpenEventMetadataEnum|Enumerates the events that a publisher provides
// @comm Accepts keyword args
static PyObject *PyEvtOpenEventMetadataEnum(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"PublisherMetadata", "Flags", NULL};
	EVT_HANDLE hpublisher, enum_handle;
	DWORD flags = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|k:EvtOpenEventMetadataEnum", keywords,
									 PyWinObject_AsHANDLE, &hpublisher, // @pyparm <o PyEVT_HANDLE>|PublisherMetadata||Publisher handle as returned by <om win32evtlog.EvtOpenPublisherMetadata>
									 &flags))							// @pyparm int|Flags|0|Reserved, use only 0
		return NULL;
	Py_BEGIN_ALLOW_THREADS
		enum_handle = EvtOpenEventMetadataEnum(hpublisher, flags);
	Py_END_ALLOW_THREADS if (enum_handle == NULL) return PyWin_SetAPIError("EvtOpenEventMetadataEnum");
	return PyWinObject_FromEVT_HANDLE(enum_handle);
}
PyCFunction pfnPyEvtOpenEventMetadataEnum = (PyCFunction)PyEvtOpenEventMetadataEnum;

// @pyswig <o PyEVT_HANDLE>|EvtNextEventMetadata|Retrieves the next item from an event metadata enumeration
// @comm Accepts keyword args
static PyObject *PyEvtNextEventMetadata(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"EventMetadataEnum", "Flags", NULL};
	EVT_HANDLE henum, ret;
	DWORD flags = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|k:EvtNextEventMetadata", keywords,
									 PyWinObject_AsHANDLE, &henum, // @pyparm <o PyEVT_HANDLE>|EventMetadataEnum||Enumeration handle as returned by <om win32evtlog.EvtOpenEventMetadataEnum>
									 &flags))					   // @pyparm int|Flags|0|Reserved, use only 0
		return NULL;

	Py_BEGIN_ALLOW_THREADS
		ret = EvtNextEventMetadata(henum, flags);
	Py_END_ALLOW_THREADS if (ret != NULL) return PyWinObject_FromEVT_HANDLE(ret);
	DWORD err = GetLastError();
	if (err == ERROR_NO_MORE_ITEMS)
	{
		Py_INCREF(Py_None);
		return Py_None;
	}
	return PyWin_SetAPIError("EvtNextEventMetadata");
}
PyCFunction pfnPyEvtNextEventMetadata = (PyCFunction)PyEvtNextEventMetadata;

// @pyswig (object, int)|EvtGetEventMetadataProperty|Retrieves a property from an event publisher
// @comm Accepts keyword args
// @rdesc Returns the value and type of value (EvtVarType*).
static PyObject *PyEvtGetEventMetadataProperty(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"EventMetadata", "PropertyId", "Flags", NULL};
	EVT_HANDLE hevent;
	EVT_EVENT_METADATA_PROPERTY_ID prop_id;
	DWORD flags = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i|k:EvtGetEventMetadataProperty", keywords,
									 PyWinObject_AsHANDLE, &hevent, // @pyparm <o PyEVT_HANDLE>|EventMetadata||Event metadata handle as returned by <om win32evtlog.EvtNextEventMetadata>
									 &prop_id,						// @pyparm int|PropertyId||Property to retreive, EventMetadata*
									 &flags))						// @pyparm int|Flags|0|Reserved, use only 0
		return NULL;

	PEVT_VARIANT val = NULL;
	DWORD buf_size = 0, buf_needed, err;
	Py_BEGIN_ALLOW_THREADS
		EvtGetEventMetadataProperty(hevent, prop_id, flags, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		err = GetLastError();
	if (err != ERROR_INSUFFICIENT_BUFFER)
		return PyWin_SetAPIError("EvtGetEventMetadataProperty", err);
	val = (PEVT_VARIANT)malloc(buf_needed);
	if (val == NULL)
		return PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", buf_needed);
	buf_size = buf_needed;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtGetEventMetadataProperty(hevent, prop_id, flags, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		PyObject *ret = NULL;
	if (!bsuccess)
		PyWin_SetAPIError("EvtGetEventMetadataProperty");
	else
		ret = PyWinObject_FromEVT_VARIANT(val);
	free(val);
	return ret;
}
PyCFunction pfnPyEvtGetEventMetadataProperty = (PyCFunction)PyEvtGetEventMetadataProperty;

// @pyswig (object, int)|EvtGetLogInfo|Retrieves log file or channel information
// @comm Accepts keyword args
// @comm Returns the value and type of value (EvtVarType*)
static PyObject *PyEvtGetLogInfo(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Log", "PropertyId", NULL};
	EVT_HANDLE hlog;
	EVT_LOG_PROPERTY_ID prop_id;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i:EvtGetLogInfo", keywords,
									 PyWinObject_AsHANDLE, &hlog, // @pyparm <o PyEVT_HANDLE>|Log||Event log handle as returned by <om win32evtlog.EvtOpenLog>
									 &prop_id))					  // @pyparm int|PropertyId||Property to retreive, EvtLog*
		return NULL;

	PEVT_VARIANT val = NULL;
	DWORD buf_size = 0, buf_needed, err;
	Py_BEGIN_ALLOW_THREADS
		EvtGetLogInfo(hlog, prop_id, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		err = GetLastError();
	if (err != ERROR_INSUFFICIENT_BUFFER)
		return PyWin_SetAPIError("EvtGetLogInfo", err);
	val = (PEVT_VARIANT)malloc(buf_needed);
	if (val == NULL)
		return PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", buf_needed);
	buf_size = buf_needed;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtGetLogInfo(hlog, prop_id, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		PyObject *ret = NULL;
	if (!bsuccess)
		PyWin_SetAPIError("EvtGetLogInfo");
	else
		ret = PyWinObject_FromEVT_VARIANT(val);
	free(val);
	return ret;
}
PyCFunction pfnPyEvtGetLogInfo = (PyCFunction)PyEvtGetLogInfo;

// @pyswig (object, int)|EvtGetEventInfo|Retrieves information about the source of an event
// @comm Accepts keyword args
// @comm Returns the value and type of value (EvtVarType*)
static PyObject *PyEvtGetEventInfo(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"Event", "PropertyId", NULL};
	EVT_HANDLE hevent;
	EVT_EVENT_PROPERTY_ID prop_id;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i:EvtGetEventInfo", keywords,
									 PyWinObject_AsHANDLE, &hevent, // @pyparm <o PyEVT_HANDLE>|Event||Handle to an event
									 &prop_id))						// @pyparm int|PropertyId||Property to retreive, EvtEvent*
		return NULL;

	PEVT_VARIANT val = NULL;
	DWORD buf_size = 0, buf_needed, err;
	Py_BEGIN_ALLOW_THREADS
		EvtGetEventInfo(hevent, prop_id, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		err = GetLastError();
	if (err != ERROR_INSUFFICIENT_BUFFER)
		return PyWin_SetAPIError("EvtGetEventInfo", err);
	val = (PEVT_VARIANT)malloc(buf_needed);
	if (val == NULL)
		return PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", buf_needed);
	buf_size = buf_needed;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtGetEventInfo(hevent, prop_id, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		PyObject *ret = NULL;
	if (!bsuccess)
		PyWin_SetAPIError("EvtGetEventInfo");
	else
		ret = PyWinObject_FromEVT_VARIANT(val);
	free(val);
	return ret;
}
PyCFunction pfnPyEvtGetEventInfo = (PyCFunction)PyEvtGetEventInfo;

// @pyswig int|EvtGetObjectArraySize|Returns the size of an array of event objects
// @comm Accepts keyword args
static PyObject *PyEvtGetObjectArraySize(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"ObjectArray", NULL};
	EVT_HANDLE harray;
	DWORD size;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&:EvtGetObjectArraySize", keywords,
									 PyWinObject_AsHANDLE, &harray)) // @pyparm <o PyEVT_HANDLE>|ObjectArray||Handle to an array of objects as returned by <om win32evtlog.EvtGetPublisherMetadataProperty> for some ProperyId's
		return NULL;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtGetObjectArraySize(harray, &size);
	Py_END_ALLOW_THREADS if (!bsuccess) return PyWin_SetAPIError("EvtGetObjectArraySize");
	return PyLong_FromUnsignedLong(size);
}
PyCFunction pfnPyEvtGetObjectArraySize = (PyCFunction)PyEvtGetObjectArraySize;

// @pyswig (object, int)|EvtGetObjectArrayProperty|Retrieves an item from an object array
// @comm Accepts keyword args
// @rdesc Returns the value and type of value (EvtVarType*)
static PyObject *PyEvtGetObjectArrayProperty(PyObject *self, PyObject *args, PyObject *kwargs)
{
	static char *keywords[] = {"ObjectArray", "PropertyId", "ArrayIndex", "Flags", NULL};
	EVT_HANDLE harray;
	DWORD prop_id, index, flags = 0;
	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&kk|k:EvtGetObjectArrayProperty", keywords,
									 PyWinObject_AsHANDLE, &harray, // @pyparm <o PyEVT_HANDLE>|ObjectArray||Handle to an array of objects as returned by <om win32evtlog.EvtGetPublisherMetadataProperty> for some ProperyId's
									 &prop_id,						// @pyparm int|PropertyId||Type of property contained in the array
									 &index,						// @pyparm int|ArrayIndex||Zero-based index of item to retrieve
									 &flags))						// @pyparm int|Flags|0|Reserved, use only 0
		return NULL;

	PEVT_VARIANT val = NULL;
	DWORD buf_size = 0, buf_needed, err;
	Py_BEGIN_ALLOW_THREADS
		EvtGetObjectArrayProperty(harray, prop_id, index, flags, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		err = GetLastError();
	if (err != ERROR_INSUFFICIENT_BUFFER)
		return PyWin_SetAPIError("EvtGetObjectArrayProperty", err);
	val = (PEVT_VARIANT)malloc(buf_needed);
	if (val == NULL)
		return PyErr_Format(PyExc_MemoryError, "Unable to allocate %d bytes", buf_needed);
	buf_size = buf_needed;
	BOOL bsuccess;
	Py_BEGIN_ALLOW_THREADS
		bsuccess = EvtGetObjectArrayProperty(harray, prop_id, index, flags, buf_size, val, &buf_needed);
	Py_END_ALLOW_THREADS
		PyObject *ret = NULL;
	if (!bsuccess)
		PyWin_SetAPIError("EvtGetObjectArrayProperty");
	else
		ret = PyWinObject_FromEVT_VARIANT(val);
	free(val);
	return ret;
}
PyCFunction pfnPyEvtGetObjectArrayProperty = (PyCFunction)PyEvtGetObjectArrayProperty;
static PyObject *_wrap_ClearEventLog(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	BOOLAPI _result;
	HANDLE _arg0;
	WCHAR *_arg1;
	PyObject *_obj0 = 0;
	PyObject *_obj1 = 0;

	self = self;
	{
		_arg1 = NULL;
	}
	if (!PyArg_ParseTuple(args, "OO:ClearEventLog", &_obj0, &_obj1))
		return NULL;
	{
		if (!PyWinObject_AsHANDLE(_obj0, &_arg0))
			return NULL;
	}
	{
		// Wide string code!
		if (!PyWinObject_AsWCHAR(_obj1, &_arg1, TRUE))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (BOOLAPI)ClearEventLogW(_arg0, _arg1);

		Py_END_ALLOW_THREADS if (!_result)
		{
			{
				// Wide string cleanup
				PyWinObject_FreeWCHAR(_arg1);
			}

			return PyWin_SetAPIError("ClearEventLogW");
		}
	}
	{
		_resultobj = Py_None;
		Py_INCREF(Py_None);
	}
	{
		// Wide string cleanup
		PyWinObject_FreeWCHAR(_arg1);
	}
	return _resultobj;
}

static PyObject *_wrap_BackupEventLog(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	BOOLAPI _result;
	HANDLE _arg0;
	WCHAR *_arg1;
	PyObject *_obj0 = 0;
	PyObject *_obj1 = 0;

	self = self;
	{
		_arg1 = NULL;
	}
	if (!PyArg_ParseTuple(args, "OO:BackupEventLog", &_obj0, &_obj1))
		return NULL;
	{
		if (!PyWinObject_AsHANDLE(_obj0, &_arg0))
			return NULL;
	}
	{
		// Wide string code!
		if (!PyWinObject_AsWCHAR(_obj1, &_arg1, FALSE))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (BOOLAPI)BackupEventLogW(_arg0, _arg1);

		Py_END_ALLOW_THREADS if (!_result)
		{
			{
				// Wide string cleanup
				PyWinObject_FreeWCHAR(_arg1);
			}

			return PyWin_SetAPIError("BackupEventLogW");
		}
	}
	{
		_resultobj = Py_None;
		Py_INCREF(Py_None);
	}
	{
		// Wide string cleanup
		PyWinObject_FreeWCHAR(_arg1);
	}
	return _resultobj;
}

static PyObject *_wrap_CloseEventLog(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	BOOLAPI _result;
	HANDLE _arg0;
	PyObject *_obj0 = 0;

	self = self;
	if (!PyArg_ParseTuple(args, "O:CloseEventLog", &_obj0))
		return NULL;
	{
		if (!PyWinObject_AsHANDLE(_obj0, &_arg0))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (BOOLAPI)CloseEventLog(_arg0);

		Py_END_ALLOW_THREADS if (!_result)
		{

			return PyWin_SetAPIError("CloseEventLog");
		}
	}
	{
		_resultobj = Py_None;
		Py_INCREF(Py_None);
	}
	return _resultobj;
}

static PyObject *_wrap_DeregisterEventSource(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	BOOLAPI _result;
	HANDLE _arg0;
	PyObject *_obj0 = 0;

	self = self;
	if (!PyArg_ParseTuple(args, "O:DeregisterEventSource", &_obj0))
		return NULL;
	{
		if (!PyWinObject_AsHANDLE(_obj0, &_arg0))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (BOOLAPI)DeregisterEventSource(_arg0);

		Py_END_ALLOW_THREADS if (!_result)
		{

			return PyWin_SetAPIError("DeregisterEventSource");
		}
	}
	{
		_resultobj = Py_None;
		Py_INCREF(Py_None);
	}
	return _resultobj;
}

static PyObject *_wrap_NotifyChangeEventLog(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	BOOLAPI _result;
	HANDLE _arg0;
	PyHANDLE _arg1;
	PyObject *_obj0 = 0;
	PyObject *_obj1 = 0;

	self = self;
	if (!PyArg_ParseTuple(args, "OO:NotifyChangeEventLog", &_obj0, &_obj1))
		return NULL;
	{
		if (!PyWinObject_AsHANDLE(_obj0, &_arg0))
			return NULL;
	}
	{
		if (!PyWinObject_AsHANDLE(_obj1, &_arg1))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (BOOLAPI)NotifyChangeEventLog(_arg0, _arg1);

		Py_END_ALLOW_THREADS if (!_result)
		{

			return PyWin_SetAPIError("NotifyChangeEventLog");
		}
	}
	{
		_resultobj = Py_None;
		Py_INCREF(Py_None);
	}
	return _resultobj;
}

static PyObject *_wrap_GetNumberOfEventLogRecords(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	BOOLAPI _result;
	HANDLE _arg0;
	unsigned long *_arg1;
	unsigned long temp;
	PyObject *_obj0 = 0;

	self = self;
	{
		_arg1 = &temp;
	}
	if (!PyArg_ParseTuple(args, "O:GetNumberOfEventLogRecords", &_obj0))
		return NULL;
	{
		if (!PyWinObject_AsHANDLE(_obj0, &_arg0))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (BOOLAPI)GetNumberOfEventLogRecords(_arg0, _arg1);

		Py_END_ALLOW_THREADS if (!_result)
		{

			return PyWin_SetAPIError("GetNumberOfEventLogRecords");
		}
	}
	{
		_resultobj = Py_None;
		Py_INCREF(Py_None);
	}
	{
		PyObject *o;
		o = PyInt_FromLong((long)(*_arg1));
		if (!_resultobj)
		{
			_resultobj = o;
		}
		else if (_resultobj == Py_None)
		{
			Py_DECREF(Py_None);
			_resultobj = o;
		}
		else
		{
			if (!PyList_Check(_resultobj))
			{
				PyObject *o2 = _resultobj;
				_resultobj = PyList_New(0);
				PyList_Append(_resultobj, o2);
				Py_XDECREF(o2);
			}
			PyList_Append(_resultobj, o);
			Py_XDECREF(o);
		}
	}
	return _resultobj;
}

static PyObject *_wrap_GetOldestEventLogRecord(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	BOOLAPI _result;
	HANDLE _arg0;
	unsigned long *_arg1;
	unsigned long temp;
	PyObject *_obj0 = 0;

	self = self;
	{
		_arg1 = &temp;
	}
	if (!PyArg_ParseTuple(args, "O:GetOldestEventLogRecord", &_obj0))
		return NULL;
	{
		if (!PyWinObject_AsHANDLE(_obj0, &_arg0))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (BOOLAPI)GetOldestEventLogRecord(_arg0, _arg1);

		Py_END_ALLOW_THREADS if (!_result)
		{

			return PyWin_SetAPIError("GetOldestEventLogRecord");
		}
	}
	{
		_resultobj = Py_None;
		Py_INCREF(Py_None);
	}
	{
		PyObject *o;
		o = PyInt_FromLong((long)(*_arg1));
		if (!_resultobj)
		{
			_resultobj = o;
		}
		else if (_resultobj == Py_None)
		{
			Py_DECREF(Py_None);
			_resultobj = o;
		}
		else
		{
			if (!PyList_Check(_resultobj))
			{
				PyObject *o2 = _resultobj;
				_resultobj = PyList_New(0);
				PyList_Append(_resultobj, o2);
				Py_XDECREF(o2);
			}
			PyList_Append(_resultobj, o);
			Py_XDECREF(o);
		}
	}
	return _resultobj;
}

static PyObject *_wrap_OpenEventLog(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	PyEVTLOG_HANDLE _result;
	WCHAR *_arg0;
	WCHAR *_arg1;
	PyObject *_obj0 = 0;
	PyObject *_obj1 = 0;

	self = self;
	{
		_arg0 = NULL;
	}
	{
		_arg1 = NULL;
	}
	if (!PyArg_ParseTuple(args, "OO:OpenEventLog", &_obj0, &_obj1))
		return NULL;
	{
		// Wide string code!
		if (!PyWinObject_AsWCHAR(_obj0, &_arg0, TRUE))
			return NULL;
	}
	{
		// Wide string code!
		if (!PyWinObject_AsWCHAR(_obj1, &_arg1, FALSE))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (PyEVTLOG_HANDLE)OpenEventLogW(_arg0, _arg1);

		Py_END_ALLOW_THREADS if (_result == 0 || _result == INVALID_HANDLE_VALUE)
		{
			{
				// Wide string cleanup
				PyWinObject_FreeWCHAR(_arg0);
			}
			{
				// Wide string cleanup
				PyWinObject_FreeWCHAR(_arg1);
			}

			return PyWin_SetAPIError("OpenEventLogW");
		}
	}
	{
		_resultobj = PyWinObject_FromEVTLOG_HANDLE(_result);
	}
	{
		// Wide string cleanup
		PyWinObject_FreeWCHAR(_arg0);
	}
	{
		// Wide string cleanup
		PyWinObject_FreeWCHAR(_arg1);
	}
	return _resultobj;
}

static PyObject *_wrap_RegisterEventSource(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	HANDLE _result;
	WCHAR *_arg0;
	WCHAR *_arg1;
	PyObject *_obj0 = 0;
	PyObject *_obj1 = 0;

	self = self;
	{
		_arg0 = NULL;
	}
	{
		_arg1 = NULL;
	}
	if (!PyArg_ParseTuple(args, "OO:RegisterEventSource", &_obj0, &_obj1))
		return NULL;
	{
		// Wide string code!
		if (!PyWinObject_AsWCHAR(_obj0, &_arg0, TRUE))
			return NULL;
	}
	{
		// Wide string code!
		if (!PyWinObject_AsWCHAR(_obj1, &_arg1, FALSE))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (HANDLE)RegisterEventSourceW(_arg0, _arg1);

		Py_END_ALLOW_THREADS if (_result == 0 || _result == INVALID_HANDLE_VALUE)
		{
			{
				// Wide string cleanup
				PyWinObject_FreeWCHAR(_arg0);
			}
			{
				// Wide string cleanup
				PyWinObject_FreeWCHAR(_arg1);
			}

			return PyWin_SetAPIError("RegisterEventSourceW");
		}
	}
	{
		_resultobj = PyWinLong_FromHANDLE(_result);
	}
	{
		// Wide string cleanup
		PyWinObject_FreeWCHAR(_arg0);
	}
	{
		// Wide string cleanup
		PyWinObject_FreeWCHAR(_arg1);
	}
	return _resultobj;
}

static PyObject *_wrap_OpenBackupEventLog(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	HANDLE _result;
	WCHAR *_arg0;
	WCHAR *_arg1;
	PyObject *_obj0 = 0;
	PyObject *_obj1 = 0;

	self = self;
	{
		_arg0 = NULL;
	}
	{
		_arg1 = NULL;
	}
	if (!PyArg_ParseTuple(args, "OO:OpenBackupEventLog", &_obj0, &_obj1))
		return NULL;
	{
		// Wide string code!
		if (!PyWinObject_AsWCHAR(_obj0, &_arg0, TRUE))
			return NULL;
	}
	{
		// Wide string code!
		if (!PyWinObject_AsWCHAR(_obj1, &_arg1, FALSE))
			return NULL;
	}
	{
		Py_BEGIN_ALLOW_THREADS
			_result = (HANDLE)OpenBackupEventLogW(_arg0, _arg1);

		Py_END_ALLOW_THREADS if (_result == 0 || _result == INVALID_HANDLE_VALUE)
		{
			{
				// Wide string cleanup
				PyWinObject_FreeWCHAR(_arg0);
			}
			{
				// Wide string cleanup
				PyWinObject_FreeWCHAR(_arg1);
			}

			return PyWin_SetAPIError("OpenBackupEventLogW");
		}
	}
	{
		_resultobj = PyWinLong_FromHANDLE(_result);
	}
	{
		// Wide string cleanup
		PyWinObject_FreeWCHAR(_arg0);
	}
	{
		// Wide string cleanup
		PyWinObject_FreeWCHAR(_arg1);
	}
	return _resultobj;
}

static PyObject *_wrap_ReportEvent(PyObject *self, PyObject *args)
{
	PyObject *_resultobj;
	PyObject *_result;
	HANDLE _arg0;
	WORD _arg1;
	WORD _arg2;
	DWORD _arg3;
	PyObject *_arg4;
	PyObject *_arg5;
	PyObject *_arg6;
	PyObject *_obj0 = 0;
	PyObject *_obj3 = 0;
	PyObject *_obj4 = 0;
	PyObject *_obj5 = 0;
	PyObject *_obj6 = 0;

	self = self;
	if (!PyArg_ParseTuple(args, "OhhOOOO:ReportEvent", &_obj0, &_arg1, &_arg2, &_obj3, &_obj4, &_obj5, &_obj6))
		return NULL;
	{
		if (!PyWinObject_AsHANDLE(_obj0, &_arg0))
			return NULL;
	}
	{
		// PyLong_AsUnsignedLongMask isn't ideal - no overflow checking - but
		// this is what the 'k' format specifier in PyArg_ParseTuple uses, and
		// that is what much of pywin32 uses for DWORDS, so we use it here too
		_arg3 = PyLong_AsUnsignedLongMask(_obj3);
		if (_arg3 == (DWORD)-1 && PyErr_Occurred())
			return NULL;
	}
	{
		_arg4 = _obj4;
	}
	{
		_arg5 = _obj5;
	}
	{
		_arg6 = _obj6;
	}
	_result = (PyObject *)MyReportEvent(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6);
	{
		if (_result == NULL)
			return NULL; // get out now!
		_resultobj = _result;
	}
	return _resultobj;
}

static PyMethodDef win32evtlogMethods[] = {
	{"EvtGetObjectArrayProperty", pfnPyEvtGetObjectArrayProperty, 1},
	{"EvtGetObjectArraySize", pfnPyEvtGetObjectArraySize, 1},
	{"EvtGetEventInfo", pfnPyEvtGetEventInfo, 1},
	{"EvtGetLogInfo", pfnPyEvtGetLogInfo, 1},
	{"EvtGetEventMetadataProperty", pfnPyEvtGetEventMetadataProperty, 1},
	{"EvtNextEventMetadata", pfnPyEvtNextEventMetadata, 1},
	{"EvtOpenEventMetadataEnum", pfnPyEvtOpenEventMetadataEnum, 1},
	{"EvtGetPublisherMetadataProperty", pfnPyEvtGetPublisherMetadataProperty, 1},
	{"EvtOpenPublisherMetadata", pfnPyEvtOpenPublisherMetadata, 1},
	{"EvtNextPublisherId", pfnPyEvtNextPublisherId, 1},
	{"EvtOpenPublisherEnum", pfnPyEvtOpenPublisherEnum, 1},
	{"EvtOpenSession", pfnPyEvtOpenSession, 1},
	{"EvtOpenChannelConfig", pfnPyEvtOpenChannelConfig, 1},
	{"EvtGetChannelConfigProperty", pfnPyEvtGetChannelConfigProperty, 1},
	{"EvtUpdateBookmark", pfnPyEvtUpdateBookmark, 1},
	{"EvtCreateBookmark", pfnPyEvtCreateBookmark, 1},
	{"EvtSubscribe", pfnPyEvtSubscribe, 1},
	{"EvtRender", pfnPyEvtRender, 1},
	{"EvtSeek", pfnPyEvtSeek, 1},
	{"EvtNext", pfnPyEvtNext, 1},
	{"EvtQuery", pfnPyEvtQuery, 1},
	{"EvtGetExtendedStatus", PyEvtGetExtendedStatus, 1},
	{"EvtArchiveExportedLog", pfnPyEvtArchiveExportedLog, 1},
	{"EvtExportLog", pfnPyEvtExportLog, 1},
	{"EvtClearLog", pfnPyEvtClearLog, 1},
	{"EvtOpenLog", pfnPyEvtOpenLog, 1},
	{"EvtNextChannelPath", pfnPyEvtNextChannelPath, 1},
	{"EvtOpenChannelEnum", pfnPyEvtOpenChannelEnum, 1},
	{"ReportEvent", _wrap_ReportEvent, 1},
	{"ReadEventLog", MyReadEventLog, 1},
	{"OpenBackupEventLog", _wrap_OpenBackupEventLog, 1},
	{"RegisterEventSource", _wrap_RegisterEventSource, 1},
	{"OpenEventLog", _wrap_OpenEventLog, 1},
	{"GetOldestEventLogRecord", _wrap_GetOldestEventLogRecord, 1},
	{"GetNumberOfEventLogRecords", _wrap_GetNumberOfEventLogRecords, 1},
	{"NotifyChangeEventLog", _wrap_NotifyChangeEventLog, 1},
	{"DeregisterEventSource", _wrap_DeregisterEventSource, 1},
	{"CloseEventLog", _wrap_CloseEventLog, 1},
	{"BackupEventLog", _wrap_BackupEventLog, 1},
	{"ClearEventLog", _wrap_ClearEventLog, 1},
	{NULL, NULL}};
static PyObject *SWIG_globals;
#ifdef __cplusplus
extern "C"
#endif
#if (PY_VERSION_HEX < 0x03000000)
#define MODINIT_ERROR_RETURN
	SWIGEXPORT(void, initwin32evtlog)()
{
#else
#define MODINIT_ERROR_RETURN NULL
SWIGEXPORT(PyObject *, PyInit__eventlog)
(void)
{
#endif
	PyObject *m, *d;
	SWIG_globals = SWIG_newvarlink();
#if (PY_VERSION_HEX < 0x03000000)
	m = Py_InitModule("_eventlog", win32evtlogMethods);
	d = PyModule_GetDict(m);
#else
	static PyModuleDef win32evtlog_def = {
		PyModuleDef_HEAD_INIT,
		"_eventlog",
		"",
		-1,
		win32evtlogMethods,
	};
	m = PyModule_Create(&win32evtlog_def);
	if (!m)
		return NULL;
	d = PyModule_GetDict(m);
	if (!d)
		return NULL;
#endif

#ifndef SWIG_PYTHONCOM
/* This code only valid if non COM SWIG builds */
#ifndef PYCOM_EXPORT
	PyDict_SetItemString(d, "UNICODE", PyInt_FromLong(
#ifdef UNICODE
										   1
#else
										   0
#endif
										   ));
#endif
	PyWinGlobals_Ensure();
	PyDict_SetItemString(d, "error", PyWinExc_ApiError);
#endif SWIG_PYTHONCOM
	PyDict_SetItemString(d, "EVENTLOG_FORWARDS_READ", PyInt_FromLong((long)EVENTLOG_FORWARDS_READ));
	PyDict_SetItemString(d, "EVENTLOG_BACKWARDS_READ", PyInt_FromLong((long)EVENTLOG_BACKWARDS_READ));
	PyDict_SetItemString(d, "EVENTLOG_SEEK_READ", PyInt_FromLong((long)EVENTLOG_SEEK_READ));
	PyDict_SetItemString(d, "EVENTLOG_SEQUENTIAL_READ", PyInt_FromLong((long)EVENTLOG_SEQUENTIAL_READ));
	PyDict_SetItemString(d, "EVENTLOG_SUCCESS", PyInt_FromLong((long)EVENTLOG_SUCCESS));
	PyDict_SetItemString(d, "EVENTLOG_ERROR_TYPE", PyInt_FromLong((long)EVENTLOG_ERROR_TYPE));
	PyDict_SetItemString(d, "EVENTLOG_WARNING_TYPE", PyInt_FromLong((long)EVENTLOG_WARNING_TYPE));
	PyDict_SetItemString(d, "EVENTLOG_INFORMATION_TYPE", PyInt_FromLong((long)EVENTLOG_INFORMATION_TYPE));
	PyDict_SetItemString(d, "EVENTLOG_AUDIT_SUCCESS", PyInt_FromLong((long)EVENTLOG_AUDIT_SUCCESS));
	PyDict_SetItemString(d, "EVENTLOG_AUDIT_FAILURE", PyInt_FromLong((long)EVENTLOG_AUDIT_FAILURE));
	PyDict_SetItemString(d, "EVENTLOG_START_PAIRED_EVENT", PyInt_FromLong((long)EVENTLOG_START_PAIRED_EVENT));
	PyDict_SetItemString(d, "EVENTLOG_END_PAIRED_EVENT", PyInt_FromLong((long)EVENTLOG_END_PAIRED_EVENT));
	PyDict_SetItemString(d, "EVENTLOG_END_ALL_PAIRED_EVENTS", PyInt_FromLong((long)EVENTLOG_END_ALL_PAIRED_EVENTS));
	PyDict_SetItemString(d, "EVENTLOG_PAIRED_EVENT_ACTIVE", PyInt_FromLong((long)EVENTLOG_PAIRED_EVENT_ACTIVE));
	PyDict_SetItemString(d, "EVENTLOG_PAIRED_EVENT_INACTIVE", PyInt_FromLong((long)EVENTLOG_PAIRED_EVENT_INACTIVE));

	for (PyMethodDef *pmd = win32evtlogMethods; pmd->ml_name; pmd++)
		if ((strcmp(pmd->ml_name, "EvtOpenChannelEnum") == 0) || (strcmp(pmd->ml_name, "EvtNextChannelPath") == 0) || (strcmp(pmd->ml_name, "EvtOpenLog") == 0) || (strcmp(pmd->ml_name, "EvtClearLog") == 0) || (strcmp(pmd->ml_name, "EvtOpenSession") == 0) || (strcmp(pmd->ml_name, "EvtExportLog") == 0) || (strcmp(pmd->ml_name, "EvtArchiveExportedLog") == 0) || (strcmp(pmd->ml_name, "EvtQuery") == 0) || (strcmp(pmd->ml_name, "EvtNext") == 0) || (strcmp(pmd->ml_name, "EvtSeek") == 0) || (strcmp(pmd->ml_name, "EvtRender") == 0) || (strcmp(pmd->ml_name, "EvtSubscribe") == 0) || (strcmp(pmd->ml_name, "EvtCreateBookmark") == 0) || (strcmp(pmd->ml_name, "EvtUpdateBookmark") == 0) || (strcmp(pmd->ml_name, "EvtGetChannelConfigProperty") == 0) || (strcmp(pmd->ml_name, "EvtOpenChannelConfig") == 0) || (strcmp(pmd->ml_name, "EvtOpenSession") == 0) || (strcmp(pmd->ml_name, "EvtOpenPublisherEnum") == 0) || (strcmp(pmd->ml_name, "EvtNextPublisherId") == 0) || (strcmp(pmd->ml_name, "EvtOpenPublisherMetadata") == 0) || (strcmp(pmd->ml_name, "EvtGetPublisherMetadataProperty") == 0) || (strcmp(pmd->ml_name, "EvtOpenEventMetadataEnum") == 0) || (strcmp(pmd->ml_name, "EvtNextEventMetadata") == 0) || (strcmp(pmd->ml_name, "EvtGetEventMetadataProperty") == 0) || (strcmp(pmd->ml_name, "EvtGetLogInfo") == 0) || (strcmp(pmd->ml_name, "EvtGetEventInfo") == 0) || (strcmp(pmd->ml_name, "EvtGetObjectArraySize") == 0) || (strcmp(pmd->ml_name, "EvtGetObjectArrayProperty") == 0))
		{
			pmd->ml_flags = METH_VARARGS | METH_KEYWORDS;
		}
	PyDict_SetItemString(d, "EvtOpenChannelPath", PyInt_FromLong((long)EvtOpenChannelPath));
	PyDict_SetItemString(d, "EvtOpenFilePath", PyInt_FromLong((long)EvtOpenFilePath));
	PyDict_SetItemString(d, "EvtExportLogChannelPath", PyInt_FromLong((long)EvtExportLogChannelPath));
	PyDict_SetItemString(d, "EvtExportLogFilePath", PyInt_FromLong((long)EvtExportLogFilePath));
	PyDict_SetItemString(d, "EvtExportLogTolerateQueryErrors", PyInt_FromLong((long)EvtExportLogTolerateQueryErrors));
	PyDict_SetItemString(d, "EvtQueryChannelPath", PyInt_FromLong((long)EvtQueryChannelPath));
	PyDict_SetItemString(d, "EvtQueryFilePath", PyInt_FromLong((long)EvtQueryFilePath));
	PyDict_SetItemString(d, "EvtQueryForwardDirection", PyInt_FromLong((long)EvtQueryForwardDirection));
	PyDict_SetItemString(d, "EvtQueryReverseDirection", PyInt_FromLong((long)EvtQueryReverseDirection));
	PyDict_SetItemString(d, "EvtQueryTolerateQueryErrors", PyInt_FromLong((long)EvtQueryTolerateQueryErrors));
	PyDict_SetItemString(d, "EvtSeekRelativeToFirst", PyInt_FromLong((long)EvtSeekRelativeToFirst));
	PyDict_SetItemString(d, "EvtSeekRelativeToLast", PyInt_FromLong((long)EvtSeekRelativeToLast));
	PyDict_SetItemString(d, "EvtSeekRelativeToCurrent", PyInt_FromLong((long)EvtSeekRelativeToCurrent));
	PyDict_SetItemString(d, "EvtSeekRelativeToBookmark", PyInt_FromLong((long)EvtSeekRelativeToBookmark));
	PyDict_SetItemString(d, "EvtSeekOriginMask", PyInt_FromLong((long)EvtSeekOriginMask));
	PyDict_SetItemString(d, "EvtSeekStrict", PyInt_FromLong((long)EvtSeekStrict));
	PyDict_SetItemString(d, "EvtRenderEventValues", PyInt_FromLong((long)EvtRenderEventValues));
	PyDict_SetItemString(d, "EvtRenderEventXml", PyInt_FromLong((long)EvtRenderEventXml));
	PyDict_SetItemString(d, "EvtRenderBookmark", PyInt_FromLong((long)EvtRenderBookmark));
	PyDict_SetItemString(d, "EvtSubscribeToFutureEvents", PyInt_FromLong((long)EvtSubscribeToFutureEvents));
	PyDict_SetItemString(d, "EvtSubscribeStartAtOldestRecord", PyInt_FromLong((long)EvtSubscribeStartAtOldestRecord));
	PyDict_SetItemString(d, "EvtSubscribeStartAfterBookmark", PyInt_FromLong((long)EvtSubscribeStartAfterBookmark));
	PyDict_SetItemString(d, "EvtSubscribeOriginMask", PyInt_FromLong((long)EvtSubscribeOriginMask));
	PyDict_SetItemString(d, "EvtSubscribeTolerateQueryErrors", PyInt_FromLong((long)EvtSubscribeTolerateQueryErrors));
	PyDict_SetItemString(d, "EvtSubscribeStrict", PyInt_FromLong((long)EvtSubscribeStrict));
	PyDict_SetItemString(d, "EvtSubscribeActionError", PyInt_FromLong((long)EvtSubscribeActionError));
	PyDict_SetItemString(d, "EvtSubscribeActionDeliver", PyInt_FromLong((long)EvtSubscribeActionDeliver));
	PyDict_SetItemString(d, "EvtVarTypeNull", PyInt_FromLong((long)EvtVarTypeNull));
	PyDict_SetItemString(d, "EvtVarTypeString", PyInt_FromLong((long)EvtVarTypeString));
	PyDict_SetItemString(d, "EvtVarTypeAnsiString", PyInt_FromLong((long)EvtVarTypeAnsiString));
	PyDict_SetItemString(d, "EvtVarTypeSByte", PyInt_FromLong((long)EvtVarTypeSByte));
	PyDict_SetItemString(d, "EvtVarTypeByte", PyInt_FromLong((long)EvtVarTypeByte));
	PyDict_SetItemString(d, "EvtVarTypeInt16", PyInt_FromLong((long)EvtVarTypeInt16));
	PyDict_SetItemString(d, "EvtVarTypeUInt16", PyInt_FromLong((long)EvtVarTypeUInt16));
	PyDict_SetItemString(d, "EvtVarTypeInt32", PyInt_FromLong((long)EvtVarTypeInt32));
	PyDict_SetItemString(d, "EvtVarTypeUInt32", PyInt_FromLong((long)EvtVarTypeUInt32));
	PyDict_SetItemString(d, "EvtVarTypeInt64", PyInt_FromLong((long)EvtVarTypeInt64));
	PyDict_SetItemString(d, "EvtVarTypeUInt64", PyInt_FromLong((long)EvtVarTypeUInt64));
	PyDict_SetItemString(d, "EvtVarTypeSingle", PyInt_FromLong((long)EvtVarTypeSingle));
	PyDict_SetItemString(d, "EvtVarTypeDouble", PyInt_FromLong((long)EvtVarTypeDouble));
	PyDict_SetItemString(d, "EvtVarTypeBoolean", PyInt_FromLong((long)EvtVarTypeBoolean));
	PyDict_SetItemString(d, "EvtVarTypeBinary", PyInt_FromLong((long)EvtVarTypeBinary));
	PyDict_SetItemString(d, "EvtVarTypeGuid", PyInt_FromLong((long)EvtVarTypeGuid));
	PyDict_SetItemString(d, "EvtVarTypeSizeT", PyInt_FromLong((long)EvtVarTypeSizeT));
	PyDict_SetItemString(d, "EvtVarTypeFileTime", PyInt_FromLong((long)EvtVarTypeFileTime));
	PyDict_SetItemString(d, "EvtVarTypeSysTime", PyInt_FromLong((long)EvtVarTypeSysTime));
	PyDict_SetItemString(d, "EvtVarTypeSid", PyInt_FromLong((long)EvtVarTypeSid));
	PyDict_SetItemString(d, "EvtVarTypeHexInt32", PyInt_FromLong((long)EvtVarTypeHexInt32));
	PyDict_SetItemString(d, "EvtVarTypeHexInt64", PyInt_FromLong((long)EvtVarTypeHexInt64));
	PyDict_SetItemString(d, "EvtVarTypeEvtHandle", PyInt_FromLong((long)EvtVarTypeEvtHandle));
	PyDict_SetItemString(d, "EvtVarTypeEvtXml", PyInt_FromLong((long)EvtVarTypeEvtXml));
	PyDict_SetItemString(d, "EvtChannelConfigEnabled", PyInt_FromLong((long)EvtChannelConfigEnabled));
	PyDict_SetItemString(d, "EvtChannelConfigIsolation", PyInt_FromLong((long)EvtChannelConfigIsolation));
	PyDict_SetItemString(d, "EvtChannelConfigType", PyInt_FromLong((long)EvtChannelConfigType));
	PyDict_SetItemString(d, "EvtChannelConfigOwningPublisher", PyInt_FromLong((long)EvtChannelConfigOwningPublisher));
	PyDict_SetItemString(d, "EvtChannelConfigClassicEventlog", PyInt_FromLong((long)EvtChannelConfigClassicEventlog));
	PyDict_SetItemString(d, "EvtChannelConfigAccess", PyInt_FromLong((long)EvtChannelConfigAccess));
	PyDict_SetItemString(d, "EvtChannelLoggingConfigRetention", PyInt_FromLong((long)EvtChannelLoggingConfigRetention));
	PyDict_SetItemString(d, "EvtChannelLoggingConfigAutoBackup", PyInt_FromLong((long)EvtChannelLoggingConfigAutoBackup));
	PyDict_SetItemString(d, "EvtChannelLoggingConfigMaxSize", PyInt_FromLong((long)EvtChannelLoggingConfigMaxSize));
	PyDict_SetItemString(d, "EvtChannelLoggingConfigLogFilePath", PyInt_FromLong((long)EvtChannelLoggingConfigLogFilePath));
	PyDict_SetItemString(d, "EvtChannelPublishingConfigLevel", PyInt_FromLong((long)EvtChannelPublishingConfigLevel));
	PyDict_SetItemString(d, "EvtChannelPublishingConfigKeywords", PyInt_FromLong((long)EvtChannelPublishingConfigKeywords));
	PyDict_SetItemString(d, "EvtChannelPublishingConfigControlGuid", PyInt_FromLong((long)EvtChannelPublishingConfigControlGuid));
	PyDict_SetItemString(d, "EvtChannelPublishingConfigBufferSize", PyInt_FromLong((long)EvtChannelPublishingConfigBufferSize));
	PyDict_SetItemString(d, "EvtChannelPublishingConfigMinBuffers", PyInt_FromLong((long)EvtChannelPublishingConfigMinBuffers));
	PyDict_SetItemString(d, "EvtChannelPublishingConfigMaxBuffers", PyInt_FromLong((long)EvtChannelPublishingConfigMaxBuffers));
	PyDict_SetItemString(d, "EvtChannelPublishingConfigLatency", PyInt_FromLong((long)EvtChannelPublishingConfigLatency));
	PyDict_SetItemString(d, "EvtChannelPublishingConfigClockType", PyInt_FromLong((long)EvtChannelPublishingConfigClockType));
	PyDict_SetItemString(d, "EvtChannelPublishingConfigSidType", PyInt_FromLong((long)EvtChannelPublishingConfigSidType));
	PyDict_SetItemString(d, "EvtChannelPublisherList", PyInt_FromLong((long)EvtChannelPublisherList));
	PyDict_SetItemString(d, "EvtChannelConfigPropertyIdEND", PyInt_FromLong((long)EvtChannelConfigPropertyIdEND));
	PyDict_SetItemString(d, "EvtRpcLogin", PyInt_FromLong((long)EvtRpcLogin));
	PyDict_SetItemString(d, "EvtRpcLoginAuthDefault", PyInt_FromLong((long)EvtRpcLoginAuthDefault));
	PyDict_SetItemString(d, "EvtRpcLoginAuthNegotiate", PyInt_FromLong((long)EvtRpcLoginAuthNegotiate));
	PyDict_SetItemString(d, "EvtRpcLoginAuthKerberos", PyInt_FromLong((long)EvtRpcLoginAuthKerberos));
	PyDict_SetItemString(d, "EvtRpcLoginAuthNTLM", PyInt_FromLong((long)EvtRpcLoginAuthNTLM));
	PyDict_SetItemString(d, "EvtPublisherMetadataPublisherGuid", PyInt_FromLong((long)EvtPublisherMetadataPublisherGuid));
	PyDict_SetItemString(d, "EvtPublisherMetadataResourceFilePath", PyInt_FromLong((long)EvtPublisherMetadataResourceFilePath));
	PyDict_SetItemString(d, "EvtPublisherMetadataParameterFilePath", PyInt_FromLong((long)EvtPublisherMetadataParameterFilePath));
	PyDict_SetItemString(d, "EvtPublisherMetadataMessageFilePath", PyInt_FromLong((long)EvtPublisherMetadataMessageFilePath));
	PyDict_SetItemString(d, "EvtPublisherMetadataHelpLink", PyInt_FromLong((long)EvtPublisherMetadataHelpLink));
	PyDict_SetItemString(d, "EvtPublisherMetadataPublisherMessageID", PyInt_FromLong((long)EvtPublisherMetadataPublisherMessageID));
	PyDict_SetItemString(d, "EvtPublisherMetadataChannelReferences", PyInt_FromLong((long)EvtPublisherMetadataChannelReferences));
	PyDict_SetItemString(d, "EvtPublisherMetadataChannelReferencePath", PyInt_FromLong((long)EvtPublisherMetadataChannelReferencePath));
	PyDict_SetItemString(d, "EvtPublisherMetadataChannelReferenceIndex", PyInt_FromLong((long)EvtPublisherMetadataChannelReferenceIndex));
	PyDict_SetItemString(d, "EvtPublisherMetadataChannelReferenceID", PyInt_FromLong((long)EvtPublisherMetadataChannelReferenceID));
	PyDict_SetItemString(d, "EvtPublisherMetadataChannelReferenceFlags", PyInt_FromLong((long)EvtPublisherMetadataChannelReferenceFlags));
	PyDict_SetItemString(d, "EvtPublisherMetadataChannelReferenceMessageID", PyInt_FromLong((long)EvtPublisherMetadataChannelReferenceMessageID));
	PyDict_SetItemString(d, "EvtPublisherMetadataLevels", PyInt_FromLong((long)EvtPublisherMetadataLevels));
	PyDict_SetItemString(d, "EvtPublisherMetadataLevelName", PyInt_FromLong((long)EvtPublisherMetadataLevelName));
	PyDict_SetItemString(d, "EvtPublisherMetadataLevelValue", PyInt_FromLong((long)EvtPublisherMetadataLevelValue));
	PyDict_SetItemString(d, "EvtPublisherMetadataLevelMessageID", PyInt_FromLong((long)EvtPublisherMetadataLevelMessageID));
	PyDict_SetItemString(d, "EvtPublisherMetadataTasks", PyInt_FromLong((long)EvtPublisherMetadataTasks));
	PyDict_SetItemString(d, "EvtPublisherMetadataTaskName", PyInt_FromLong((long)EvtPublisherMetadataTaskName));
	PyDict_SetItemString(d, "EvtPublisherMetadataTaskEventGuid", PyInt_FromLong((long)EvtPublisherMetadataTaskEventGuid));
	PyDict_SetItemString(d, "EvtPublisherMetadataTaskValue", PyInt_FromLong((long)EvtPublisherMetadataTaskValue));
	PyDict_SetItemString(d, "EvtPublisherMetadataTaskMessageID", PyInt_FromLong((long)EvtPublisherMetadataTaskMessageID));
	PyDict_SetItemString(d, "EvtPublisherMetadataOpcodes", PyInt_FromLong((long)EvtPublisherMetadataOpcodes));
	PyDict_SetItemString(d, "EvtPublisherMetadataOpcodeName", PyInt_FromLong((long)EvtPublisherMetadataOpcodeName));
	PyDict_SetItemString(d, "EvtPublisherMetadataOpcodeValue", PyInt_FromLong((long)EvtPublisherMetadataOpcodeValue));
	PyDict_SetItemString(d, "EvtPublisherMetadataOpcodeMessageID", PyInt_FromLong((long)EvtPublisherMetadataOpcodeMessageID));
	PyDict_SetItemString(d, "EvtPublisherMetadataKeywords", PyInt_FromLong((long)EvtPublisherMetadataKeywords));
	PyDict_SetItemString(d, "EvtPublisherMetadataKeywordName", PyInt_FromLong((long)EvtPublisherMetadataKeywordName));
	PyDict_SetItemString(d, "EvtPublisherMetadataKeywordValue", PyInt_FromLong((long)EvtPublisherMetadataKeywordValue));
	PyDict_SetItemString(d, "EvtPublisherMetadataKeywordMessageID", PyInt_FromLong((long)EvtPublisherMetadataKeywordMessageID));
	PyDict_SetItemString(d, "EvtPublisherMetadataPropertyIdEND", PyInt_FromLong((long)EvtPublisherMetadataPropertyIdEND));
	PyDict_SetItemString(d, "EventMetadataEventID", PyInt_FromLong((long)EventMetadataEventID));
	PyDict_SetItemString(d, "EventMetadataEventVersion", PyInt_FromLong((long)EventMetadataEventVersion));
	PyDict_SetItemString(d, "EventMetadataEventChannel", PyInt_FromLong((long)EventMetadataEventChannel));
	PyDict_SetItemString(d, "EventMetadataEventLevel", PyInt_FromLong((long)EventMetadataEventLevel));
	PyDict_SetItemString(d, "EventMetadataEventOpcode", PyInt_FromLong((long)EventMetadataEventOpcode));
	PyDict_SetItemString(d, "EventMetadataEventTask", PyInt_FromLong((long)EventMetadataEventTask));
	PyDict_SetItemString(d, "EventMetadataEventKeyword", PyInt_FromLong((long)EventMetadataEventKeyword));
	PyDict_SetItemString(d, "EventMetadataEventMessageID", PyInt_FromLong((long)EventMetadataEventMessageID));
	PyDict_SetItemString(d, "EventMetadataEventTemplate", PyInt_FromLong((long)EventMetadataEventTemplate));
	PyDict_SetItemString(d, "EvtEventMetadataPropertyIdEND", PyInt_FromLong((long)EvtEventMetadataPropertyIdEND));
	PyDict_SetItemString(d, "EvtLogCreationTime", PyInt_FromLong((long)EvtLogCreationTime));
	PyDict_SetItemString(d, "EvtLogLastAccessTime", PyInt_FromLong((long)EvtLogLastAccessTime));
	PyDict_SetItemString(d, "EvtLogLastWriteTime", PyInt_FromLong((long)EvtLogLastWriteTime));
	PyDict_SetItemString(d, "EvtLogFileSize", PyInt_FromLong((long)EvtLogFileSize));
	PyDict_SetItemString(d, "EvtLogAttributes", PyInt_FromLong((long)EvtLogAttributes));
	PyDict_SetItemString(d, "EvtLogNumberOfLogRecords", PyInt_FromLong((long)EvtLogNumberOfLogRecords));
	PyDict_SetItemString(d, "EvtLogOldestRecordNumber", PyInt_FromLong((long)EvtLogOldestRecordNumber));
	PyDict_SetItemString(d, "EvtLogFull", PyInt_FromLong((long)EvtLogFull));
	PyDict_SetItemString(d, "EvtEventQueryIDs", PyInt_FromLong((long)EvtEventQueryIDs));
	PyDict_SetItemString(d, "EvtEventPath", PyInt_FromLong((long)EvtEventPath));
	PyDict_SetItemString(d, "EvtEventPropertyIdEND", PyInt_FromLong((long)EvtEventPropertyIdEND));
#if (PY_VERSION_HEX > 0x03000000)
	return m;
#endif
}
