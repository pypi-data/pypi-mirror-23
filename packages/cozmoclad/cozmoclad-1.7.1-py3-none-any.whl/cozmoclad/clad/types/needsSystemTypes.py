# Copyright (c) 2016 Anki, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the file LICENSE.txt or at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Autogenerated python message buffer code.
Source: clad/types/needsSystemTypes.clad
Full command line: ../tools/message-buffers/emitters/Python_emitter.py -C ./src/ -I ../robot/clad/src/ ../coretech/vision/clad/src/ ../coretech/common/clad/src/ -o ../generated/cladPython// clad/types/needsSystemTypes.clad
"""

from __future__ import absolute_import
from __future__ import print_function

def _modify_path():
  import inspect, os, sys
  search_paths = [
    '../..',
    '../../../../tools/message-buffers/support/python',
  ]
  currentpath = os.path.abspath(os.path.dirname(inspect.getfile(inspect.currentframe())))
  for search_path in search_paths:
    search_path = os.path.normpath(os.path.abspath(os.path.realpath(os.path.join(currentpath, search_path))))
    if search_path not in sys.path:
      sys.path.insert(0, search_path)
_modify_path()

import msgbuffers

Anki = msgbuffers.Namespace()
Anki.Cozmo = msgbuffers.Namespace()

class NeedId(object):
  "Automatically-generated int_32 enumeration."
  Repair = 0
  Energy = 1
  Play   = 2
  Count  = 3

Anki.Cozmo.NeedId = NeedId
del NeedId


class NeedBracketId(object):
  "Automatically-generated int_32 enumeration."
  Full     = 0
  Normal   = 1
  Warning  = 2
  Critical = 3
  Count    = 4

Anki.Cozmo.NeedBracketId = NeedBracketId
del NeedBracketId


class RepairablePartId(object):
  "Automatically-generated int_32 enumeration."
  Head   = 0
  Lift   = 1
  Treads = 2
  Count  = 3

Anki.Cozmo.RepairablePartId = RepairablePartId
del RepairablePartId


class NeedsActionId(object):
  "Automatically-generated int_32 enumeration."
  NoAction         = 0
  Decay            = 1
  RepairHead       = 2
  RepairLift       = 3
  RepairTreads     = 4
  FeedRed          = 5
  FeedBlue         = 6
  FeedGreen        = 7
  Play             = 8
  KeepAwayWin      = 9
  KeepAwayLose     = 10
  MemoryMatchWin   = 11
  MemoryMatchLose  = 12
  QuickTapWin      = 13
  QuickTapLose     = 14
  CozmoSings       = 15
  DizzyHard        = 16
  DizzyMedium      = 17
  DizzySoft        = 18
  Fall             = 19
  FistBump         = 20
  GatherCubes      = 21
  GuardDogLose     = 22
  GuardDogWin      = 23
  HiccupsEndBad    = 24
  HiccupsEndGood   = 25
  KnockDownCubes   = 26
  PeekAboo         = 27
  PickupCube       = 28
  PopAWheelie      = 29
  Pounce           = 30
  PyramidCompleted = 31
  RollACube        = 32
  SayName          = 33
  StackCube        = 34
  Workout          = 35
  SeeFace          = 36
  Count            = 37

Anki.Cozmo.NeedsActionId = NeedsActionId
del NeedsActionId


class NeedsRewardType(object):
  "Automatically-generated int_32 enumeration."
  Sparks      = 0
  Unlock      = 1
  Song        = 2
  MemoryBadge = 3
  Count       = 4

Anki.Cozmo.NeedsRewardType = NeedsRewardType
del NeedsRewardType


class NeedsReward(object):
  "Generated message-passing structure."

  __slots__ = (
    '_rewardType', # Anki.Cozmo.NeedsRewardType
    '_data',       # string[uint_8]
  )

  @property
  def rewardType(self):
    "Anki.Cozmo.NeedsRewardType rewardType struct property."
    return self._rewardType

  @rewardType.setter
  def rewardType(self, value):
    self._rewardType = msgbuffers.validate_integer(
      'NeedsReward.rewardType', value, -2147483648, 2147483647)

  @property
  def data(self):
    "string[uint_8] data struct property."
    return self._data

  @data.setter
  def data(self, value):
    self._data = msgbuffers.validate_string(
      'NeedsReward.data', value, 255)

  def __init__(self, rewardType=Anki.Cozmo.NeedsRewardType.Sparks, data=''):
    self.rewardType = rewardType
    self.data = data

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NeedsReward from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NeedsReward.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NeedsReward from the given BinaryReader."
    _rewardType = reader.read('i')
    _data = reader.read_string('B')
    return cls(_rewardType, _data)

  def pack(self):
    "Writes the current NeedsReward, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NeedsReward to the given BinaryWriter."
    writer.write(self._rewardType, 'i')
    writer.write_string(self._data, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._rewardType == other._rewardType and
        self._data == other._data)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._rewardType, 'i') +
      msgbuffers.size_string(self._data, 'B'))

  def __str__(self):
    return '{type}(rewardType={rewardType}, data={data})'.format(
      type=type(self).__name__,
      rewardType=self._rewardType,
      data=msgbuffers.shorten_string(self._data))

  def __repr__(self):
    return '{type}(rewardType={rewardType}, data={data})'.format(
      type=type(self).__name__,
      rewardType=repr(self._rewardType),
      data=repr(self._data))

Anki.Cozmo.NeedsReward = NeedsReward
del NeedsReward


class NeedsStateOnRobot(object):
  "Generated message-passing structure."

  __slots__ = (
    '_version',             # int_32
    '_timeLastWritten',     # uint_64
    '_curNeedLevel',        # int_32[10]
    '_curNeedsUnlockLevel', # int_32
    '_numStarsAwarded',     # int_32
    '_partIsDamaged',       # bool[32]
    '_timeLastStarAwarded', # uint_64
  )

  @property
  def version(self):
    "int_32 version struct property."
    return self._version

  @version.setter
  def version(self, value):
    self._version = msgbuffers.validate_integer(
      'NeedsStateOnRobot.version', value, -2147483648, 2147483647)

  @property
  def timeLastWritten(self):
    "uint_64 timeLastWritten struct property."
    return self._timeLastWritten

  @timeLastWritten.setter
  def timeLastWritten(self, value):
    self._timeLastWritten = msgbuffers.validate_integer(
      'NeedsStateOnRobot.timeLastWritten', value, 0, 18446744073709551615)

  @property
  def curNeedLevel(self):
    "int_32[10] curNeedLevel struct property."
    return self._curNeedLevel

  @curNeedLevel.setter
  def curNeedLevel(self, value):
    self._curNeedLevel = msgbuffers.validate_farray(
      'NeedsStateOnRobot.curNeedLevel', value, 10,
      lambda name, value_inner: msgbuffers.validate_integer(
        name, value_inner, -2147483648, 2147483647))

  @property
  def curNeedsUnlockLevel(self):
    "int_32 curNeedsUnlockLevel struct property."
    return self._curNeedsUnlockLevel

  @curNeedsUnlockLevel.setter
  def curNeedsUnlockLevel(self, value):
    self._curNeedsUnlockLevel = msgbuffers.validate_integer(
      'NeedsStateOnRobot.curNeedsUnlockLevel', value, -2147483648, 2147483647)

  @property
  def numStarsAwarded(self):
    "int_32 numStarsAwarded struct property."
    return self._numStarsAwarded

  @numStarsAwarded.setter
  def numStarsAwarded(self, value):
    self._numStarsAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot.numStarsAwarded', value, -2147483648, 2147483647)

  @property
  def partIsDamaged(self):
    "bool[32] partIsDamaged struct property."
    return self._partIsDamaged

  @partIsDamaged.setter
  def partIsDamaged(self, value):
    self._partIsDamaged = msgbuffers.validate_farray(
      'NeedsStateOnRobot.partIsDamaged', value, 32,
      lambda name, value_inner: msgbuffers.validate_bool(
        name, value_inner))

  @property
  def timeLastStarAwarded(self):
    "uint_64 timeLastStarAwarded struct property."
    return self._timeLastStarAwarded

  @timeLastStarAwarded.setter
  def timeLastStarAwarded(self, value):
    self._timeLastStarAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot.timeLastStarAwarded', value, 0, 18446744073709551615)

  def __init__(self, version=0, timeLastWritten=0, curNeedLevel=(0,) * 10, curNeedsUnlockLevel=0, numStarsAwarded=0, partIsDamaged=(False,) * 32, timeLastStarAwarded=0):
    self.version = version
    self.timeLastWritten = timeLastWritten
    self.curNeedLevel = curNeedLevel
    self.curNeedsUnlockLevel = curNeedsUnlockLevel
    self.numStarsAwarded = numStarsAwarded
    self.partIsDamaged = partIsDamaged
    self.timeLastStarAwarded = timeLastStarAwarded

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NeedsStateOnRobot from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NeedsStateOnRobot.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NeedsStateOnRobot from the given BinaryReader."
    _version = reader.read('i')
    _timeLastWritten = reader.read('Q')
    _curNeedLevel = reader.read_farray('i', 10)
    _curNeedsUnlockLevel = reader.read('i')
    _numStarsAwarded = reader.read('i')
    _partIsDamaged = list(map(bool, reader.read_farray('b', 32)))
    _timeLastStarAwarded = reader.read('Q')
    return cls(_version, _timeLastWritten, _curNeedLevel, _curNeedsUnlockLevel, _numStarsAwarded, _partIsDamaged, _timeLastStarAwarded)

  def pack(self):
    "Writes the current NeedsStateOnRobot, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NeedsStateOnRobot to the given BinaryWriter."
    writer.write(self._version, 'i')
    writer.write(self._timeLastWritten, 'Q')
    writer.write_farray(self._curNeedLevel, 'i', 10)
    writer.write(self._curNeedsUnlockLevel, 'i')
    writer.write(self._numStarsAwarded, 'i')
    writer.write_farray(list(map(int, self._partIsDamaged)), 'b', 32)
    writer.write(self._timeLastStarAwarded, 'Q')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._version == other._version and
        self._timeLastWritten == other._timeLastWritten and
        self._curNeedLevel == other._curNeedLevel and
        self._curNeedsUnlockLevel == other._curNeedsUnlockLevel and
        self._numStarsAwarded == other._numStarsAwarded and
        self._partIsDamaged == other._partIsDamaged and
        self._timeLastStarAwarded == other._timeLastStarAwarded)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._version, 'i') +
      msgbuffers.size(self._timeLastWritten, 'Q') +
      msgbuffers.size_farray(self._curNeedLevel, 'i', 10) +
      msgbuffers.size(self._curNeedsUnlockLevel, 'i') +
      msgbuffers.size(self._numStarsAwarded, 'i') +
      msgbuffers.size_farray(self._partIsDamaged, 'b', 32) +
      msgbuffers.size(self._timeLastStarAwarded, 'Q'))

  def __str__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded})'.format(
      type=type(self).__name__,
      version=self._version,
      timeLastWritten=self._timeLastWritten,
      curNeedLevel=msgbuffers.shorten_sequence(self._curNeedLevel),
      curNeedsUnlockLevel=self._curNeedsUnlockLevel,
      numStarsAwarded=self._numStarsAwarded,
      partIsDamaged=msgbuffers.shorten_sequence(self._partIsDamaged),
      timeLastStarAwarded=self._timeLastStarAwarded)

  def __repr__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded})'.format(
      type=type(self).__name__,
      version=repr(self._version),
      timeLastWritten=repr(self._timeLastWritten),
      curNeedLevel=repr(self._curNeedLevel),
      curNeedsUnlockLevel=repr(self._curNeedsUnlockLevel),
      numStarsAwarded=repr(self._numStarsAwarded),
      partIsDamaged=repr(self._partIsDamaged),
      timeLastStarAwarded=repr(self._timeLastStarAwarded))

Anki.Cozmo.NeedsStateOnRobot = NeedsStateOnRobot
del NeedsStateOnRobot


class NeedsStateOnRobot_v01(object):
  "Generated message-passing structure."

  __slots__ = (
    '_version',             # int_32
    '_timeLastWritten',     # uint_64
    '_curNeedLevel',        # int_32[10]
    '_curNeedsUnlockLevel', # int_32
    '_numStarsAwarded',     # int_32
    '_partIsDamaged',       # bool[32]
  )

  @property
  def version(self):
    "int_32 version struct property."
    return self._version

  @version.setter
  def version(self, value):
    self._version = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v01.version', value, -2147483648, 2147483647)

  @property
  def timeLastWritten(self):
    "uint_64 timeLastWritten struct property."
    return self._timeLastWritten

  @timeLastWritten.setter
  def timeLastWritten(self, value):
    self._timeLastWritten = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v01.timeLastWritten', value, 0, 18446744073709551615)

  @property
  def curNeedLevel(self):
    "int_32[10] curNeedLevel struct property."
    return self._curNeedLevel

  @curNeedLevel.setter
  def curNeedLevel(self, value):
    self._curNeedLevel = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v01.curNeedLevel', value, 10,
      lambda name, value_inner: msgbuffers.validate_integer(
        name, value_inner, -2147483648, 2147483647))

  @property
  def curNeedsUnlockLevel(self):
    "int_32 curNeedsUnlockLevel struct property."
    return self._curNeedsUnlockLevel

  @curNeedsUnlockLevel.setter
  def curNeedsUnlockLevel(self, value):
    self._curNeedsUnlockLevel = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v01.curNeedsUnlockLevel', value, -2147483648, 2147483647)

  @property
  def numStarsAwarded(self):
    "int_32 numStarsAwarded struct property."
    return self._numStarsAwarded

  @numStarsAwarded.setter
  def numStarsAwarded(self, value):
    self._numStarsAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v01.numStarsAwarded', value, -2147483648, 2147483647)

  @property
  def partIsDamaged(self):
    "bool[32] partIsDamaged struct property."
    return self._partIsDamaged

  @partIsDamaged.setter
  def partIsDamaged(self, value):
    self._partIsDamaged = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v01.partIsDamaged', value, 32,
      lambda name, value_inner: msgbuffers.validate_bool(
        name, value_inner))

  def __init__(self, version=0, timeLastWritten=0, curNeedLevel=(0,) * 10, curNeedsUnlockLevel=0, numStarsAwarded=0, partIsDamaged=(False,) * 32):
    self.version = version
    self.timeLastWritten = timeLastWritten
    self.curNeedLevel = curNeedLevel
    self.curNeedsUnlockLevel = curNeedsUnlockLevel
    self.numStarsAwarded = numStarsAwarded
    self.partIsDamaged = partIsDamaged

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NeedsStateOnRobot_v01 from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NeedsStateOnRobot_v01.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NeedsStateOnRobot_v01 from the given BinaryReader."
    _version = reader.read('i')
    _timeLastWritten = reader.read('Q')
    _curNeedLevel = reader.read_farray('i', 10)
    _curNeedsUnlockLevel = reader.read('i')
    _numStarsAwarded = reader.read('i')
    _partIsDamaged = list(map(bool, reader.read_farray('b', 32)))
    return cls(_version, _timeLastWritten, _curNeedLevel, _curNeedsUnlockLevel, _numStarsAwarded, _partIsDamaged)

  def pack(self):
    "Writes the current NeedsStateOnRobot_v01, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NeedsStateOnRobot_v01 to the given BinaryWriter."
    writer.write(self._version, 'i')
    writer.write(self._timeLastWritten, 'Q')
    writer.write_farray(self._curNeedLevel, 'i', 10)
    writer.write(self._curNeedsUnlockLevel, 'i')
    writer.write(self._numStarsAwarded, 'i')
    writer.write_farray(list(map(int, self._partIsDamaged)), 'b', 32)

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._version == other._version and
        self._timeLastWritten == other._timeLastWritten and
        self._curNeedLevel == other._curNeedLevel and
        self._curNeedsUnlockLevel == other._curNeedsUnlockLevel and
        self._numStarsAwarded == other._numStarsAwarded and
        self._partIsDamaged == other._partIsDamaged)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._version, 'i') +
      msgbuffers.size(self._timeLastWritten, 'Q') +
      msgbuffers.size_farray(self._curNeedLevel, 'i', 10) +
      msgbuffers.size(self._curNeedsUnlockLevel, 'i') +
      msgbuffers.size(self._numStarsAwarded, 'i') +
      msgbuffers.size_farray(self._partIsDamaged, 'b', 32))

  def __str__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged})'.format(
      type=type(self).__name__,
      version=self._version,
      timeLastWritten=self._timeLastWritten,
      curNeedLevel=msgbuffers.shorten_sequence(self._curNeedLevel),
      curNeedsUnlockLevel=self._curNeedsUnlockLevel,
      numStarsAwarded=self._numStarsAwarded,
      partIsDamaged=msgbuffers.shorten_sequence(self._partIsDamaged))

  def __repr__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged})'.format(
      type=type(self).__name__,
      version=repr(self._version),
      timeLastWritten=repr(self._timeLastWritten),
      curNeedLevel=repr(self._curNeedLevel),
      curNeedsUnlockLevel=repr(self._curNeedsUnlockLevel),
      numStarsAwarded=repr(self._numStarsAwarded),
      partIsDamaged=repr(self._partIsDamaged))

Anki.Cozmo.NeedsStateOnRobot_v01 = NeedsStateOnRobot_v01
del NeedsStateOnRobot_v01


class UnlockLevel(object):
  "Generated message-passing structure."

  __slots__ = (
    '_rewards',          # NeedsReward[uint_8]
    '_numStarsToUnlock', # int_32
  )

  @property
  def rewards(self):
    "NeedsReward[uint_8] rewards struct property."
    return self._rewards

  @rewards.setter
  def rewards(self, value):
    self._rewards = msgbuffers.validate_varray(
      'UnlockLevel.rewards', value, 255,
      lambda name, value_inner: msgbuffers.validate_object(
        name, value_inner, Anki.Cozmo.NeedsReward))

  @property
  def numStarsToUnlock(self):
    "int_32 numStarsToUnlock struct property."
    return self._numStarsToUnlock

  @numStarsToUnlock.setter
  def numStarsToUnlock(self, value):
    self._numStarsToUnlock = msgbuffers.validate_integer(
      'UnlockLevel.numStarsToUnlock', value, -2147483648, 2147483647)

  def __init__(self, rewards=(), numStarsToUnlock=0):
    self.rewards = rewards
    self.numStarsToUnlock = numStarsToUnlock

  @classmethod
  def unpack(cls, buffer):
    "Reads a new UnlockLevel from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('UnlockLevel.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new UnlockLevel from the given BinaryReader."
    _rewards = reader.read_object_varray(Anki.Cozmo.NeedsReward.unpack_from, 'B')
    _numStarsToUnlock = reader.read('i')
    return cls(_rewards, _numStarsToUnlock)

  def pack(self):
    "Writes the current UnlockLevel, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current UnlockLevel to the given BinaryWriter."
    writer.write_object_varray(self._rewards, 'B')
    writer.write(self._numStarsToUnlock, 'i')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._rewards == other._rewards and
        self._numStarsToUnlock == other._numStarsToUnlock)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_object_varray(self._rewards, 'B') +
      msgbuffers.size(self._numStarsToUnlock, 'i'))

  def __str__(self):
    return '{type}(rewards={rewards}, numStarsToUnlock={numStarsToUnlock})'.format(
      type=type(self).__name__,
      rewards=msgbuffers.shorten_sequence(self._rewards),
      numStarsToUnlock=self._numStarsToUnlock)

  def __repr__(self):
    return '{type}(rewards={rewards}, numStarsToUnlock={numStarsToUnlock})'.format(
      type=type(self).__name__,
      rewards=repr(self._rewards),
      numStarsToUnlock=repr(self._numStarsToUnlock))

Anki.Cozmo.UnlockLevel = UnlockLevel
del UnlockLevel


