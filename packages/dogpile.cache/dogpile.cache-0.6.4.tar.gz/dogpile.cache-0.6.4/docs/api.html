<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API &#8212; dogpile.cache 0.6.4 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/changelog.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx_paramlinks.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Changelog" href="changelog.html" />
    <link rel="prev" title="dogpile Core" href="core_usage.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Changelog"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="core_usage.html" title="dogpile Core"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">dogpile.cache 0.6.4 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-dogpile.cache.region">
<span id="region"></span><h2>Region<a class="headerlink" href="#module-dogpile.cache.region" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dogpile.cache.region.CacheRegion">
<em class="property">class </em><code class="descclassname">dogpile.cache.region.</code><code class="descname">CacheRegion</code><span class="sig-paren">(</span><em>name=None</em>, <em>function_key_generator=&lt;function function_key_generator&gt;</em>, <em>function_multi_key_generator=&lt;function function_multi_key_generator&gt;</em>, <em>key_mangler=None</em>, <em>async_creation_runner=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>A front end to a particular cache backend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.region.CacheRegion.params.name"></span><strong>name</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.params.name">¶</a> &#8211; Optional, a string name for the region.
This isn&#8217;t used internally
but can be accessed via the <code class="docutils literal"><span class="pre">.name</span></code> parameter, helpful
for configuring a region from a config file.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.params.function_key_generator"></span><strong>function_key_generator</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.params.function_key_generator">¶</a> &#8211; <p>Optional.  A
function that will produce a &#8220;cache key&#8221; given
a data creation function and arguments, when using
the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a> method.
The structure of this function
should be two levels: given the data creation function,
return a new function that generates the key based on
the given arguments.  Such as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_key_generator</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">def</span> <span class="nf">generate_key</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">namespace</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">fname</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">generate_key</span>


<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">(</span>
    <span class="n">function_key_generator</span> <span class="o">=</span> <span class="n">my_key_generator</span>
<span class="p">)</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s2">&quot;dogpile.cache.dbm&quot;</span><span class="p">,</span>
    <span class="n">expiration_time</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;filename&quot;</span><span class="p">:</span><span class="s2">&quot;file.dbm&quot;</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">namespace</span></code> is that passed to
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a>.  It&#8217;s not consulted
outside this function, so in fact can be of any form.
For example, it can be passed as a tuple, used to specify
arguments to pluck from **kw:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_key_generator</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">generate_key</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span><span class="n">kw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">namespace</span><span class="p">]</span> <span class="o">+</span>
                <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">]</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">generate_key</span>
</pre></div>
</div>
<p>Where the decorator might be used as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@my_region</span><span class="o">.</span><span class="n">cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">my_data</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#dogpile.cache.util.function_key_generator" title="dogpile.cache.util.function_key_generator"><code class="xref py py-func docutils literal"><span class="pre">function_key_generator()</span></code></a> - default key generator</p>
<p class="last"><a class="reference internal" href="#dogpile.cache.util.kwarg_function_key_generator" title="dogpile.cache.util.kwarg_function_key_generator"><code class="xref py py-func docutils literal"><span class="pre">kwarg_function_key_generator()</span></code></a> - optional gen that also
uses keyword arguments</p>
</div>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.params.function_multi_key_generator"></span><strong>function_multi_key_generator</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.params.function_multi_key_generator">¶</a> &#8211; <p>Optional.
Similar to <code class="docutils literal"><span class="pre">function_key_generator</span></code> parameter, but it&#8217;s used in
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments" title="dogpile.cache.region.CacheRegion.cache_multi_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_multi_on_arguments()</span></code></a>. Generated function
should return list of keys. For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_multi_key_generator</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="n">namespace</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="n">namespace</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generate_keys</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">namespace</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">generate_keys</span>
</pre></div>
</div>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.params.key_mangler"></span><strong>key_mangler</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.params.key_mangler">¶</a> &#8211; Function which will be used on all incoming
keys before passing to the backend.  Defaults to <code class="docutils literal"><span class="pre">None</span></code>,
in which case the key mangling function recommended by
the cache backend will be used.    A typical mangler
is the SHA1 mangler found at <a class="reference internal" href="#dogpile.cache.util.sha1_mangle_key" title="dogpile.cache.util.sha1_mangle_key"><code class="xref py py-func docutils literal"><span class="pre">sha1_mangle_key()</span></code></a>
which coerces keys into a SHA1
hash, so that the string length is fixed.  To
disable all key mangling, set to <code class="docutils literal"><span class="pre">False</span></code>.   Another typical
mangler is the built-in Python function <code class="docutils literal"><span class="pre">str</span></code>, which can be used
to convert non-string or Unicode keys to bytestrings, which is
needed when using a backend such as bsddb or dbm under Python 2.x
in conjunction with Unicode keys.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.params.async_creation_runner"></span><strong>async_creation_runner</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.params.async_creation_runner">¶</a> &#8211; <p>A callable that, when specified,
will be passed to and called by dogpile.lock when
there is a stale value present in the cache.  It will be passed the
mutex and is responsible releasing that mutex when finished.
This can be used to defer the computation of expensive creator
functions to later points in the future by way of, for example, a
background thread, a long-running queue, or a task manager system
like Celery.</p>
<p>For a specific example using async_creation_runner, new values can
be created in a background thread like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">def</span> <span class="nf">async_creation_runner</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">somekey</span><span class="p">,</span> <span class="n">creator</span><span class="p">,</span> <span class="n">mutex</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Used by dogpile.core:Lock when appropriate  &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">runner</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">creator</span><span class="p">()</span>
            <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">somekey</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">mutex</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">runner</span><span class="p">)</span>
    <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>


<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">(</span>
    <span class="n">async_creation_runner</span><span class="o">=</span><span class="n">async_creation_runner</span><span class="p">,</span>
<span class="p">)</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.memcached&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;url&#39;</span><span class="p">:</span> <span class="s1">&#39;127.0.0.1:11211&#39;</span><span class="p">,</span>
        <span class="s1">&#39;distributed_lock&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Remember that the first request for a key with no associated
value will always block; async_creator will not be invoked.
However, subsequent requests for cached-but-expired values will
still return promptly.  They will be refreshed by whatever
asynchronous means the provided async_creation_runner callable
implements.</p>
<p>By default the async_creation_runner is disabled and is set
to <code class="docutils literal"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.4.2: </span>added the async_creation_runner
feature.</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.cache_multi_on_arguments">
<code class="descname">cache_multi_on_arguments</code><span class="sig-paren">(</span><em>namespace=None</em>, <em>expiration_time=None</em>, <em>should_cache_fn=None</em>, <em>asdict=False</em>, <em>to_str=&lt;type 'str'&gt;</em>, <em>function_multi_key_generator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>A function decorator that will cache multiple return
values from the function using a sequence of keys derived from the
function itself and the arguments passed to it.</p>
<p>This method is the &#8220;multiple key&#8221; analogue to the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a> method.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@someregion</span><span class="o">.</span><span class="n">cache_multi_on_arguments</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">generate_something</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">somedatabase</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>The decorated function can be called normally.  The decorator
will produce a list of cache keys using a mechanism similar to
that of <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a>, combining the
name of the function with the optional namespace and with the
string form of each key.  It will then consult the cache using
the same mechanism as that of <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_multi" title="dogpile.cache.region.CacheRegion.get_multi"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_multi()</span></code></a>
to retrieve all current values; the originally passed keys
corresponding to those values which aren&#8217;t generated or need
regeneration will be assembled into a new argument list, and
the decorated function is then called with that subset of
arguments.</p>
<p>The returned result is a list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">generate_something</span><span class="p">(</span><span class="s2">&quot;key1&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The decorator internally makes use of the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create_multi" title="dogpile.cache.region.CacheRegion.get_or_create_multi"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create_multi()</span></code></a> method to access the
cache and conditionally call the function.  See that
method for additional behavioral details.</p>
<p>Unlike the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a> method,
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments" title="dogpile.cache.region.CacheRegion.cache_multi_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_multi_on_arguments()</span></code></a> works only with
a single function signature, one which takes a simple list of
keys as arguments.</p>
<p>Like <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a>, the decorated function
is also provided with a <code class="docutils literal"><span class="pre">set()</span></code> method, which here accepts a
mapping of keys and values to set in the cache:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">generate_something</span><span class="o">.</span><span class="n">set</span><span class="p">({</span><span class="s2">&quot;k1&quot;</span><span class="p">:</span> <span class="s2">&quot;value1&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;k2&quot;</span><span class="p">:</span> <span class="s2">&quot;value2&quot;</span><span class="p">,</span> <span class="s2">&quot;k3&quot;</span><span class="p">:</span> <span class="s2">&quot;value3&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>...an <code class="docutils literal"><span class="pre">invalidate()</span></code> method, which has the effect of deleting
the given sequence of keys using the same mechanism as that of
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.delete_multi" title="dogpile.cache.region.CacheRegion.delete_multi"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.delete_multi()</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">generate_something</span><span class="o">.</span><span class="n">invalidate</span><span class="p">(</span><span class="s2">&quot;k1&quot;</span><span class="p">,</span> <span class="s2">&quot;k2&quot;</span><span class="p">,</span> <span class="s2">&quot;k3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>...a <code class="docutils literal"><span class="pre">refresh()</span></code> method, which will call the creation
function, cache the new values, and return them:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="n">generate_something</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span><span class="s2">&quot;k1&quot;</span><span class="p">,</span> <span class="s2">&quot;k2&quot;</span><span class="p">,</span> <span class="s2">&quot;k3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>...and a <code class="docutils literal"><span class="pre">get()</span></code> method, which will return values
based on the given arguments:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="n">generate_something</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;k1&quot;</span><span class="p">,</span> <span class="s2">&quot;k2&quot;</span><span class="p">,</span> <span class="s2">&quot;k3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.3: </span>Added <code class="docutils literal"><span class="pre">get()</span></code> method to decorated
function.</p>
</div>
<p>Parameters passed to <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments" title="dogpile.cache.region.CacheRegion.cache_multi_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_multi_on_arguments()</span></code></a>
have the same meaning as those passed to
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.namespace"></span><strong>namespace</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.namespace">¶</a> &#8211; optional string argument which will be
established as part of each cache key.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.expiration_time"></span><strong>expiration_time</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.expiration_time">¶</a> &#8211; if not None, will override the normal
expiration time.  May be passed as an integer or a
callable.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.should_cache_fn"></span><strong>should_cache_fn</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.should_cache_fn">¶</a> &#8211; passed to
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create_multi" title="dogpile.cache.region.CacheRegion.get_or_create_multi"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create_multi()</span></code></a>. This function is given a
value as returned by the creator, and only if it returns True will
that value be placed in the cache.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.asdict"></span><strong>asdict</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.asdict">¶</a> &#8211; <p>if <code class="docutils literal"><span class="pre">True</span></code>, the decorated function should return
its result as a dictionary of keys-&gt;values, and the final result
of calling the decorated function will also be a dictionary.
If left at its default value of <code class="docutils literal"><span class="pre">False</span></code>, the decorated function
should return its result as a list of values, and the final
result of calling the decorated function will also be a list.</p>
<p>When <code class="docutils literal"><span class="pre">asdict==True</span></code> if the dictionary returned by the decorated
function is missing keys, those keys will not be cached.</p>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.to_str"></span><strong>to_str</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.to_str">¶</a> &#8211; callable, will be called on each function argument
in order to convert to a string.  Defaults to <code class="docutils literal"><span class="pre">str()</span></code>.  If the
function accepts non-ascii unicode arguments on Python 2.x, the
<code class="docutils literal"><span class="pre">unicode()</span></code> builtin can be substituted, but note this will
produce unicode cache keys which may require key mangling before
reaching the cache.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.function_multi_key_generator"></span><strong>function_multi_key_generator</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments.params.function_multi_key_generator">¶</a> &#8211; <p>a function that will produce a
list of keys. This function will supersede the one configured on the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a> itself.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.5.</span></p>
</div>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a></p>
<p class="last"><a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create_multi" title="dogpile.cache.region.CacheRegion.get_or_create_multi"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create_multi()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.cache_on_arguments">
<code class="descname">cache_on_arguments</code><span class="sig-paren">(</span><em>namespace=None</em>, <em>expiration_time=None</em>, <em>should_cache_fn=None</em>, <em>to_str=&lt;type 'str'&gt;</em>, <em>function_key_generator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>A function decorator that will cache the return
value of the function using a key derived from the
function itself and its arguments.</p>
<p>The decorator internally makes use of the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></code></a> method to access the
cache and conditionally call the function.  See that
method for additional behavioral details.</p>
<p>E.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@someregion</span><span class="o">.</span><span class="n">cache_on_arguments</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">generate_something</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">somedatabase</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>The decorated function can then be called normally, where
data will be pulled from the cache region unless a new
value is needed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">generate_something</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>The function is also given an attribute <code class="docutils literal"><span class="pre">invalidate()</span></code>, which
provides for invalidation of the value.  Pass to <code class="docutils literal"><span class="pre">invalidate()</span></code>
the same arguments you&#8217;d pass to the function itself to represent
a particular value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">generate_something</span><span class="o">.</span><span class="n">invalidate</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>Another attribute <code class="docutils literal"><span class="pre">set()</span></code> is added to provide extra caching
possibilities relative to the function.   This is a convenience
method for <a class="reference internal" href="#dogpile.cache.region.CacheRegion.set" title="dogpile.cache.region.CacheRegion.set"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.set()</span></code></a> which will store a given
value directly without calling the decorated function.
The value to be cached is passed as the first argument, and the
arguments which would normally be passed to the function
should follow:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">generate_something</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>The above example is equivalent to calling
<code class="docutils literal"><span class="pre">generate_something(5,</span> <span class="pre">6)</span></code>, if the function were to produce
the value <code class="docutils literal"><span class="pre">3</span></code> as the value to be cached.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.4.1: </span>Added <code class="docutils literal"><span class="pre">set()</span></code> method to decorated function.</p>
</div>
<p>Similar to <code class="docutils literal"><span class="pre">set()</span></code> is <code class="docutils literal"><span class="pre">refresh()</span></code>.   This attribute will
invoke the decorated function and populate a new value into
the cache with the new value, as well as returning that value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">newvalue</span> <span class="o">=</span> <span class="n">generate_something</span><span class="o">.</span><span class="n">refresh</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0: </span>Added <code class="docutils literal"><span class="pre">refresh()</span></code> method to decorated
function.</p>
</div>
<p>Lastly, the <code class="docutils literal"><span class="pre">get()</span></code> method returns either the value cached
for the given key, or the token <code class="docutils literal"><span class="pre">NO_VALUE</span></code> if no such key
exists:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">value</span> <span class="o">=</span> <span class="n">generate_something</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.3: </span>Added <code class="docutils literal"><span class="pre">get()</span></code> method to decorated
function.</p>
</div>
<p>The default key generation will use the name
of the function, the module name for the function,
the arguments passed, as well as an optional &#8220;namespace&#8221;
parameter in order to generate a cache key.</p>
<p>Given a function <code class="docutils literal"><span class="pre">one</span></code> inside the module
<code class="docutils literal"><span class="pre">myapp.tools</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@region</span><span class="o">.</span><span class="n">cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>Above, calling <code class="docutils literal"><span class="pre">one(3,</span> <span class="pre">4)</span></code> will produce a
cache key as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">myapp</span><span class="o">.</span><span class="n">tools</span><span class="p">:</span><span class="n">one</span><span class="o">|</span><span class="n">foo</span><span class="o">|</span><span class="mi">3</span> <span class="mi">4</span>
</pre></div>
</div>
<p>The key generator will ignore an initial argument
of <code class="docutils literal"><span class="pre">self</span></code> or <code class="docutils literal"><span class="pre">cls</span></code>, making the decorator suitable
(with caveats) for use with instance or class methods.
Given the example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@region</span><span class="o">.</span><span class="n">cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>The cache key above for <code class="docutils literal"><span class="pre">MyClass().one(3,</span> <span class="pre">4)</span></code> will
again produce the same cache key of <code class="docutils literal"><span class="pre">myapp.tools:one|foo|3</span> <span class="pre">4</span></code> -
the name <code class="docutils literal"><span class="pre">self</span></code> is skipped.</p>
<p>The <code class="docutils literal"><span class="pre">namespace</span></code> parameter is optional, and is used
normally to disambiguate two functions of the same
name within the same module, as can occur when decorating
instance or class methods as below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@region</span><span class="o">.</span><span class="n">cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;MC&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">somemethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="s2">&quot;&quot;</span>

<span class="k">class</span> <span class="nc">MyOtherClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@region</span><span class="o">.</span><span class="n">cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;MOC&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">somemethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="s2">&quot;&quot;</span>
</pre></div>
</div>
<p>Above, the <code class="docutils literal"><span class="pre">namespace</span></code> parameter disambiguates
between <code class="docutils literal"><span class="pre">somemethod</span></code> on <code class="docutils literal"><span class="pre">MyClass</span></code> and <code class="docutils literal"><span class="pre">MyOtherClass</span></code>.
Python class declaration mechanics otherwise prevent
the decorator from having awareness of the <code class="docutils literal"><span class="pre">MyClass</span></code>
and <code class="docutils literal"><span class="pre">MyOtherClass</span></code> names, as the function is received
by the decorator before it becomes an instance method.</p>
<p>The function key generation can be entirely replaced
on a per-region basis using the <code class="docutils literal"><span class="pre">function_key_generator</span></code>
argument present on <a class="reference internal" href="#dogpile.cache.region.make_region" title="dogpile.cache.region.make_region"><code class="xref py py-func docutils literal"><span class="pre">make_region()</span></code></a> and
<a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>. If defaults to
<a class="reference internal" href="#dogpile.cache.util.function_key_generator" title="dogpile.cache.util.function_key_generator"><code class="xref py py-func docutils literal"><span class="pre">function_key_generator()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_on_arguments.params.namespace"></span><strong>namespace</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments.params.namespace">¶</a> &#8211; optional string argument which will be
established as part of the cache key.   This may be needed
to disambiguate functions of the same name within the same
source file, such as those
associated with classes - note that the decorator itself
can&#8217;t see the parent class on a function as the class is
being declared.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_on_arguments.params.expiration_time"></span><strong>expiration_time</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments.params.expiration_time">¶</a> &#8211; <p>if not None, will override the normal
expiration time.</p>
<p>May be specified as a callable, taking no arguments, that
returns a value to be used as the <code class="docutils literal"><span class="pre">expiration_time</span></code>. This callable
will be called whenever the decorated function itself is called, in
caching or retrieving. Thus, this can be used to
determine a <em>dynamic</em> expiration time for the cached function
result.  Example use cases include &#8220;cache the result until the
end of the day, week or time period&#8221; and &#8220;cache until a certain date
or time passes&#8221;.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.5.0: </span><code class="docutils literal"><span class="pre">expiration_time</span></code> may be passed as a callable to
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a>.</p>
</div>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_on_arguments.params.should_cache_fn"></span><strong>should_cache_fn</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments.params.should_cache_fn">¶</a> &#8211; <p>passed to <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.4.3.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_on_arguments.params.to_str"></span><strong>to_str</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments.params.to_str">¶</a> &#8211; <p>callable, will be called on each function argument
in order to convert to a string.  Defaults to <code class="docutils literal"><span class="pre">str()</span></code>.  If the
function accepts non-ascii unicode arguments on Python 2.x, the
<code class="docutils literal"><span class="pre">unicode()</span></code> builtin can be substituted, but note this will
produce unicode cache keys which may require key mangling before
reaching the cache.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.cache_on_arguments.params.function_key_generator"></span><strong>function_key_generator</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments.params.function_key_generator">¶</a> &#8211; <p>a function that will produce a
&#8220;cache key&#8221;. This function will supersede the one configured on the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a> itself.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.5.</span></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments" title="dogpile.cache.region.CacheRegion.cache_multi_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_multi_on_arguments()</span></code></a></p>
<p class="last"><a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.configure">
<code class="descname">configure</code><span class="sig-paren">(</span><em>backend</em>, <em>expiration_time=None</em>, <em>arguments=None</em>, <em>_config_argument_dict=None</em>, <em>_config_prefix=None</em>, <em>wrap=None</em>, <em>replace_existing_backend=False</em>, <em>region_invalidator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure a <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>.</p>
<p>The <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a> itself
is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.region.CacheRegion.configure.params.backend"></span><strong>backend</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.configure.params.backend">¶</a> &#8211; Required.  This is the name of the
<a class="reference internal" href="#dogpile.cache.api.CacheBackend" title="dogpile.cache.api.CacheBackend"><code class="xref py py-class docutils literal"><span class="pre">CacheBackend</span></code></a> to use, and is resolved by loading
the class from the <code class="docutils literal"><span class="pre">dogpile.cache</span></code> entrypoint.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.configure.params.expiration_time"></span><strong>expiration_time</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.configure.params.expiration_time">¶</a> &#8211; <p>Optional.  The expiration time passed
to the dogpile system.  May be passed as an integer number
of seconds, or as a <code class="docutils literal"><span class="pre">datetime.timedelta</span></code> value.</p>
<p>The <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></code></a>
method as well as the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a>
decorator (though note:  <strong>not</strong> the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get" title="dogpile.cache.region.CacheRegion.get"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get()</span></code></a>
method) will call upon the value creation function after this
time period has passed since the last generation.</p>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.configure.params.arguments"></span><strong>arguments</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.configure.params.arguments">¶</a> &#8211; Optional.  The structure here is passed
directly to the constructor of the <a class="reference internal" href="#dogpile.cache.api.CacheBackend" title="dogpile.cache.api.CacheBackend"><code class="xref py py-class docutils literal"><span class="pre">CacheBackend</span></code></a>
in use, though is typically a dictionary.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.configure.params.wrap"></span><strong>wrap</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.configure.params.wrap">¶</a> &#8211; <p>Optional.  A list of <a class="reference internal" href="#dogpile.cache.proxy.ProxyBackend" title="dogpile.cache.proxy.ProxyBackend"><code class="xref py py-class docutils literal"><span class="pre">ProxyBackend</span></code></a>
classes and/or instances, each of which will be applied
in a chain to ultimately wrap the original backend,
so that custom functionality augmentation can be applied.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="usage.html#changing-backend-behavior"><span class="std std-ref">Changing Backend Behavior</span></a></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.configure.params.replace_existing_backend"></span><strong>replace_existing_backend</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.configure.params.replace_existing_backend">¶</a> &#8211; <p>if True, the existing cache backend
will be replaced.  Without this flag, an exception is raised if
a backend is already configured.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.7.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.configure.params.region_invalidator"></span><strong>region_invalidator</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.configure.params.region_invalidator">¶</a> &#8211; <p>Optional. Override default invalidation
strategy with custom implementation of
<a class="reference internal" href="#dogpile.cache.region.RegionInvalidationStrategy" title="dogpile.cache.region.RegionInvalidationStrategy"><code class="xref py py-class docutils literal"><span class="pre">RegionInvalidationStrategy</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.6.2.</span></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.configure_from_config">
<code class="descname">configure_from_config</code><span class="sig-paren">(</span><em>config_dict</em>, <em>prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.configure_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure from a configuration dictionary
and a prefix.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">local_region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span>
<span class="n">memcached_region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span>

<span class="c1"># regions are ready to use for function</span>
<span class="c1"># decorators, but not yet for actual caching</span>

<span class="c1"># later, when config is available</span>
<span class="n">myconfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;cache.local.backend&quot;</span><span class="p">:</span><span class="s2">&quot;dogpile.cache.dbm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cache.local.arguments.filename&quot;</span><span class="p">:</span><span class="s2">&quot;/path/to/dbmfile.dbm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cache.memcached.backend&quot;</span><span class="p">:</span><span class="s2">&quot;dogpile.cache.pylibmc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cache.memcached.arguments.url&quot;</span><span class="p">:</span><span class="s2">&quot;127.0.0.1, 10.0.0.1&quot;</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">local_region</span><span class="o">.</span><span class="n">configure_from_config</span><span class="p">(</span><span class="n">myconfig</span><span class="p">,</span> <span class="s2">&quot;cache.local.&quot;</span><span class="p">)</span>
<span class="n">memcached_region</span><span class="o">.</span><span class="n">configure_from_config</span><span class="p">(</span><span class="n">myconfig</span><span class="p">,</span>
                                    <span class="s2">&quot;cache.memcached.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a value from the cache.</p>
<p>This operation is idempotent (can be called multiple times, or on a
non-existent key, safely)</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.delete_multi">
<code class="descname">delete_multi</code><span class="sig-paren">(</span><em>keys</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.delete_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove multiple values from the cache.</p>
<p>This operation is idempotent (can be called multiple times, or on a
non-existent key, safely)</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>key</em>, <em>expiration_time=None</em>, <em>ignore_expiration=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a value from the cache, based on the given key.</p>
<p>If the value is not present, the method returns the token
<code class="docutils literal"><span class="pre">NO_VALUE</span></code>. <code class="docutils literal"><span class="pre">NO_VALUE</span></code> evaluates to False, but is separate from
<code class="docutils literal"><span class="pre">None</span></code> to distinguish between a cached value of <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>By default, the configured expiration time of the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>, or alternatively the expiration
time supplied by the <code class="docutils literal"><span class="pre">expiration_time</span></code> argument,
is tested against the creation time of the retrieved
value versus the current time (as reported by <code class="docutils literal"><span class="pre">time.time()</span></code>).
If stale, the cached value is ignored and the <code class="docutils literal"><span class="pre">NO_VALUE</span></code>
token is returned.  Passing the flag <code class="docutils literal"><span class="pre">ignore_expiration=True</span></code>
bypasses the expiration time check.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.3.0: </span><a class="reference internal" href="#dogpile.cache.region.CacheRegion.get" title="dogpile.cache.region.CacheRegion.get"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get()</span></code></a> now checks the value&#8217;s creation time
against the expiration time, rather than returning
the value unconditionally.</p>
</div>
<p>The method also interprets the cached value in terms
of the current &#8220;invalidation&#8221; time as set by
the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><code class="xref py py-meth docutils literal"><span class="pre">invalidate()</span></code></a> method.   If a value is present,
but its creation time is older than the current
invalidation time, the <code class="docutils literal"><span class="pre">NO_VALUE</span></code> token is returned.
Passing the flag <code class="docutils literal"><span class="pre">ignore_expiration=True</span></code> bypasses
the invalidation time check.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.3.0: </span>Support for the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.invalidate()</span></code></a>
method.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.region.CacheRegion.get.params.key"></span><strong>key</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get.params.key">¶</a> &#8211; Key to be retrieved. While it&#8217;s typical for a key to be a
string, it is ultimately passed directly down to the cache backend,
before being optionally processed by the key_mangler function, so can
be of any type recognized by the backend or by the key_mangler
function, if present.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.get.params.expiration_time"></span><strong>expiration_time</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get.params.expiration_time">¶</a> &#8211; <p>Optional expiration time value
which will supersede that configured on the <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>
itself.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.3.0.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.get.params.ignore_expiration"></span><strong>ignore_expiration</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get.params.ignore_expiration">¶</a> &#8211; <p>if <code class="docutils literal"><span class="pre">True</span></code>, the value is returned
from the cache if present, regardless of configured
expiration times or whether or not <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><code class="xref py py-meth docutils literal"><span class="pre">invalidate()</span></code></a>
was called.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.3.0.</span></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.get_multi">
<code class="descname">get_multi</code><span class="sig-paren">(</span><em>keys</em>, <em>expiration_time=None</em>, <em>ignore_expiration=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.get_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return multiple values from the cache, based on the given keys.</p>
<p>Returns values as a list matching the keys given.</p>
<p>E.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get_multi</span><span class="p">([</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>To convert values to a dictionary, use <code class="docutils literal"><span class="pre">zip()</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">]</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get_multi</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="n">dictionary</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
</pre></div>
</div>
<p>Keys which aren&#8217;t present in the list are returned as
the <code class="docutils literal"><span class="pre">NO_VALUE</span></code> token.  <code class="docutils literal"><span class="pre">NO_VALUE</span></code> evaluates to False,
but is separate from
<code class="docutils literal"><span class="pre">None</span></code> to distinguish between a cached value of <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>By default, the configured expiration time of the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>, or alternatively the expiration
time supplied by the <code class="docutils literal"><span class="pre">expiration_time</span></code> argument,
is tested against the creation time of the retrieved
value versus the current time (as reported by <code class="docutils literal"><span class="pre">time.time()</span></code>).
If stale, the cached value is ignored and the <code class="docutils literal"><span class="pre">NO_VALUE</span></code>
token is returned.  Passing the flag <code class="docutils literal"><span class="pre">ignore_expiration=True</span></code>
bypasses the expiration time check.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.get_or_create">
<code class="descname">get_or_create</code><span class="sig-paren">(</span><em>key</em>, <em>creator</em>, <em>expiration_time=None</em>, <em>should_cache_fn=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.get_or_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cached value based on the given key.</p>
<p>If the value does not exist or is considered to be expired
based on its creation time, the given
creation function may or may not be used to recreate the value
and persist the newly generated value in the cache.</p>
<p>Whether or not the function is used depends on if the
<em>dogpile lock</em> can be acquired or not.  If it can&#8217;t, it means
a different thread or process is already running a creation
function for this key against the cache.  When the dogpile
lock cannot be acquired, the method will block if no
previous value is available, until the lock is released and
a new value available.  If a previous value
is available, that value is returned immediately without blocking.</p>
<p>If the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><code class="xref py py-meth docutils literal"><span class="pre">invalidate()</span></code></a> method has been called, and
the retrieved value&#8217;s timestamp is older than the invalidation
timestamp, the value is unconditionally prevented from
being returned.  The method will attempt to acquire the dogpile
lock to generate a new value, or will wait
until the lock is released to return the new value.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.3.0: </span>The value is unconditionally regenerated if the creation
time is older than the last call to <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><code class="xref py py-meth docutils literal"><span class="pre">invalidate()</span></code></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.region.CacheRegion.get_or_create.params.key"></span><strong>key</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create.params.key">¶</a> &#8211; Key to be retrieved. While it&#8217;s typical for a key to be a
string, it is ultimately passed directly down to the cache backend,
before being optionally processed by the key_mangler function, so can
be of any type recognized by the backend or by the key_mangler
function, if present.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.get_or_create.params.creator"></span><strong>creator</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create.params.creator">¶</a> &#8211; function which creates a new value.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.get_or_create.params.expiration_time"></span><strong>expiration_time</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create.params.expiration_time">¶</a> &#8211; optional expiration time which will overide
the expiration time already configured on this <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>
if not None.   To set no expiration, use the value -1.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.get_or_create.params.should_cache_fn"></span><strong>should_cache_fn</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create.params.should_cache_fn">¶</a> &#8211; <p>optional callable function which will receive
the value returned by the &#8220;creator&#8221;, and will then return True or
False, indicating if the value should actually be cached or not.  If
it returns False, the value is still returned, but isn&#8217;t cached.
E.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dont_cache_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

<span class="n">value</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="s2">&quot;some key&quot;</span><span class="p">,</span>
                    <span class="n">create_value</span><span class="p">,</span>
                    <span class="n">should_cache_fn</span><span class="o">=</span><span class="n">dont_cache_none</span><span class="p">)</span>
</pre></div>
</div>
<p>Above, the function returns the value of create_value() if
the cache is invalid, however if the return value is None,
it won&#8217;t be cached.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.4.3.</span></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a> - applies
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><code class="xref py py-meth docutils literal"><span class="pre">get_or_create()</span></code></a> to any function using a decorator.</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create_multi" title="dogpile.cache.region.CacheRegion.get_or_create_multi"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create_multi()</span></code></a> - multiple key/value</dt>
<dd>version</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.get_or_create_multi">
<code class="descname">get_or_create_multi</code><span class="sig-paren">(</span><em>keys</em>, <em>creator</em>, <em>expiration_time=None</em>, <em>should_cache_fn=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.get_or_create_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sequence of cached values based on a sequence of keys.</p>
<p>The behavior for generation of values based on keys corresponds
to that of <code class="xref py py-meth docutils literal"><span class="pre">Region.get_or_create()</span></code>, with the exception that
the <code class="docutils literal"><span class="pre">creator()</span></code> function may be asked to generate any subset of
the given keys.   The list of keys to be generated is passed to
<code class="docutils literal"><span class="pre">creator()</span></code>, and <code class="docutils literal"><span class="pre">creator()</span></code> should return the generated values
as a sequence corresponding to the order of the keys.</p>
<p>The method uses the same approach as <code class="xref py py-meth docutils literal"><span class="pre">Region.get_multi()</span></code>
and <code class="xref py py-meth docutils literal"><span class="pre">Region.set_multi()</span></code> to get and set values from the
backend.</p>
<p>If you are using a <a class="reference internal" href="#dogpile.cache.api.CacheBackend" title="dogpile.cache.api.CacheBackend"><code class="xref py py-class docutils literal"><span class="pre">CacheBackend</span></code></a> or <a class="reference internal" href="#dogpile.cache.proxy.ProxyBackend" title="dogpile.cache.proxy.ProxyBackend"><code class="xref py py-class docutils literal"><span class="pre">ProxyBackend</span></code></a>
that modifies values, take note this function invokes
<code class="docutils literal"><span class="pre">.set_multi()</span></code> for newly generated values using the same values it
returns to the calling function. A correct implementation of
<code class="docutils literal"><span class="pre">.set_multi()</span></code> will not modify values in-place on the submitted
<code class="docutils literal"><span class="pre">mapping</span></code> dict.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.region.CacheRegion.get_or_create_multi.params.keys"></span><strong>keys</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create_multi.params.keys">¶</a> &#8211; Sequence of keys to be retrieved.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.get_or_create_multi.params.creator"></span><strong>creator</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create_multi.params.creator">¶</a> &#8211; function which accepts a sequence of keys and
returns a sequence of new values.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.get_or_create_multi.params.expiration_time"></span><strong>expiration_time</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create_multi.params.expiration_time">¶</a> &#8211; optional expiration time which will overide
the expiration time already configured on this <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>
if not None.   To set no expiration, use the value -1.</li>
<li><span class="target" id="dogpile.cache.region.CacheRegion.get_or_create_multi.params.should_cache_fn"></span><strong>should_cache_fn</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create_multi.params.should_cache_fn">¶</a> &#8211; optional callable function which will receive
each value returned by the &#8220;creator&#8221;, and will then return True or
False, indicating if the value should actually be cached or not.  If
it returns False, the value is still returned, but isn&#8217;t cached.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_multi_on_arguments" title="dogpile.cache.region.CacheRegion.cache_multi_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_multi_on_arguments()</span></code></a></p>
<p class="last"><a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.invalidate">
<code class="descname">invalidate</code><span class="sig-paren">(</span><em>hard=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate this <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>.</p>
<p>The default invalidation system works by setting
a current timestamp (using <code class="docutils literal"><span class="pre">time.time()</span></code>)
representing the &#8220;minimum creation time&#8221; for
a value.  Any retrieved value whose creation
time is prior to this timestamp
is considered to be stale.  It does not
affect the data in the cache in any way, and is also
local to this instance of <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>.</p>
<p>Once set, the invalidation time is honored by
the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></code></a>,
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create_multi" title="dogpile.cache.region.CacheRegion.get_or_create_multi"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create_multi()</span></code></a> and
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get" title="dogpile.cache.region.CacheRegion.get"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get()</span></code></a> methods.</p>
<p>The method supports both &#8220;hard&#8221; and &#8220;soft&#8221; invalidation
options.  With &#8220;hard&#8221; invalidation,
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></code></a> will force an immediate
regeneration of the value which all getters will wait for.
With &#8220;soft&#8221; invalidation, subsequent getters will return the
&#8220;old&#8221; value until the new one is available.</p>
<p>Usage of &#8220;soft&#8221; invalidation requires that the region or the method
is given a non-None expiration time.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.3.0.</span></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="dogpile.cache.region.CacheRegion.invalidate.params.hard"></span><strong>hard</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.region.CacheRegion.invalidate.params.hard">¶</a> &#8211; <p>if True, cache values will all require immediate
regeneration; dogpile logic won&#8217;t be used.  If False, the
creation time of existing values will be pushed back before
the expiration time so that a return+regen will be invoked.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.1.</span></p>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="dogpile.cache.region.CacheRegion.is_configured">
<code class="descname">is_configured</code><a class="headerlink" href="#dogpile.cache.region.CacheRegion.is_configured" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the backend has been configured via the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.configure" title="dogpile.cache.region.CacheRegion.configure"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.configure()</span></code></a> method already.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.1.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Place a new value in the cache under the given key.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.set_multi">
<code class="descname">set_multi</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.set_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Place new values in the cache under the given keys.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.wrap">
<code class="descname">wrap</code><span class="sig-paren">(</span><em>proxy</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.CacheRegion.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a ProxyBackend instance or class and wraps the
attached backend.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dogpile.cache.region.RegionInvalidationStrategy">
<em class="property">class </em><code class="descclassname">dogpile.cache.region.</code><code class="descname">RegionInvalidationStrategy</code><a class="headerlink" href="#dogpile.cache.region.RegionInvalidationStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Region invalidation strategy interface</p>
<p>Implement this interface and pass implementation instance
to <a class="reference internal" href="#dogpile.cache.region.CacheRegion.configure" title="dogpile.cache.region.CacheRegion.configure"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.configure()</span></code></a> to override default region invalidation.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomInvalidationStrategy</span><span class="p">(</span><span class="n">RegionInvalidationStrategy</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_soft_invalidated</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hard_invalidated</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hard</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">hard</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_soft_invalidated</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hard_invalidated</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_soft_invalidated</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hard_invalidated</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">is_invalidated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_soft_invalidated</span> <span class="ow">and</span>
                 <span class="n">timestamp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_soft_invalidated</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hard_invalidated</span> <span class="ow">and</span>
                 <span class="n">timestamp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hard_invalidated</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">was_hard_invalidated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hard_invalidated</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_hard_invalidated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hard_invalidated</span> <span class="ow">and</span>
                <span class="n">timestamp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hard_invalidated</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">was_soft_invalidated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_soft_invalidated</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_soft_invalidated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_soft_invalidated</span> <span class="ow">and</span>
                <span class="n">timestamp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_soft_invalidated</span><span class="p">)</span>
</pre></div>
</div>
<p>The custom implementation is injected into a <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>
at configure time using the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.configure.params.region_invalidator" title="dogpile.cache.region.CacheRegion.configure"><code class="xref py py-paramref docutils literal"><span class="pre">CacheRegion.configure.region_invalidator</span></code></a> parameter:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">region</span> <span class="o">=</span> <span class="n">CacheRegion</span><span class="p">()</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">region_invalidator</span><span class="o">=</span><span class="n">CustomInvalidationStrategy</span><span class="p">())</span>
</pre></div>
</div>
<p>Invalidation strategies that wish to have access to the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a> itself should construct the invalidator given the
region as an argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyInvalidator</span><span class="p">(</span><span class="n">RegionInvalidationStrategy</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="n">region</span>
        <span class="c1"># ...</span>

    <span class="c1"># ...</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">CacheRegion</span><span class="p">()</span>
<span class="n">region</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">region_invalidator</span><span class="o">=</span><span class="n">MyInvalidator</span><span class="p">(</span><span class="n">region</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.6.2.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dogpile.cache.region.CacheRegion.configure.params.region_invalidator" title="dogpile.cache.region.CacheRegion.configure"><code class="xref py py-paramref docutils literal"><span class="pre">CacheRegion.configure.region_invalidator</span></code></a></p>
</div>
<dl class="method">
<dt id="dogpile.cache.region.RegionInvalidationStrategy.invalidate">
<code class="descname">invalidate</code><span class="sig-paren">(</span><em>hard=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.RegionInvalidationStrategy.invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>Region invalidation.</p>
<p><a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a> propagated call.
The default invalidation system works by setting
a current timestamp (using <code class="docutils literal"><span class="pre">time.time()</span></code>) to consider all older
timestamps effectively invalidated.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.RegionInvalidationStrategy.is_hard_invalidated">
<code class="descname">is_hard_invalidated</code><span class="sig-paren">(</span><em>timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.RegionInvalidationStrategy.is_hard_invalidated" title="Permalink to this definition">¶</a></dt>
<dd><p>Check timestamp to determine if it was hard invalidated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Boolean. True if <code class="docutils literal"><span class="pre">timestamp</span></code> is older than
the last region invalidation time and region is invalidated
in hard mode.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.RegionInvalidationStrategy.is_invalidated">
<code class="descname">is_invalidated</code><span class="sig-paren">(</span><em>timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.RegionInvalidationStrategy.is_invalidated" title="Permalink to this definition">¶</a></dt>
<dd><p>Check timestamp to determine if it was invalidated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Boolean. True if <code class="docutils literal"><span class="pre">timestamp</span></code> is older than
the last region invalidation time.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.RegionInvalidationStrategy.is_soft_invalidated">
<code class="descname">is_soft_invalidated</code><span class="sig-paren">(</span><em>timestamp</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.RegionInvalidationStrategy.is_soft_invalidated" title="Permalink to this definition">¶</a></dt>
<dd><p>Check timestamp to determine if it was soft invalidated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Boolean. True if <code class="docutils literal"><span class="pre">timestamp</span></code> is older than
the last region invalidation time and region is invalidated
in soft mode.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.RegionInvalidationStrategy.was_hard_invalidated">
<code class="descname">was_hard_invalidated</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.RegionInvalidationStrategy.was_hard_invalidated" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate the region was invalidated in hard mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Boolean. True if region was invalidated in hard mode.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.RegionInvalidationStrategy.was_soft_invalidated">
<code class="descname">was_soft_invalidated</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.RegionInvalidationStrategy.was_soft_invalidated" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate the region was invalidated in soft mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Boolean. True if region was invalidated in soft mode.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dogpile.cache.region.make_region">
<code class="descclassname">dogpile.cache.region.</code><code class="descname">make_region</code><span class="sig-paren">(</span><em>*arg</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.region.make_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a new <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>.</p>
<p>Currently, <a class="reference internal" href="#dogpile.cache.region.make_region" title="dogpile.cache.region.make_region"><code class="xref py py-func docutils literal"><span class="pre">make_region()</span></code></a> is a passthrough
to <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>.  See that class for
constructor arguments.</p>
</dd></dl>

<dl class="data">
<dt id="dogpile.cache.region.value_version">
<code class="descclassname">dogpile.cache.region.</code><code class="descname">value_version</code><em class="property"> = 1</em><a class="headerlink" href="#dogpile.cache.region.value_version" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer placed in the <a class="reference internal" href="#dogpile.cache.api.CachedValue" title="dogpile.cache.api.CachedValue"><code class="xref py py-class docutils literal"><span class="pre">CachedValue</span></code></a>
so that new versions of dogpile.cache can detect cached
values from a previous, backwards-incompatible version.</p>
</dd></dl>

</div>
<div class="section" id="backend-api">
<h2>Backend API<a class="headerlink" href="#backend-api" title="Permalink to this headline">¶</a></h2>
<p>See the section <a class="reference internal" href="usage.html#creating-backends"><span class="std std-ref">Creating Backends</span></a> for details on how to
register new backends or <a class="reference internal" href="usage.html#changing-backend-behavior"><span class="std std-ref">Changing Backend Behavior</span></a> for details on
how to alter the behavior of existing backends.</p>
<span class="target" id="module-dogpile.cache.api"></span><dl class="class">
<dt id="dogpile.cache.api.CacheBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.api.</code><code class="descname">CacheBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.api.CacheBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for backend implementations.</p>
<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.api.CacheBackend.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a value from the cache.</p>
<p>The key will be whatever was passed
to the registry, processed by the
&#8220;key mangling&#8221; function, if any.</p>
<p>The behavior here should be idempotent,
that is, can be called any number of times
regardless of whether or not the
key exists.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.delete_multi">
<code class="descname">delete_multi</code><span class="sig-paren">(</span><em>keys</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.api.CacheBackend.delete_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete multiple values from the cache.</p>
<p>The key will be whatever was passed
to the registry, processed by the
&#8220;key mangling&#8221; function, if any.</p>
<p>The behavior here should be idempotent,
that is, can be called any number of times
regardless of whether or not the
key exists.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.api.CacheBackend.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<p>The returned value should be an instance of
<a class="reference internal" href="#dogpile.cache.api.CachedValue" title="dogpile.cache.api.CachedValue"><code class="xref py py-class docutils literal"><span class="pre">CachedValue</span></code></a>, or <code class="docutils literal"><span class="pre">NO_VALUE</span></code> if
not present.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.get_multi">
<code class="descname">get_multi</code><span class="sig-paren">(</span><em>keys</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.api.CacheBackend.get_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve multiple values from the cache.</p>
<p>The returned value should be a list, corresponding
to the list of keys given.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.get_mutex">
<code class="descname">get_mutex</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.api.CacheBackend.get_mutex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an optional mutexing object for the given key.</p>
<p>This object need only provide an <code class="docutils literal"><span class="pre">acquire()</span></code>
and <code class="docutils literal"><span class="pre">release()</span></code> method.</p>
<p>May return <code class="docutils literal"><span class="pre">None</span></code>, in which case the dogpile
lock will use a regular <code class="docutils literal"><span class="pre">threading.Lock</span></code>
object to mutex concurrent threads for
value creation.   The default implementation
returns <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p>Different backends may want to provide various
kinds of &#8220;mutex&#8221; objects, such as those which
link to lock files, distributed mutexes,
memcached semaphores, etc.  Whatever
kind of system is best suited for the scope
and behavior of the caching backend.</p>
<p>A mutex that takes the key into account will
allow multiple regenerate operations across
keys to proceed simultaneously, while a mutex
that does not will serialize regenerate operations
to just one at a time across all keys in the region.
The latter approach, or a variant that involves
a modulus of the given key&#8217;s hash value,
can be used as a means of throttling the total
number of value recreation operations that may
proceed at one time.</p>
</dd></dl>

<dl class="attribute">
<dt id="dogpile.cache.api.CacheBackend.key_mangler">
<code class="descname">key_mangler</code><em class="property"> = None</em><a class="headerlink" href="#dogpile.cache.api.CacheBackend.key_mangler" title="Permalink to this definition">¶</a></dt>
<dd><p>Key mangling function.</p>
<p>May be None, or otherwise declared
as an ordinary instance method.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.api.CacheBackend.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a value in the cache.</p>
<p>The key will be whatever was passed
to the registry, processed by the
&#8220;key mangling&#8221; function, if any.
The value will always be an instance
of <a class="reference internal" href="#dogpile.cache.api.CachedValue" title="dogpile.cache.api.CachedValue"><code class="xref py py-class docutils literal"><span class="pre">CachedValue</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.set_multi">
<code class="descname">set_multi</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.api.CacheBackend.set_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Set multiple values in the cache.</p>
<p><code class="docutils literal"><span class="pre">mapping</span></code> is a dict in which
the key will be whatever was passed
to the registry, processed by the
&#8220;key mangling&#8221; function, if any.
The value will always be an instance
of <a class="reference internal" href="#dogpile.cache.api.CachedValue" title="dogpile.cache.api.CachedValue"><code class="xref py py-class docutils literal"><span class="pre">CachedValue</span></code></a>.</p>
<p>When implementing a new <a class="reference internal" href="#dogpile.cache.api.CacheBackend" title="dogpile.cache.api.CacheBackend"><code class="xref py py-class docutils literal"><span class="pre">CacheBackend</span></code></a> or cutomizing via
<a class="reference internal" href="#dogpile.cache.proxy.ProxyBackend" title="dogpile.cache.proxy.ProxyBackend"><code class="xref py py-class docutils literal"><span class="pre">ProxyBackend</span></code></a>, be aware that when this method is invoked by
<code class="xref py py-meth docutils literal"><span class="pre">Region.get_or_create_multi()</span></code>, the <code class="docutils literal"><span class="pre">mapping</span></code> values are the
same ones returned to the upstream caller. If the subclass alters the
values in any way, it must not do so &#8216;in-place&#8217; on the <code class="docutils literal"><span class="pre">mapping</span></code> dict
&#8211; that will have the undesirable effect of modifying the returned
values as well.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dogpile.cache.api.CachedValue">
<em class="property">class </em><code class="descclassname">dogpile.cache.api.</code><code class="descname">CachedValue</code><a class="headerlink" href="#dogpile.cache.api.CachedValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent a value stored in the cache.</p>
<p><a class="reference internal" href="#dogpile.cache.api.CachedValue" title="dogpile.cache.api.CachedValue"><code class="xref py py-class docutils literal"><span class="pre">CachedValue</span></code></a> is a two-tuple of
<code class="docutils literal"><span class="pre">(payload,</span> <span class="pre">metadata)</span></code>, where <code class="docutils literal"><span class="pre">metadata</span></code>
is dogpile.cache&#8217;s tracking information (
currently the creation time).  The metadata
and tuple structure is pickleable, if
the backend requires serialization.</p>
<dl class="attribute">
<dt id="dogpile.cache.api.CachedValue.metadata">
<code class="descname">metadata</code><a class="headerlink" href="#dogpile.cache.api.CachedValue.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Named accessor for the dogpile.cache metadata dictionary.</p>
</dd></dl>

<dl class="attribute">
<dt id="dogpile.cache.api.CachedValue.payload">
<code class="descname">payload</code><a class="headerlink" href="#dogpile.cache.api.CachedValue.payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Named accessor for the payload.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="dogpile.cache.api.NO_VALUE">
<code class="descclassname">dogpile.cache.api.</code><code class="descname">NO_VALUE</code><em class="property"> = &lt;dogpile.cache.api.NoValue object&gt;</em><a class="headerlink" href="#dogpile.cache.api.NO_VALUE" title="Permalink to this definition">¶</a></dt>
<dd><p>Value returned from <code class="docutils literal"><span class="pre">get()</span></code> that describes
a  key not present.</p>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.api.NoValue">
<em class="property">class </em><code class="descclassname">dogpile.cache.api.</code><code class="descname">NoValue</code><a class="headerlink" href="#dogpile.cache.api.NoValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Describe a missing cache value.</p>
<p>The <code class="xref py py-attr docutils literal"><span class="pre">NO_VALUE</span></code> module global
should be used.</p>
</dd></dl>

</div>
<div class="section" id="module-dogpile.cache.backends.memory">
<span id="backends"></span><h2>Backends<a class="headerlink" href="#module-dogpile.cache.backends.memory" title="Permalink to this headline">¶</a></h2>
<div class="section" id="memory-backends">
<h3>Memory Backends<a class="headerlink" href="#memory-backends" title="Permalink to this headline">¶</a></h3>
<p>Provides simple dictionary-based backends.</p>
<p>The two backends are <a class="reference internal" href="#dogpile.cache.backends.memory.MemoryBackend" title="dogpile.cache.backends.memory.MemoryBackend"><code class="xref py py-class docutils literal"><span class="pre">MemoryBackend</span></code></a> and <a class="reference internal" href="#dogpile.cache.backends.memory.MemoryPickleBackend" title="dogpile.cache.backends.memory.MemoryPickleBackend"><code class="xref py py-class docutils literal"><span class="pre">MemoryPickleBackend</span></code></a>;
the latter applies a serialization step to cached values while the former
places the value as given into the dictionary.</p>
<dl class="class">
<dt id="dogpile.cache.backends.memory.MemoryBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.memory.</code><code class="descname">MemoryBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.memory.MemoryBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A backend that uses a plain dictionary.</p>
<p>There is no size management, and values which
are placed into the dictionary will remain
until explicitly removed.   Note that
Dogpile&#8217;s expiration of items is based on
timestamps and does not remove them from
the cache.</p>
<p>E.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.memory&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To use a Python dictionary of your choosing,
it can be passed in with the <code class="docutils literal"><span class="pre">cache_dict</span></code>
argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">my_dictionary</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.memory&#39;</span><span class="p">,</span>
    <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;cache_dict&quot;</span><span class="p">:</span><span class="n">my_dictionary</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.memory.MemoryPickleBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.memory.</code><code class="descname">MemoryPickleBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.memory.MemoryPickleBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A backend that uses a plain dictionary, but serializes objects on
<code class="xref py py-meth docutils literal"><span class="pre">MemoryBackend.set()</span></code> and deserializes <code class="xref py py-meth docutils literal"><span class="pre">MemoryBackend.get()</span></code>.</p>
<p>E.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.memory_pickle&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The usage of pickle to serialize cached values allows an object
as placed in the cache to be a copy of the original given object, so
that any subsequent changes to the given object aren&#8217;t reflected
in the cached value, thus making the backend behave the same way
as other backends which make use of serialization.</p>
<p>The serialization is performed via pickle, and incurs the same
performance hit in doing so as that of other backends; in this way
the <a class="reference internal" href="#dogpile.cache.backends.memory.MemoryPickleBackend" title="dogpile.cache.backends.memory.MemoryPickleBackend"><code class="xref py py-class docutils literal"><span class="pre">MemoryPickleBackend</span></code></a> performance is somewhere in between
that of the pure <a class="reference internal" href="#dogpile.cache.backends.memory.MemoryBackend" title="dogpile.cache.backends.memory.MemoryBackend"><code class="xref py py-class docutils literal"><span class="pre">MemoryBackend</span></code></a> and the remote server oriented
backends such as that of Memcached or Redis.</p>
<p>Pickle behavior here is the same as that of the Redis backend, using
either <code class="docutils literal"><span class="pre">cPickle</span></code> or <code class="docutils literal"><span class="pre">pickle</span></code> and specifying <code class="docutils literal"><span class="pre">HIGHEST_PROTOCOL</span></code>
upon serialize.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.3.</span></p>
</div>
</dd></dl>

</div>
<span class="target" id="module-dogpile.cache.backends.memcached"></span><div class="section" id="memcached-backends">
<h3>Memcached Backends<a class="headerlink" href="#memcached-backends" title="Permalink to this headline">¶</a></h3>
<p>Provides backends for talking to <a class="reference external" href="http://memcached.org">memcached</a>.</p>
<dl class="class">
<dt id="dogpile.cache.backends.memcached.GenericMemcachedBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.memcached.</code><code class="descname">GenericMemcachedBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for memcached backends.</p>
<p>This base class accepts a number of paramters
common to all backends.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.backends.memcached.GenericMemcachedBackend.params.url"></span><strong>url</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend.params.url">¶</a> &#8211; the string URL to connect to.  Can be a single
string or a list of strings.  This is the only argument
that&#8217;s required.</li>
<li><span class="target" id="dogpile.cache.backends.memcached.GenericMemcachedBackend.params.distributed_lock"></span><strong>distributed_lock</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend.params.distributed_lock">¶</a> &#8211; boolean, when True, will use a
memcached-lock as the dogpile lock (see <a class="reference internal" href="#dogpile.cache.backends.memcached.MemcachedLock" title="dogpile.cache.backends.memcached.MemcachedLock"><code class="xref py py-class docutils literal"><span class="pre">MemcachedLock</span></code></a>).
Use this when multiple
processes will be talking to the same memcached instance.
When left at False, dogpile will coordinate on a regular
threading mutex.</li>
<li><span class="target" id="dogpile.cache.backends.memcached.GenericMemcachedBackend.params.lock_timeout"></span><strong>lock_timeout</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend.params.lock_timeout">¶</a> &#8211; <p>integer, number of seconds after acquiring a lock that
memcached should expire it.  This argument is only valid when
<code class="docutils literal"><span class="pre">distributed_lock</span></code> is <code class="docutils literal"><span class="pre">True</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.7.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.backends.memcached.GenericMemcachedBackend.params.memcached_expire_time"></span><strong>memcached_expire_time</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend.params.memcached_expire_time">¶</a> &#8211; <p>integer, when present will
be passed as the <code class="docutils literal"><span class="pre">time</span></code> parameter to <code class="docutils literal"><span class="pre">pylibmc.Client.set</span></code>.
This is used to set the memcached expiry time for a value.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This parameter is <strong>different</strong> from Dogpile&#8217;s own
<code class="docutils literal"><span class="pre">expiration_time</span></code>, which is the number of seconds after
which Dogpile will consider the value to be expired.
When Dogpile considers a value to be expired,
it <strong>continues to use the value</strong> until generation
of a new value is complete, when using
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></code></a>.
Therefore, if you are setting <code class="docutils literal"><span class="pre">memcached_expire_time</span></code>, you&#8217;ll
want to make sure it is greater than <code class="docutils literal"><span class="pre">expiration_time</span></code>
by at least enough seconds for new values to be generated,
else the value won&#8217;t be available during a regeneration,
forcing all threads to wait for a regeneration each time
a value expires.</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The <code class="xref py py-class docutils literal"><span class="pre">GenericMemachedBackend</span></code> uses a <code class="docutils literal"><span class="pre">threading.local()</span></code>
object to store individual client objects per thread,
as most modern memcached clients do not appear to be inherently
threadsafe.</p>
<p>In particular, <code class="docutils literal"><span class="pre">threading.local()</span></code> has the advantage over pylibmc&#8217;s
built-in thread pool in that it automatically discards objects
associated with a particular thread when that thread ends.</p>
<dl class="attribute">
<dt id="dogpile.cache.backends.memcached.GenericMemcachedBackend.client">
<code class="descname">client</code><a class="headerlink" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend.client" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memcached client.</p>
<p>This uses a threading.local by
default as it appears most modern
memcached libs aren&#8217;t inherently
threadsafe.</p>
</dd></dl>

<dl class="attribute">
<dt id="dogpile.cache.backends.memcached.GenericMemcachedBackend.set_arguments">
<code class="descname">set_arguments</code><em class="property"> = {}</em><a class="headerlink" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend.set_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional arguments which will be passed
to the <code class="xref py py-meth docutils literal"><span class="pre">set()</span></code> method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.memcached.MemcachedBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.memcached.</code><code class="descname">MemcachedBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.memcached.MemcachedBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A backend using the standard
<a class="reference external" href="http://www.tummy.com/Community/software/python-memcached/">Python-memcached</a>
library.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.memcached&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;url&#39;</span><span class="p">:</span><span class="s2">&quot;127.0.0.1:11211&quot;</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.memcached.PylibmcBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.memcached.</code><code class="descname">PylibmcBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.memcached.PylibmcBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A backend for the
<a class="reference external" href="http://sendapatch.se/projects/pylibmc/index.html">pylibmc</a>
memcached client.</p>
<p>A configuration illustrating several of the optional
arguments described in the pylibmc documentation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.pylibmc&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;url&#39;</span><span class="p">:[</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">],</span>
        <span class="s1">&#39;binary&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
        <span class="s1">&#39;behaviors&#39;</span><span class="p">:{</span><span class="s2">&quot;tcp_nodelay&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span><span class="s2">&quot;ketama&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Arguments accepted here include those of
<a class="reference internal" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend" title="dogpile.cache.backends.memcached.GenericMemcachedBackend"><code class="xref py py-class docutils literal"><span class="pre">GenericMemcachedBackend</span></code></a>, as well as
those below.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.backends.memcached.PylibmcBackend.params.binary"></span><strong>binary</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.memcached.PylibmcBackend.params.binary">¶</a> &#8211; sets the <code class="docutils literal"><span class="pre">binary</span></code> flag understood by
<code class="docutils literal"><span class="pre">pylibmc.Client</span></code>.</li>
<li><span class="target" id="dogpile.cache.backends.memcached.PylibmcBackend.params.behaviors"></span><strong>behaviors</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.memcached.PylibmcBackend.params.behaviors">¶</a> &#8211; a dictionary which will be passed to
<code class="docutils literal"><span class="pre">pylibmc.Client</span></code> as the <code class="docutils literal"><span class="pre">behaviors</span></code> parameter.</li>
<li><span class="target" id="dogpile.cache.backends.memcached.PylibmcBackend.params.min_compress_len"></span><strong>min_compress_len</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.memcached.PylibmcBackend.params.min_compress_len">¶</a> &#8211; Integer, will be passed as the
<code class="docutils literal"><span class="pre">min_compress_len</span></code> parameter to the <code class="docutils literal"><span class="pre">pylibmc.Client.set</span></code>
method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.memcached.BMemcachedBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.memcached.</code><code class="descname">BMemcachedBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.memcached.BMemcachedBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A backend for the
<a class="reference external" href="https://github.com/jaysonsantos/python-binary-memcached">python-binary-memcached</a>
memcached client.</p>
<p>This is a pure Python memcached client which
includes the ability to authenticate with a memcached
server using SASL.</p>
<p>A typical configuration using username/password:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.bmemcached&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;url&#39;</span><span class="p">:[</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">],</span>
        <span class="s1">&#39;username&#39;</span><span class="p">:</span><span class="s1">&#39;scott&#39;</span><span class="p">,</span>
        <span class="s1">&#39;password&#39;</span><span class="p">:</span><span class="s1">&#39;tiger&#39;</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Arguments which can be passed to the <code class="docutils literal"><span class="pre">arguments</span></code>
dictionary include:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.backends.memcached.BMemcachedBackend.params.username"></span><strong>username</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.memcached.BMemcachedBackend.params.username">¶</a> &#8211; optional username, will be used for
SASL authentication.</li>
<li><span class="target" id="dogpile.cache.backends.memcached.BMemcachedBackend.params.password"></span><strong>password</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.memcached.BMemcachedBackend.params.password">¶</a> &#8211; optional password, will be used for
SASL authentication.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dogpile.cache.backends.memcached.BMemcachedBackend.delete_multi">
<code class="descname">delete_multi</code><span class="sig-paren">(</span><em>keys</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.memcached.BMemcachedBackend.delete_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>python-binary-memcached api does not implements delete_multi</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.memcached.MemcachedLock">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.memcached.</code><code class="descname">MemcachedLock</code><span class="sig-paren">(</span><em>client_fn</em>, <em>key</em>, <em>timeout=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.memcached.MemcachedLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple distributed lock using memcached.</p>
<p>This is an adaptation of the lock featured at
<a class="reference external" href="http://amix.dk/blog/post/19386">http://amix.dk/blog/post/19386</a></p>
</dd></dl>

</div>
<span class="target" id="module-dogpile.cache.backends.redis"></span><div class="section" id="redis-backends">
<h3>Redis Backends<a class="headerlink" href="#redis-backends" title="Permalink to this headline">¶</a></h3>
<p>Provides backends for talking to <a class="reference external" href="http://redis.io">Redis</a>.</p>
<dl class="class">
<dt id="dogpile.cache.backends.redis.RedisBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.redis.</code><code class="descname">RedisBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.redis.RedisBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://redis.io/">Redis</a> backend, using the
<a class="reference external" href="http://pypi.python.org/pypi/redis/">redis-py</a> backend.</p>
<p>Example configuration:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.redis&#39;</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="s1">&#39;localhost&#39;</span><span class="p">,</span>
        <span class="s1">&#39;port&#39;</span><span class="p">:</span> <span class="mi">6379</span><span class="p">,</span>
        <span class="s1">&#39;db&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;redis_expiration_time&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>   <span class="c1"># 2 hours</span>
        <span class="s1">&#39;distributed_lock&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Arguments accepted in the arguments dictionary:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.url"></span><strong>url</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.url">¶</a> &#8211; <p>string. If provided, will override separate host/port/db
params.  The format is that accepted by <code class="docutils literal"><span class="pre">StrictRedis.from_url()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.4.1.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.host"></span><strong>host</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.host">¶</a> &#8211; string, default is <code class="docutils literal"><span class="pre">localhost</span></code>.</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.password"></span><strong>password</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.password">¶</a> &#8211; <p>string, default is no password.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.4.1.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.port"></span><strong>port</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.port">¶</a> &#8211; integer, default is <code class="docutils literal"><span class="pre">6379</span></code>.</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.db"></span><strong>db</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.db">¶</a> &#8211; integer, default is <code class="docutils literal"><span class="pre">0</span></code>.</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.redis_expiration_time"></span><strong>redis_expiration_time</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.redis_expiration_time">¶</a> &#8211; integer, number of seconds after setting
a value that Redis should expire it.  This should be larger than dogpile&#8217;s
cache expiration.  By default no expiration is set.</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.distributed_lock"></span><strong>distributed_lock</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.distributed_lock">¶</a> &#8211; boolean, when True, will use a
redis-lock as the dogpile lock.
Use this when multiple
processes will be talking to the same redis instance.
When left at False, dogpile will coordinate on a regular
threading mutex.</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.lock_timeout"></span><strong>lock_timeout</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.lock_timeout">¶</a> &#8211; <p>integer, number of seconds after acquiring a lock that
Redis should expire it.  This argument is only valid when
<code class="docutils literal"><span class="pre">distributed_lock</span></code> is <code class="docutils literal"><span class="pre">True</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.socket_timeout"></span><strong>socket_timeout</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.socket_timeout">¶</a> &#8211; <p>float, seconds for socket timeout.
Default is None (no timeout).</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.4.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.lock_sleep"></span><strong>lock_sleep</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.lock_sleep">¶</a> &#8211; <p>integer, number of seconds to sleep when failed to
acquire a lock.  This argument is only valid when
<code class="docutils literal"><span class="pre">distributed_lock</span></code> is <code class="docutils literal"><span class="pre">True</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
</li>
<li><span class="target" id="dogpile.cache.backends.redis.RedisBackend.params.connection_pool"></span><strong>connection_pool</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.redis.RedisBackend.params.connection_pool">¶</a> &#8211; <p><code class="docutils literal"><span class="pre">redis.ConnectionPool</span></code> object.  If provided,
this object supersedes other connection arguments passed to the
<code class="docutils literal"><span class="pre">redis.StrictRedis</span></code> instance, including url and/or host as well as
socket_timeout, and will be passed to <code class="docutils literal"><span class="pre">redis.StrictRedis</span></code> as the
source of connectivity.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.4.</span></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<span class="target" id="module-dogpile.cache.backends.file"></span><div class="section" id="file-backends">
<h3>File Backends<a class="headerlink" href="#file-backends" title="Permalink to this headline">¶</a></h3>
<p>Provides backends that deal with local filesystem access.</p>
<dl class="class">
<dt id="dogpile.cache.backends.file.DBMBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.file.</code><code class="descname">DBMBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.DBMBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A file-backend using a dbm file to store keys.</p>
<p>Basic usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.dbm&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;filename&quot;</span><span class="p">:</span><span class="s2">&quot;/path/to/cachefile.dbm&quot;</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>DBM access is provided using the Python <code class="docutils literal"><span class="pre">anydbm</span></code> module,
which selects a platform-specific dbm module to use.
This may be made to be more configurable in a future
release.</p>
<p>Note that different dbm modules have different behaviors.
Some dbm implementations handle their own locking, while
others don&#8217;t.  The <a class="reference internal" href="#dogpile.cache.backends.file.DBMBackend" title="dogpile.cache.backends.file.DBMBackend"><code class="xref py py-class docutils literal"><span class="pre">DBMBackend</span></code></a> uses a read/write
lockfile by default, which is compatible even with those
DBM implementations for which this is unnecessary,
though the behavior can be disabled.</p>
<p>The DBM backend by default makes use of two lockfiles.
One is in order to protect the DBM file itself from
concurrent writes, the other is to coordinate
value creation (i.e. the dogpile lock).  By default,
these lockfiles use the <code class="docutils literal"><span class="pre">flock()</span></code> system call
for locking; this is <strong>only available on Unix
platforms</strong>.   An alternative lock implementation, such as one
which is based on threads or uses a third-party system
such as <a class="reference external" href="https://pypi.python.org/pypi/portalocker">portalocker</a>,
can be dropped in using the <code class="docutils literal"><span class="pre">lock_factory</span></code> argument
in conjunction with the <a class="reference internal" href="#dogpile.cache.backends.file.AbstractFileLock" title="dogpile.cache.backends.file.AbstractFileLock"><code class="xref py py-class docutils literal"><span class="pre">AbstractFileLock</span></code></a> base class.</p>
<p>Currently, the dogpile lock is against the entire
DBM file, not per key.   This means there can
only be one &#8220;creator&#8221; job running at a time
per dbm file.</p>
<p>A future improvement might be to have the dogpile lock
using a filename that&#8217;s based on a modulus of the key.
Locking on a filename that uniquely corresponds to the
key is problematic, since it&#8217;s not generally safe to
delete lockfiles as the application runs, implying an
unlimited number of key-based files would need to be
created and never deleted.</p>
<p>Parameters to the <code class="docutils literal"><span class="pre">arguments</span></code> dictionary are
below.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.cache.backends.file.DBMBackend.params.filename"></span><strong>filename</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.file.DBMBackend.params.filename">¶</a> &#8211; path of the filename in which to
create the DBM file.  Note that some dbm backends
will change this name to have additional suffixes.</li>
<li><span class="target" id="dogpile.cache.backends.file.DBMBackend.params.rw_lockfile"></span><strong>rw_lockfile</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.file.DBMBackend.params.rw_lockfile">¶</a> &#8211; the name of the file to use for
read/write locking.  If omitted, a default name
is used by appending the suffix &#8221;.rw.lock&#8221; to the
DBM filename.  If False, then no lock is used.</li>
<li><span class="target" id="dogpile.cache.backends.file.DBMBackend.params.dogpile_lockfile"></span><strong>dogpile_lockfile</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.file.DBMBackend.params.dogpile_lockfile">¶</a> &#8211; the name of the file to use
for value creation, i.e. the dogpile lock.  If
omitted, a default name is used by appending the
suffix &#8221;.dogpile.lock&#8221; to the DBM filename. If
False, then dogpile.cache uses the default dogpile
lock, a plain thread-based mutex.</li>
<li><span class="target" id="dogpile.cache.backends.file.DBMBackend.params.lock_factory"></span><strong>lock_factory</strong><a class="paramlink headerlink reference internal" href="#dogpile.cache.backends.file.DBMBackend.params.lock_factory">¶</a> &#8211; <p>a function or class which provides
for a read/write lock.  Defaults to <a class="reference internal" href="#dogpile.cache.backends.file.FileLock" title="dogpile.cache.backends.file.FileLock"><code class="xref py py-class docutils literal"><span class="pre">FileLock</span></code></a>.
Custom implementations need to implement context-manager
based <code class="docutils literal"><span class="pre">read()</span></code> and <code class="docutils literal"><span class="pre">write()</span></code> functions - the
<a class="reference internal" href="#dogpile.cache.backends.file.AbstractFileLock" title="dogpile.cache.backends.file.AbstractFileLock"><code class="xref py py-class docutils literal"><span class="pre">AbstractFileLock</span></code></a> class is provided as a base class
which provides these methods based on individual read/write lock
functions.  E.g. to replace the lock with the dogpile.core
<a class="reference internal" href="#dogpile.util.ReadWriteMutex" title="dogpile.util.ReadWriteMutex"><code class="xref py py-class docutils literal"><span class="pre">ReadWriteMutex</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.core.readwrite_lock</span> <span class="k">import</span> <span class="n">ReadWriteMutex</span>
<span class="kn">from</span> <span class="nn">dogpile.cache.backends.file</span> <span class="k">import</span> <span class="n">AbstractFileLock</span>

<span class="k">class</span> <span class="nc">MutexLock</span><span class="p">(</span><span class="n">AbstractFileLock</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutex</span> <span class="o">=</span> <span class="n">ReadWriteMutex</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">acquire_read_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wait</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">acquire_read_lock</span><span class="p">(</span><span class="n">wait</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wait</span> <span class="ow">or</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">acquire_write_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wait</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">acquire_write_lock</span><span class="p">(</span><span class="n">wait</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wait</span> <span class="ow">or</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">release_read_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">release_read_lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">release_write_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutex</span><span class="o">.</span><span class="n">release_write_lock</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s2">&quot;dogpile.cache.dbm&quot;</span><span class="p">,</span>
    <span class="n">expiration_time</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;file.dbm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lock_factory&quot;</span><span class="p">:</span> <span class="n">MutexLock</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>While the included <a class="reference internal" href="#dogpile.cache.backends.file.FileLock" title="dogpile.cache.backends.file.FileLock"><code class="xref py py-class docutils literal"><span class="pre">FileLock</span></code></a> uses <code class="docutils literal"><span class="pre">os.flock()</span></code>, a
windows-compatible implementation can be built using a library
such as <a class="reference external" href="https://pypi.python.org/pypi/portalocker">portalocker</a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.2.</span></p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.file.FileLock">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.file.</code><code class="descname">FileLock</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.FileLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Use lockfiles to coordinate read/write access to a file.</p>
<p>Only works on Unix systems, using
<a class="reference external" href="http://docs.python.org/library/fcntl.html">fcntl.flock()</a>.</p>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.file.AbstractFileLock">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.file.</code><code class="descname">AbstractFileLock</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordinate read/write access to a file.</p>
<p>typically is a file-based lock but doesn&#8217;t necessarily have to be.</p>
<p>The default implementation here is <a class="reference internal" href="#dogpile.cache.backends.file.FileLock" title="dogpile.cache.backends.file.FileLock"><code class="xref py py-class docutils literal"><span class="pre">FileLock</span></code></a>.</p>
<p>Implementations should provide the following methods:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="fm">__init__</span><span class="p">()</span>
<span class="o">*</span> <span class="n">acquire_read_lock</span><span class="p">()</span>
<span class="o">*</span> <span class="n">acquire_write_lock</span><span class="p">()</span>
<span class="o">*</span> <span class="n">release_read_lock</span><span class="p">()</span>
<span class="o">*</span> <span class="n">release_write_lock</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">__init__()</span></code> method accepts a single argument &#8220;filename&#8221;, which
may be used as the &#8220;lock file&#8221;, for those implementations that use a lock
file.</p>
<p>Note that multithreaded environments must provide a thread-safe
version of this lock.  The recommended approach for file-
descriptor-based locks is to use a Python <code class="docutils literal"><span class="pre">threading.local()</span></code> so
that a unique file descriptor is held per thread.  See the source
code of <a class="reference internal" href="#dogpile.cache.backends.file.FileLock" title="dogpile.cache.backends.file.FileLock"><code class="xref py py-class docutils literal"><span class="pre">FileLock</span></code></a> for an implementation example.</p>
<dl class="method">
<dt id="dogpile.cache.backends.file.AbstractFileLock.acquire">
<code class="descname">acquire</code><span class="sig-paren">(</span><em>wait=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the &#8220;write&#8221; lock.</p>
<p>This is a direct call to <a class="reference internal" href="#dogpile.cache.backends.file.AbstractFileLock.acquire_write_lock" title="dogpile.cache.backends.file.AbstractFileLock.acquire_write_lock"><code class="xref py py-meth docutils literal"><span class="pre">AbstractFileLock.acquire_write_lock()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.backends.file.AbstractFileLock.acquire_read_lock">
<code class="descname">acquire_read_lock</code><span class="sig-paren">(</span><em>wait</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock.acquire_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a &#8216;reader&#8217; lock.</p>
<p>Raises <code class="docutils literal"><span class="pre">NotImplementedError</span></code> by default, must be
implemented by subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.backends.file.AbstractFileLock.acquire_write_lock">
<code class="descname">acquire_write_lock</code><span class="sig-paren">(</span><em>wait</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock.acquire_write_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a &#8216;write&#8217; lock.</p>
<p>Raises <code class="docutils literal"><span class="pre">NotImplementedError</span></code> by default, must be
implemented by subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="dogpile.cache.backends.file.AbstractFileLock.is_open">
<code class="descname">is_open</code><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock.is_open" title="Permalink to this definition">¶</a></dt>
<dd><p>optional method.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.backends.file.AbstractFileLock.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a context manager for the &#8220;read&#8221; lock.</p>
<p>This method makes use of <a class="reference internal" href="#dogpile.cache.backends.file.AbstractFileLock.acquire_read_lock" title="dogpile.cache.backends.file.AbstractFileLock.acquire_read_lock"><code class="xref py py-meth docutils literal"><span class="pre">AbstractFileLock.acquire_read_lock()</span></code></a>
and <a class="reference internal" href="#dogpile.cache.backends.file.AbstractFileLock.release_read_lock" title="dogpile.cache.backends.file.AbstractFileLock.release_read_lock"><code class="xref py py-meth docutils literal"><span class="pre">AbstractFileLock.release_read_lock()</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.backends.file.AbstractFileLock.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the &#8220;write&#8221; lock.</p>
<p>This is a direct call to <a class="reference internal" href="#dogpile.cache.backends.file.AbstractFileLock.release_write_lock" title="dogpile.cache.backends.file.AbstractFileLock.release_write_lock"><code class="xref py py-meth docutils literal"><span class="pre">AbstractFileLock.release_write_lock()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.backends.file.AbstractFileLock.release_read_lock">
<code class="descname">release_read_lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock.release_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a &#8216;reader&#8217; lock.</p>
<p>Raises <code class="docutils literal"><span class="pre">NotImplementedError</span></code> by default, must be
implemented by subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.backends.file.AbstractFileLock.release_write_lock">
<code class="descname">release_write_lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock.release_write_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a &#8216;writer&#8217; lock.</p>
<p>Raises <code class="docutils literal"><span class="pre">NotImplementedError</span></code> by default, must be
implemented by subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.backends.file.AbstractFileLock.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.file.AbstractFileLock.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a context manager for the &#8220;write&#8221; lock.</p>
<p>This method makes use of <a class="reference internal" href="#dogpile.cache.backends.file.AbstractFileLock.acquire_write_lock" title="dogpile.cache.backends.file.AbstractFileLock.acquire_write_lock"><code class="xref py py-meth docutils literal"><span class="pre">AbstractFileLock.acquire_write_lock()</span></code></a>
and <a class="reference internal" href="#dogpile.cache.backends.file.AbstractFileLock.release_write_lock" title="dogpile.cache.backends.file.AbstractFileLock.release_write_lock"><code class="xref py py-meth docutils literal"><span class="pre">AbstractFileLock.release_write_lock()</span></code></a></p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-dogpile.cache.proxy"></span><div class="section" id="proxy-backends">
<h3>Proxy Backends<a class="headerlink" href="#proxy-backends" title="Permalink to this headline">¶</a></h3>
<p>Provides a utility and a decorator class that allow for modifying the behavior
of different backends without altering the class itself or having to extend the
base backend.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0: </span>Added support for the <a class="reference internal" href="#dogpile.cache.proxy.ProxyBackend" title="dogpile.cache.proxy.ProxyBackend"><code class="xref py py-class docutils literal"><span class="pre">ProxyBackend</span></code></a> class.</p>
</div>
<dl class="class">
<dt id="dogpile.cache.proxy.ProxyBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.proxy.</code><code class="descname">ProxyBackend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.proxy.ProxyBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator class for altering the functionality of backends.</p>
<p>Basic usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>
<span class="kn">from</span> <span class="nn">dogpile.cache.proxy</span> <span class="k">import</span> <span class="n">ProxyBackend</span>

<span class="k">class</span> <span class="nc">MyFirstProxy</span><span class="p">(</span><span class="n">ProxyBackend</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># ... custom code goes here ...</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">proxied</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># ... custom code goes here ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proxied</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MySecondProxy</span><span class="p">(</span><span class="n">ProxyBackend</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># ... custom code goes here ...</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">proxied</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.dbm&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;filename&quot;</span><span class="p">:</span><span class="s2">&quot;/path/to/cachefile.dbm&quot;</span>
    <span class="p">},</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="p">[</span> <span class="n">MyFirstProxy</span><span class="p">,</span> <span class="n">MySecondProxy</span> <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Classes that extend <a class="reference internal" href="#dogpile.cache.proxy.ProxyBackend" title="dogpile.cache.proxy.ProxyBackend"><code class="xref py py-class docutils literal"><span class="pre">ProxyBackend</span></code></a> can be stacked
together.  The <code class="docutils literal"><span class="pre">.proxied</span></code> property will always
point to either the concrete backend instance or
the next proxy in the chain that a method can be
delegated towards.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.0.</span></p>
</div>
<dl class="method">
<dt id="dogpile.cache.proxy.ProxyBackend.wrap">
<code class="descname">wrap</code><span class="sig-paren">(</span><em>backend</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.proxy.ProxyBackend.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a backend as an argument and setup the self.proxied property.
Return an object that be used as a backend by a <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>
object.</p>
</dd></dl>

</dd></dl>

</div>
<span class="target" id="module-dogpile.cache.backends.null"></span><div class="section" id="null-backend">
<h3>Null Backend<a class="headerlink" href="#null-backend" title="Permalink to this headline">¶</a></h3>
<p>The Null backend does not do any caching at all.  It can be
used to test behavior without caching, or as a means of disabling
caching for a region that is otherwise used normally.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.5.4.</span></p>
</div>
<dl class="class">
<dt id="dogpile.cache.backends.null.NullBackend">
<em class="property">class </em><code class="descclassname">dogpile.cache.backends.null.</code><code class="descname">NullBackend</code><span class="sig-paren">(</span><em>arguments</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.backends.null.NullBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A &#8220;null&#8221; backend that effectively disables all cache operations.</p>
<p>Basic usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s1">&#39;dogpile.cache.null&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-dogpile.cache.exception">
<span id="exceptions"></span><h2>Exceptions<a class="headerlink" href="#module-dogpile.cache.exception" title="Permalink to this headline">¶</a></h2>
<p>Exception classes for dogpile.cache.</p>
<dl class="exception">
<dt id="dogpile.cache.exception.DogpileCacheException">
<em class="property">exception </em><code class="descclassname">dogpile.cache.exception.</code><code class="descname">DogpileCacheException</code><a class="headerlink" href="#dogpile.cache.exception.DogpileCacheException" title="Permalink to this definition">¶</a></dt>
<dd><p>Base Exception for dogpile.cache exceptions to inherit from.</p>
</dd></dl>

<dl class="exception">
<dt id="dogpile.cache.exception.PluginNotFound">
<em class="property">exception </em><code class="descclassname">dogpile.cache.exception.</code><code class="descname">PluginNotFound</code><a class="headerlink" href="#dogpile.cache.exception.PluginNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>The specified plugin could not be found.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.6.4.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="dogpile.cache.exception.RegionAlreadyConfigured">
<em class="property">exception </em><code class="descclassname">dogpile.cache.exception.</code><code class="descname">RegionAlreadyConfigured</code><a class="headerlink" href="#dogpile.cache.exception.RegionAlreadyConfigured" title="Permalink to this definition">¶</a></dt>
<dd><p>CacheRegion instance is already configured.</p>
</dd></dl>

<dl class="exception">
<dt id="dogpile.cache.exception.RegionNotConfigured">
<em class="property">exception </em><code class="descclassname">dogpile.cache.exception.</code><code class="descname">RegionNotConfigured</code><a class="headerlink" href="#dogpile.cache.exception.RegionNotConfigured" title="Permalink to this definition">¶</a></dt>
<dd><p>CacheRegion instance has not been configured.</p>
</dd></dl>

<dl class="exception">
<dt id="dogpile.cache.exception.ValidationError">
<em class="property">exception </em><code class="descclassname">dogpile.cache.exception.</code><code class="descname">ValidationError</code><a class="headerlink" href="#dogpile.cache.exception.ValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Error validating a value or option.</p>
</dd></dl>

</div>
<div class="section" id="module-dogpile.cache.plugins.mako_cache">
<span id="plugins"></span><h2>Plugins<a class="headerlink" href="#module-dogpile.cache.plugins.mako_cache" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mako-integration">
<h3>Mako Integration<a class="headerlink" href="#mako-integration" title="Permalink to this headline">¶</a></h3>
<p>dogpile.cache includes a <a class="reference external" href="http://www.makotemplates.org">Mako</a> plugin
that replaces <a class="reference external" href="http://beaker.groovie.org">Beaker</a>
as the cache backend.
Setup a Mako template lookup using the &#8220;dogpile.cache&#8221; cache implementation
and a region dictionary:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="k">import</span> <span class="n">make_region</span>
<span class="kn">from</span> <span class="nn">mako.lookup</span> <span class="k">import</span> <span class="n">TemplateLookup</span>

<span class="n">my_regions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;local&quot;</span><span class="p">:</span><span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="s2">&quot;dogpile.cache.dbm&quot;</span><span class="p">,</span>
                <span class="n">expiration_time</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span>
                <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;filename&quot;</span><span class="p">:</span><span class="s2">&quot;file.dbm&quot;</span><span class="p">}</span>
            <span class="p">),</span>
    <span class="s2">&quot;memcached&quot;</span><span class="p">:</span><span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="s2">&quot;dogpile.cache.pylibmc&quot;</span><span class="p">,</span>
                <span class="n">expiration_time</span><span class="o">=</span><span class="mi">3600</span><span class="p">,</span>
                <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;url&quot;</span><span class="p">:[</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">]}</span>
            <span class="p">)</span>
<span class="p">}</span>

<span class="n">mako_lookup</span> <span class="o">=</span> <span class="n">TemplateLookup</span><span class="p">(</span>
    <span class="n">directories</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;/myapp/templates&quot;</span><span class="p">],</span>
    <span class="n">cache_impl</span><span class="o">=</span><span class="s2">&quot;dogpile.cache&quot;</span><span class="p">,</span>
    <span class="n">cache_args</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;regions&#39;</span><span class="p">:</span><span class="n">my_regions</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To use the above configuration in a template, use the <code class="docutils literal"><span class="pre">cached=True</span></code>
argument  on any Mako tag which accepts it, in conjunction with the
name of the desired region as the <code class="docutils literal"><span class="pre">cache_region</span></code> argument:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;%</span><span class="k">def</span> <span class="nf">name</span><span class="o">=</span><span class="s2">&quot;mysection()&quot;</span> <span class="n">cached</span><span class="o">=</span><span class="s2">&quot;True&quot;</span> <span class="n">cache_region</span><span class="o">=</span><span class="s2">&quot;memcached&quot;</span><span class="o">&gt;</span>
    <span class="n">some</span> <span class="n">content</span> <span class="n">that</span><span class="s1">&#39;s cached</span>
<span class="o">&lt;/%</span><span class="n">def</span><span class="o">&gt;</span>
</pre></div>
</div>
<dl class="class">
<dt id="dogpile.cache.plugins.mako_cache.MakoPlugin">
<em class="property">class </em><code class="descclassname">dogpile.cache.plugins.mako_cache.</code><code class="descname">MakoPlugin</code><span class="sig-paren">(</span><em>cache</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.plugins.mako_cache.MakoPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>A Mako <code class="docutils literal"><span class="pre">CacheImpl</span></code> which talks to dogpile.cache.</p>
</dd></dl>

</div>
</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="dogpile.cache.util.function_key_generator">
<code class="descclassname">dogpile.cache.util.</code><code class="descname">function_key_generator</code><span class="sig-paren">(</span><em>namespace</em>, <em>fn</em>, <em>to_str=&lt;type 'str'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.util.function_key_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a function that generates a string
key, based on a given function as well as
arguments to the returned function itself.</p>
<p>This is used by <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><code class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></code></a>
to generate a cache key from a decorated function.</p>
<p>An alternate function may be used by specifying
the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.params.function_key_generator" title="dogpile.cache.region.CacheRegion"><code class="xref py py-paramref docutils literal"><span class="pre">CacheRegion.function_key_generator</span></code></a> argument
for <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><code class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dogpile.cache.util.kwarg_function_key_generator" title="dogpile.cache.util.kwarg_function_key_generator"><code class="xref py py-func docutils literal"><span class="pre">kwarg_function_key_generator()</span></code></a> - similar function that also
takes keyword arguments into account</p>
</div>
</dd></dl>

<dl class="function">
<dt id="dogpile.cache.util.kwarg_function_key_generator">
<code class="descclassname">dogpile.cache.util.</code><code class="descname">kwarg_function_key_generator</code><span class="sig-paren">(</span><em>namespace</em>, <em>fn</em>, <em>to_str=&lt;type 'str'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.util.kwarg_function_key_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a function that generates a string
key, based on a given function as well as
arguments to the returned function itself.</p>
<p>For kwargs passed in, we will build a dict of
all argname (key) argvalue (values) including
default args from the argspec and then
alphabetize the list before generating the
key.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.6.2.</span></p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#dogpile.cache.util.function_key_generator" title="dogpile.cache.util.function_key_generator"><code class="xref py py-func docutils literal"><span class="pre">function_key_generator()</span></code></a> - default key generation function</p>
</div>
</dd></dl>

<dl class="function">
<dt id="dogpile.cache.util.sha1_mangle_key">
<code class="descclassname">dogpile.cache.util.</code><code class="descname">sha1_mangle_key</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.util.sha1_mangle_key" title="Permalink to this definition">¶</a></dt>
<dd><p>a SHA1 key mangler.</p>
</dd></dl>

<dl class="function">
<dt id="dogpile.cache.util.length_conditional_mangler">
<code class="descclassname">dogpile.cache.util.</code><code class="descname">length_conditional_mangler</code><span class="sig-paren">(</span><em>length</em>, <em>mangler</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.cache.util.length_conditional_mangler" title="Permalink to this definition">¶</a></dt>
<dd><p>a key mangler that mangles if the length of the key is
past a certain threshold.</p>
</dd></dl>

</div>
<div class="section" id="dogpile-core">
<h2>dogpile Core<a class="headerlink" href="#dogpile-core" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dogpile.Lock">
<em class="property">class </em><code class="descclassname">dogpile.</code><code class="descname">Lock</code><span class="sig-paren">(</span><em>mutex</em>, <em>creator</em>, <em>value_and_created_fn</em>, <em>expiretime</em>, <em>async_creator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Dogpile lock class.</p>
<p>Provides an interface around an arbitrary mutex
that allows one thread/process to be elected as
the creator of a new value, while other threads/processes
continue to return the previous version
of that value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.Lock.params.mutex"></span><strong>mutex</strong><a class="paramlink headerlink reference internal" href="#dogpile.Lock.params.mutex">¶</a> &#8211; A mutex object that provides <code class="docutils literal"><span class="pre">acquire()</span></code>
and <code class="docutils literal"><span class="pre">release()</span></code> methods.</li>
<li><span class="target" id="dogpile.Lock.params.creator"></span><strong>creator</strong><a class="paramlink headerlink reference internal" href="#dogpile.Lock.params.creator">¶</a> &#8211; Callable which returns a tuple of the form
(new_value, creation_time).  &#8220;new_value&#8221; should be a newly
generated value representing completed state.  &#8220;creation_time&#8221;
should be a floating point time value which is relative
to Python&#8217;s <code class="docutils literal"><span class="pre">time.time()</span></code> call, representing the time
at which the value was created.  This time value should
be associated with the created value.</li>
<li><span class="target" id="dogpile.Lock.params.value_and_created_fn"></span><strong>value_and_created_fn</strong><a class="paramlink headerlink reference internal" href="#dogpile.Lock.params.value_and_created_fn">¶</a> &#8211; Callable which returns
a tuple of the form (existing_value, creation_time).  This
basically should return what the last local call to the <code class="docutils literal"><span class="pre">creator()</span></code>
callable has returned, i.e. the value and the creation time,
which would be assumed here to be from a cache.  If the
value is not available, the <a class="reference internal" href="#dogpile.NeedRegenerationException" title="dogpile.NeedRegenerationException"><code class="xref py py-class docutils literal"><span class="pre">NeedRegenerationException</span></code></a>
exception should be thrown.</li>
<li><span class="target" id="dogpile.Lock.params.expiretime"></span><strong>expiretime</strong><a class="paramlink headerlink reference internal" href="#dogpile.Lock.params.expiretime">¶</a> &#8211; Expiration time in seconds.  Set to
<code class="docutils literal"><span class="pre">None</span></code> for never expires.  This timestamp is compared
to the creation_time result and <code class="docutils literal"><span class="pre">time.time()</span></code> to determine if
the value returned by value_and_created_fn is &#8220;expired&#8221;.</li>
<li><span class="target" id="dogpile.Lock.params.async_creator"></span><strong>async_creator</strong><a class="paramlink headerlink reference internal" href="#dogpile.Lock.params.async_creator">¶</a> &#8211; A callable.  If specified, this callable will be
passed the mutex as an argument and is responsible for releasing the mutex
after it finishes some asynchronous value creation.  The intent is for
this to be used to defer invocation of the creator callable until some
later time.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="dogpile.NeedRegenerationException">
<em class="property">class </em><code class="descclassname">dogpile.</code><code class="descname">NeedRegenerationException</code><a class="headerlink" href="#dogpile.NeedRegenerationException" title="Permalink to this definition">¶</a></dt>
<dd><p>An exception that when raised in the &#8216;with&#8217; block,
forces the &#8216;has_value&#8217; flag to False and incurs a
regeneration of the value.</p>
</dd></dl>

<dl class="class">
<dt id="dogpile.util.ReadWriteMutex">
<em class="property">class </em><code class="descclassname">dogpile.util.</code><code class="descname">ReadWriteMutex</code><a class="headerlink" href="#dogpile.util.ReadWriteMutex" title="Permalink to this definition">¶</a></dt>
<dd><p>A mutex which allows multiple readers, single writer.</p>
<p><a class="reference internal" href="#dogpile.util.ReadWriteMutex" title="dogpile.util.ReadWriteMutex"><code class="xref py py-class docutils literal"><span class="pre">ReadWriteMutex</span></code></a> uses a Python <code class="docutils literal"><span class="pre">threading.Condition</span></code>
to provide this functionality across threads within a process.</p>
<p>The Beaker package also contained a file-lock based version
of this concept, so that readers/writers could be synchronized
across processes with a common filesystem.  A future Dogpile
release may include this additional class at some point.</p>
<dl class="method">
<dt id="dogpile.util.ReadWriteMutex.acquire_read_lock">
<code class="descname">acquire_read_lock</code><span class="sig-paren">(</span><em>wait=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.util.ReadWriteMutex.acquire_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the &#8216;read&#8217; lock.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.util.ReadWriteMutex.acquire_write_lock">
<code class="descname">acquire_write_lock</code><span class="sig-paren">(</span><em>wait=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.util.ReadWriteMutex.acquire_write_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the &#8216;write&#8217; lock.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.util.ReadWriteMutex.release_read_lock">
<code class="descname">release_read_lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.util.ReadWriteMutex.release_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the &#8216;read&#8217; lock.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.util.ReadWriteMutex.release_write_lock">
<code class="descname">release_write_lock</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.util.ReadWriteMutex.release_write_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the &#8216;write&#8217; lock.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dogpile.util.NameRegistry">
<em class="property">class </em><code class="descclassname">dogpile.util.</code><code class="descname">NameRegistry</code><span class="sig-paren">(</span><em>creator</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.util.NameRegistry" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates and return an object, keeping it as a
singleton for a certain identifier for as long as its
strongly referenced.</p>
<p>e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyFoo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s2">&quot;some important object.&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier</span>

<span class="n">registry</span> <span class="o">=</span> <span class="n">NameRegistry</span><span class="p">(</span><span class="n">MyFoo</span><span class="p">)</span>

<span class="c1"># thread 1:</span>
<span class="n">my_foo</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;foo1&quot;</span><span class="p">)</span>

<span class="c1"># thread 2</span>
<span class="n">my_foo</span> <span class="o">=</span> <span class="n">registry</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;foo1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Above, <code class="docutils literal"><span class="pre">my_foo</span></code> in both thread #1 and #2 will
be <em>the same object</em>.   The constructor for
<code class="docutils literal"><span class="pre">MyFoo</span></code> will be called once, passing the
identifier <code class="docutils literal"><span class="pre">foo1</span></code> as the argument.</p>
<p>When thread 1 and thread 2 both complete or
otherwise delete references to <code class="docutils literal"><span class="pre">my_foo</span></code>, the
object is <em>removed</em> from the <a class="reference internal" href="#dogpile.util.NameRegistry" title="dogpile.util.NameRegistry"><code class="xref py py-class docutils literal"><span class="pre">NameRegistry</span></code></a> as
a result of Python garbage collection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="dogpile.util.NameRegistry.params.creator"></span><strong>creator</strong><a class="paramlink headerlink reference internal" href="#dogpile.util.NameRegistry.params.creator">¶</a> &#8211; A function that will create a new
value, given the identifier passed to the <a class="reference internal" href="#dogpile.util.NameRegistry.get" title="dogpile.util.NameRegistry.get"><code class="xref py py-meth docutils literal"><span class="pre">NameRegistry.get()</span></code></a>
method.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dogpile.util.NameRegistry.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>identifier</em>, <em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#dogpile.util.NameRegistry.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get and possibly create the value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="dogpile.util.NameRegistry.get.params.identifier"></span><strong>identifier</strong><a class="paramlink headerlink reference internal" href="#dogpile.util.NameRegistry.get.params.identifier">¶</a> &#8211; Hash key for the value.
If the creation function is called, this identifier
will also be passed to the creation function.</li>
<li><span class="target" id="dogpile.util.NameRegistry.get.params.**kw"></span><strong>**kw</strong><a class="paramlink headerlink reference internal" href="#dogpile.util.NameRegistry.get.params.**kw">¶</a> (<em>*args</em><em>,</em><em></em>) &#8211; Additional arguments which will
also be passed to the creation function if it is
called.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API</a><ul>
<li><a class="reference internal" href="#module-dogpile.cache.region">Region</a></li>
<li><a class="reference internal" href="#backend-api">Backend API</a></li>
<li><a class="reference internal" href="#module-dogpile.cache.backends.memory">Backends</a><ul>
<li><a class="reference internal" href="#memory-backends">Memory Backends</a></li>
<li><a class="reference internal" href="#memcached-backends">Memcached Backends</a></li>
<li><a class="reference internal" href="#redis-backends">Redis Backends</a></li>
<li><a class="reference internal" href="#file-backends">File Backends</a></li>
<li><a class="reference internal" href="#proxy-backends">Proxy Backends</a></li>
<li><a class="reference internal" href="#null-backend">Null Backend</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-dogpile.cache.exception">Exceptions</a></li>
<li><a class="reference internal" href="#module-dogpile.cache.plugins.mako_cache">Plugins</a><ul>
<li><a class="reference internal" href="#mako-integration">Mako Integration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
<li><a class="reference internal" href="#dogpile-core">dogpile Core</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="core_usage.html"
                        title="previous chapter">dogpile Core</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="changelog.html"
                        title="next chapter">Changelog</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/api.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Changelog"
             >next</a> |</li>
        <li class="right" >
          <a href="core_usage.html" title="dogpile Core"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">dogpile.cache 0.6.4 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2017 Mike Bayer.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>