import argparse
import docker
import io
import json
import os
import requests
import shutil
import sys
import zipfile


##############################################################################################################
# constants
##############################################################################################################


PATH_PREFIX = '/collab'
INPUT_FILE_LOCATION = os.path.join(PATH_PREFIX, 'in.txt')
OUTPUT_FILE_LOCATION = os.path.join(PATH_PREFIX, 'out.txt')

_SOURCE_OF_TRUTH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'TRUTH.txt')
_CONFIG_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'config.txt')
_DOCKER_EXAMPLE_NAME = 'fibonacci'
_DOCKER_EXAMPLE_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), _DOCKER_EXAMPLE_NAME)
_truth = None
def _get_truth():
    """
    load constants from a file that is autogenerated from the outside when this module is compiled.
    This is a convenient way to share constants between different applications during development.
    Uses a cache.
    """
    global _truth
    if _truth is None:
        with open(_SOURCE_OF_TRUTH, 'r') as f:
            _truth = json.load(f)
    return _truth

def _get_server_url():
    """
    get a connection string that can be used to connect to the server
    """
    url = _get_truth()['server_url']
    return url

def _get_json_encoding_of_server():
    """
    get the type of encoding that the server uses for encoding JSON strings
    """
    url = _get_truth()['json_encoding']
    return url

def _get_docker_registry():
    """
    get the registry used to store Docker Images.
    """
    url = _get_truth()['docker_registry']
    return url


##############################################################################################################
# utilities
##############################################################################################################


def docker_connect():
    """
    connect to a Docker registry
    """
    client = docker.from_env()
    # TODO:
    # use _get_docker_registry() here
    #client = docker.DockerClient(base_url=_get_docker_registry())
    return client


##############################################################################################################
# main - initialize
##############################################################################################################


parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers()

def require_authentication(subparser):
    subparser.add_argument('-e', '--email', default=None,
        help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")
    subparser.add_argument('-p', '--password', default=None,
        help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")

def check_if_credentials_are_configured(args):
    """
    if the arguments contain an email and password, return them.
    If not, check if there is a configuration file and use it.
    """
    if args.email is not None and args.password is not None:
        return
    if (0 if args.email is None else 1) + (0 if args.password is None else 1) == 1:
        raise ValueError("either both or neither of email and password must be specified.")
    if os.path.isfile(_CONFIG_FILE):
        with open(_CONFIG_FILE, 'r') as f:
            config = json.load(f)
            args.email = config['email']
            args.password = config['password']
    else:
        raise ValueError("email and password must be specified. Either use a configuration file for this or provide them as arguments. See --help for details.")


##############################################################################################################
# main - functions
##############################################################################################################


def configure(args):
    if args.delete:
        if os.path.isfile(_CONFIG_FILE):
            os.remove(_CONFIG_FILE)
            return
        else:
            raise ValueError("no config file exists.")
    if args.email is not None and args.password is not None:
        with open(_CONFIG_FILE, 'w') as f:
            config = {
                'email' : args.email,
                'password' : args.password,
            }
            json.dump(config, f)
        print("successfully created configuration file.")
    else:
        raise ValueError("both an email and a password must be specified.")

subparser = subparsers.add_parser('configure',
    help="""creates a configuration file to store your login credentials, so you don't have to specify them every time.
    Be aware that anyone who steals this configuration file will be able to log in with your credentials unless you delete the file again.""")
subparser.add_argument('-e', '--email', default=None,
    help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")
subparser.add_argument('-p', '--password', default=None,
    help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")
subparser.add_argument('-d', '--delete', action='store_true',
    help="delete the configuration file.")
subparser.set_defaults(func=configure)


def generate_example_program(args):
    dst = os.path.join(args.folder, _DOCKER_EXAMPLE_NAME)
    if os.path.exists(args.folder):
        raise ValueError("the specified path already exists: %s" % dst)
    shutil.copytree(_DOCKER_EXAMPLE_PATH, dst)
    # manually delete the pycache that gets created for some reason...
    cache = os.path.join(dst, '__pycache__')
    if os.path.exists(cache):
        shutil.rmtree(cache)


subparser = subparsers.add_parser('generate-example-program', help="creates an example program, as a tutorial what the files of a program for Collab should look like.")
subparser.add_argument('-f', '--folder', required=True, help="the path to the folder in which the example program will be generated.")
subparser.set_defaults(func=generate_example_program)


def upload_program(args):
    check_if_credentials_are_configured(args)
    folder = args.folder
    image_name = args.name
    program_description = args.program_description
    docker_user_name = "example_user" # TODO: use a real user name here
    full_image_name = "%s/%s" % (docker_user_name, image_name,)
    full_image_name_with_registry = "%s/%s/%s" % (_get_docker_registry(), docker_user_name, image_name,)
    print(full_image_name)
    #
    # build the Docker image
    #
    # find out how many versions of the Image already exist, if any
    print("compiling Docker Image...")
    client = docker_connect()
    image = client.images.build(path=folder)
    #
    # if required, upload the source code as well
    #
    include_source = args.include_source
    files = {}
    if include_source:
        def zipdir(path, zip_handle):
            for root, dirs, files in os.walk(path):
                for file in files:
                    zip_handle.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(path, '..')))
        virtual_file = io.BytesIO()
        zip_handle = zipfile.ZipFile(virtual_file, 'w', zipfile.ZIP_DEFLATED)
        zipdir(folder, zip_handle)
        zip_handle.close()
        files['source_files_archive'] = virtual_file.getvalue()
    #
    # notify the Collab server
    # (and optionally upload the files)
    #
    print("contacting Collab server...")
    data = {
        'email' : args.email,
        'password' : args.password,
        'full_image_name_with_registry' : full_image_name_with_registry,
        'docker_user_name' : docker_user_name,
        'program_name' : image_name,
        'program_description' : program_description,
    }
    url = _get_server_url() + '/api/upload_program/'
    resp = requests.post(url, data=data, files=files)
    resp = json.loads(resp._content.decode(_get_json_encoding_of_server()))
    version = resp['version']
    #
    # print the response received from the server
    #
    response_text = resp['response_text']
    print(response_text)
    #
    # Tag the Image with the right version number and push it to the registry server
    #
    # tag the image
    print("tagging and uploading Docker Image...")
    tag = "version-%d" % (version,)
    full_identifier = '%s:%s' % (full_image_name_with_registry, tag)
    # (tagging with this API apparently works by just building the Image again and relying on the cache to avoid actually rebuilding it)
    image = client.images.build(path=folder, tag=full_identifier)
    # push to the registry
    for line in client.images.push(full_image_name_with_registry, tag=tag, stream=True):
        msgs = [json.loads(a) for a in line.decode('utf-8').split('\n') if a != ""]
        for msg in msgs:
            if 'error' in msg:
                raise Exception(msg['error'])
            elif 'status' in msg:
                print("\t%s" % (msg['status'],))
    print("done. Uploaded image:\n%s" % (full_identifier,))

subparser = subparsers.add_parser('upload-program',
    help="""upload a program to the server, making it available for use by execution rules.
    Can be used for creating new programs, or updating existing ones.""")
subparser.add_argument('-f', '--folder', required=True,
    help="the path to the folder that should be uploaded. This should target the directory in which the Dockerfile is located.")
subparser.add_argument('-n', '--name', required=True,
    help="the name of the program. If an existing name is given, a new version of it will be created. Otherwise, a new program is created.")
subparser.add_argument('-d', '--description', default="no description given",
    help="a short description of the program.")
subparser.add_argument('-s', '--include-source', default=True,
    help="whether or not to also upload the source files to the Collab server, to make them available for inspection.")
require_authentication(subparser)
subparser.set_defaults(func=upload_program)


##############################################################################################################
# main - finalize
##############################################################################################################


def main():
    if len(sys.argv)==1:
        # if the program is called without arguments, print the help menu and exit
        parser.print_help()
        sys.exit(1)
    else:
        args = parser.parse_args()
        args.func(args)

if __name__ == '__main__':
    main()


