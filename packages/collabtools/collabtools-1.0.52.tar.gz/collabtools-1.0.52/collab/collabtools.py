import argparse
import docker
import io
import json
import os
import requests
import shutil
import sys
import zipfile


##############################################################################################################
# constants
##############################################################################################################


PATH_PREFIX = '/collab'
INPUT_FILE_LOCATION = os.path.join(PATH_PREFIX, 'in.txt')
OUTPUT_FILE_LOCATION = os.path.join(PATH_PREFIX, 'out.txt')

_SOURCE_OF_TRUTH = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'TRUTH.txt')
_CONFIG_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'config.txt')
_DOCKER_EXAMPLE_NAME = 'fibonacci'
_DOCKER_EXAMPLE_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), _DOCKER_EXAMPLE_NAME)
_truth = None
def _get_truth():
    """
    load constants from a file that is autogenerated from the outside when this module is compiled.
    This is a convenient way to share constants between different applications during development.
    Uses a cache.
    """
    global _truth
    if _truth is None:
        with open(_SOURCE_OF_TRUTH, 'r') as f:
            _truth = json.load(f)
    return _truth

def _get_server_url():
    """
    get a connection string that can be used to connect to the server
    """
    url = _get_truth()['server_url']
    return url

def _get_json_encoding_of_server():
    """
    get the type of encoding that the server uses for encoding JSON strings
    """
    url = _get_truth()['json_encoding']
    return url


##############################################################################################################
# utilities
##############################################################################################################



##############################################################################################################
# main - initialize
##############################################################################################################


parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers()

def require_authentication(subparser):
    subparser.add_argument('-e', '--email', default=None,
        help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")
    subparser.add_argument('-p', '--password', default=None,
        help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")

def check_if_credentials_are_configured(args):
    """
    if the arguments contain an email and password, return them.
    If not, check if there is a configuration file and use it.
    """
    if args.email is not None and args.password is not None:
        return
    if (0 if args.email is None else 1) + (0 if args.password is None else 1) == 1:
        raise ValueError("either both or neither of email and password must be specified.")
    if os.path.isfile(_CONFIG_FILE):
        with open(_CONFIG_FILE, 'r') as f:
            config = json.load(f)
            args.email = config['email']
            args.password = config['password']
    else:
        raise ValueError("email and password must be specified. Either use a configuration file for this or provide them as arguments. See --help for details.")


##############################################################################################################
# main - functions
##############################################################################################################


def configure(args):
    if args.delete:
        if os.path.isfile(_CONFIG_FILE):
            os.remove(_CONFIG_FILE)
            return
        else:
            raise ValueError("no config file exists.")
    if args.email is not None and args.password is not None:
        with open(_CONFIG_FILE, 'w') as f:
            config = {
                'email' : args.email,
                'password' : args.password,
            }
            json.dump(config, f)
        print("successfully created configuration file.")
    else:
        raise ValueError("both an email and a password must be specified.")

subparser = subparsers.add_parser('configure',
    help="""creates a configuration file to store your login credentials, so you don't have to specify them every time.
    Be aware that anyone who steals this configuration file will be able to log in with your credentials unless you delete the file again.""")
subparser.add_argument('-e', '--email', default=None,
    help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")
subparser.add_argument('-p', '--password', default=None,
    help="the password of your Collab account. This can be skipped if you have already used the 'configure' command.")
subparser.add_argument('-d', '--delete', action='store_true',
    help="delete the configuration file.")
subparser.set_defaults(func=configure)


def generate_example_program(args):
    dst = os.path.join(args.folder, _DOCKER_EXAMPLE_NAME)
    if os.path.exists(args.folder):
        raise ValueError("the specified path already exists: %s" % dst)
    shutil.copytree(_DOCKER_EXAMPLE_PATH, dst)
    # manually delete the pycache that gets created for some reason...
    cache = os.path.join(dst, '__pycache__')
    if os.path.exists(cache):
        shutil.rmtree(cache)


subparser = subparsers.add_parser('generate-example-program', help="creates an example program, as a tutorial what the files of a program for Collab should look like.")
subparser.add_argument('-f', '--folder', required=True, help="the path to the folder in which the example program will be generated.")
subparser.set_defaults(func=generate_example_program)


def upload_program(args):
    check_if_credentials_are_configured(args)
    url = _get_server_url() + '/api/upload_program/'
    folder = args.folder
    print(folder)
    #
    # upload the folder with Docker
    #
    # get the current version of the image, if it already exists
    print("compiling Docker image...")
    print("uploading Docker image...")
    version = 0
    #
    # if required, upload the source code as well
    #
    include_source = args.include_source
    files = {}
    if include_source:
        def zipdir(path, zip_handle):
            for root, dirs, files in os.walk(path):
                for file in files:
                    zip_handle.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(path, '..')))
        virtual_file = io.BytesIO()
        zip_handle = zipfile.ZipFile(virtual_file, 'w', zipfile.ZIP_DEFLATED)
        zipdir(folder, zip_handle)
        zip_handle.close()
        files['source_files_archive'] = virtual_file.getvalue()
        # TODO: how to upload a zip file without first creating the file and saving it somewhere?
        #zip_file.extractall(test)
    #
    # notify the Collab server
    # (and optionally upload the file)
    #
    data = {
        'email' : args.email,
        'password' : args.password,
    }
    resp = requests.post(url, data=data, files=files)
    resp = json.loads(resp._content.decode(_get_json_encoding_of_server()))
    #
    # print the response received from the server
    #
    response_text = resp['response_text']
    print(response_text)

subparser = subparsers.add_parser('upload-program',
    help="""upload a program to the server, making it available for use by execution rules.
    Can be used for creating new programs, or updating existing ones.""")
subparser.add_argument('-f', '--folder', required=True,
    help="the path to the folder that should be uploaded. This should target the directory in which the Dockerfile is located.")
subparser.add_argument('-n', '--name', default=True,
    help="the name of the program. If an existing name is given, a new version of it will be created. Otherwise, a new program is created.")
subparser.add_argument('-s', '--include-source', default=True,
    help="whether or not to also upload the source files to the Collab server, to make them available for inspection.")
require_authentication(subparser)
subparser.set_defaults(func=upload_program)


##############################################################################################################
# main - finalize
##############################################################################################################


def main():
    if len(sys.argv)==1:
        # if the program is called without arguments, print the help menu and exit
        parser.print_help()
        sys.exit(1)
    else:
        args = parser.parse_args()
        args.func(args)

if __name__ == '__main__':
    main()


