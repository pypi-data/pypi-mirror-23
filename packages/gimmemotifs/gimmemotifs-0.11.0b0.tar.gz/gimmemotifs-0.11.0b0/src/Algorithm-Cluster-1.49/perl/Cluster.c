/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.28 from the
 * contents of Cluster.xs. Do not edit this file, edit Cluster.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Cluster.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* The Perl include files perl.h redefines malloc and free. Here, we need the
 * usual malloc and free, defined in stdlib.h. So we undefine the ones in
 * perl.h.
 */

#ifdef malloc
#undef malloc
#endif
#ifdef free
#undef free
#endif

#include <stdlib.h>

#include "../src/cluster.h"


typedef struct {Node* nodes; int n;} Tree;

/* -------------------------------------------------
 * Using the warnings registry, check to see if warnings
 * are enabled for the Algorithm::Cluster module.
 */
static int
warnings_enabled(pTHX) {

    dSP;

    I32 count;
    bool isEnabled; 
    SV * mysv;

    ENTER ;
    SAVETMPS;
    PUSHMARK(SP) ;
    XPUSHs(sv_2mortal(newSVpv("Algorithm::Cluster",18)));
    PUTBACK ;

    count = perl_call_pv("warnings::enabled", G_SCALAR) ;

    if (count != 1) croak("No arguments returned from call_pv()\n") ;

    mysv = POPs; 
    isEnabled = (bool) SvTRUE(mysv); 

    PUTBACK ;
    FREETMPS ;
    LEAVE ;

    return isEnabled;
}

/* -------------------------------------------------
 * Create a row of doubles, initialized to a value
 */
static double*
malloc_row_dbl(pTHX_ int ncols, double val) {

    int j;
    double * row;

    row = malloc(ncols * sizeof(double) );
    if (!row) {
        return NULL;
    }

    for (j = 0; j < ncols; j++) { 
        row[j] = val;
    }
    return row;
}

/* -------------------------------------------------
 * Only coerce to a double if we already know it's 
 * an integer or double, or a string which is actually numeric.
 * Don't blindly run the macro SvNV, because that will coerce 
 * a non-numeric string to be a double of value 0.0, 
 * and we do not want that to happen, because if we test it again, 
 * it will then appear to be a valid double value. 
 */
static int
extract_double_from_scalar(pTHX_ SV * mysv, double * number) {

    if (SvPOKp(mysv) && SvLEN(mysv)) {  

        /* This function is not in the public perl API */
        if (Perl_looks_like_number(aTHX_ mysv)) {
            *number = SvNV( mysv );
            return 1;
        } else {
            return 0;
        } 
    } else if (SvNIOK(mysv)) {  
        *number = SvNV( mysv );
        return 1;
    } else {
        return 0;
    }
}



/* -------------------------------------------------
 * Convert a Perl 2D matrix into a 2D matrix of C doubles.
 * If no data are masked, mask can be passed as NULL.
 * NOTE: on errors this function returns a value greater than zero.
 */
static double**
parse_data(pTHX_ SV * matrix_ref, int** mask) {

    AV * matrix_av;
    SV * row_ref;
    AV * row_av;
    SV * cell;

    int type, i, j, nrows, ncols, n;

    double** matrix;

    /* NOTE -- we will just assume that matrix_ref points to an arrayref,
     * and that the first item in the array is itself an arrayref.
     * The calling perl functions must check this before we get this pointer.  
     * (It's easier to implement these checks in Perl rather than C.)
     * The value of perl_rows is now fixed. But the value of
     * rows will be decremented, if we skip any (invalid) Perl rows.
     */
    matrix_av  = (AV *) SvRV(matrix_ref);
    nrows = (int) av_len(matrix_av) + 1;

    if(nrows <= 0) {
        return NULL;
    }
    matrix   = malloc(nrows*sizeof(double*));
    if (!matrix) {
        return NULL;
    }

    row_ref  = *(av_fetch(matrix_av, (I32) 0, 0)); 
    row_av   = (AV *) SvRV(row_ref);
    ncols    = (int) av_len(row_av) + 1;


    /* ------------------------------------------------------------ 
     * Loop once for each row in the Perl matrix, and convert it to
     * C doubles. 
     */
    for (i=0; i < nrows; i++) { 

        row_ref = *(av_fetch(matrix_av, (I32) i, 0)); 

        if(! SvROK(row_ref) ) {

            if(warnings_enabled(aTHX))
                Perl_warn(aTHX_ 
                    "Row %d: Wanted array reference, but "
                    "got a scalar. No row to process?\n", i);
            break;
        }

        row_av = (AV *) SvRV(row_ref);
        type = SvTYPE(row_av); 
    
        /* Handle unexpected cases */
        if(type != SVt_PVAV ) {

             /* Reference doesn't point to an array at all. */
            if(warnings_enabled(aTHX))
                Perl_warn(aTHX_ 
                    "Row %d: Wanted array reference, but got "
                    "a reference to something else (%d)\n",
                    i, type);
            break;

        }

        n = (int) av_len(row_av) + 1;
        if (n != ncols) {
            /* All rows in the matrix should have the same
             * number of columns. */
            if(warnings_enabled(aTHX))
                Perl_warn(aTHX_ 
                    "Row %d: Contains %d columns "
                    "(expected %d)\n", i, n, ncols);
            break;
        }

        matrix[i] = malloc(ncols*sizeof(double));
        if (!matrix[i])
            break;

        /* Loop once for each cell in the row. */
        for (j=0; j < ncols; j++) { 
        
            double num;
            if (!mask || mask[i][j]) {
                cell = *(av_fetch(row_av, (I32) j, 0)); 
                if(extract_double_from_scalar(aTHX_ cell,&num) <= 0) {    
                    if(warnings_enabled(aTHX))
                        Perl_warn(aTHX_ 
                            "Row %d col %d: Value is not "
                                                    "a number.\n", i, j);
                    free(matrix[i]); /* not included below */
                    break;
                }
            }
            else {
                /* Don't read the value if it is masked.
                 * Set it to some arbitrary value. */
                num = 0.0;
            }
            matrix[i][j] = num;

        } /* End for (j=0; j < ncols; j++) */
        if (j < ncols) break;

    } /* End for (i=0; i < nrows; i++) */

    if (i < nrows) { /* encountered a break */
        nrows = i;
        for (i = 0; i < nrows; i++) free(matrix[i]);
        free(matrix);
        matrix = NULL;
    }

    return matrix;
}


/* -------------------------------------------------
 * Convert a Perl 2D matrix into a 2D matrix of C ints.
 * On errors this function returns a value greater than zero.
 */
static int**
parse_mask(pTHX_ SV * matrix_ref) {

    AV * matrix_av;
    SV * row_ref;
    AV * row_av;
    SV * cell;

    int type, i, j, nrows, ncols, n;

    int** matrix;

    /* NOTE -- we will just assume that matrix_ref points to an arrayref,
     * and that the first item in the array is itself an arrayref.
     * The calling perl functions must check this before we get this pointer.  
     * (It's easier to implement these checks in Perl rather than C.)
     * The value of perl_rows is now fixed. But the value of
     * rows will be decremented, if we skip any (invalid) Perl rows.
     */
    matrix_av = (AV *) SvRV(matrix_ref);
    nrows = (int) av_len(matrix_av) + 1;

    if(nrows <= 0) {
        return NULL;  /* Caller must handle this case!! */
    }
    matrix    = malloc(nrows * sizeof(int *) );
    if (!matrix) {
        return NULL;
    }

    row_ref   = *(av_fetch(matrix_av, (I32) 0, 0)); 
    row_av    = (AV *) SvRV(row_ref);
    ncols     = (int) av_len(row_av) + 1;



    /* ------------------------------------------------------------ 
     * Loop once for each row in the Perl matrix, and convert it to C ints. 
     */
    for (i=0; i < nrows; i++) { 

        row_ref = *(av_fetch(matrix_av, (I32) i, 0)); 

        if(! SvROK(row_ref) ) {

            if(warnings_enabled(aTHX))
                Perl_warn(aTHX_ 
                    "Row %d: Wanted array reference, but "
                    "got a scalar. No row to process?\n", i);
            break;
        }

        row_av = (AV *) SvRV(row_ref);
        type = SvTYPE(row_av); 
    
        /* Handle unexpected cases */
        if(type != SVt_PVAV ) {

             /* Reference doesn't point to an array at all. */
            if(warnings_enabled(aTHX))
                Perl_warn(aTHX_ 
                    "Row %d: Wanted array reference, but got "
                    "a reference to something else (%d)\n",
                    i, type);
            break;

        }

        n = (int) av_len(row_av) + 1;
        if (n != ncols) {
            /* All rows in the matrix should have the same
             * number of columns. */
            if(warnings_enabled(aTHX))
                Perl_warn(aTHX_ 
                    "Row %d: Contains %d columns "
                    "(expected %d)\n", i, n, ncols);
            break;
        }

        matrix[i] = malloc(ncols * sizeof(int) );
        if (!matrix[i]) {
            break;
        }

        /* Loop once for each cell in the row. */
        for (j=0; j < ncols; ++j) { 
            double num;
            cell = *(av_fetch(row_av, (I32) j, 0)); 
            if(extract_double_from_scalar(aTHX_ cell,&num) <= 0) {    
                if(warnings_enabled(aTHX))
                    Perl_warn(aTHX_
                        "Row %d col %d: Value is not "
                        "a number.\n", i, j);
                free(matrix[i]); /* not included below */
                break;
            }
            matrix[i][j] = (int) num;

        } /* End for (j=0; j < ncols; j++) */
        if (j < ncols) break;

    } /* End for (i=0; i < nrows; i++) */

    if (i < nrows) { /* break statement encountered */
        nrows = i;
        for (i = 0; i < nrows; i++) free(matrix[i]);
        free(matrix);
        matrix = NULL;
    }

    return matrix;
}


/* -------------------------------------------------
 *
 */
static void
free_matrix_int(int ** matrix, int nrows) {

    int i;
    for(i = 0; i < nrows; ++i ) {
        free(matrix[i]);
    }

    free(matrix);
}


/* -------------------------------------------------
 *
 */
static void
free_matrix_dbl(double ** matrix, int nrows) {

    int i;
    for(i = 0; i < nrows; ++i ) {
        free(matrix[i]);
    }

    free(matrix);
}


/* -------------------------------------------------
 *
 */
static void
free_ragged_matrix_dbl(double ** matrix, int nrows) {

    int i;
    for(i = 1; i < nrows; ++i ) {
        free(matrix[i]);
    }

    free(matrix);
}


/* -------------------------------------------------
 * Convert a Perl array into an array of doubles
 * On error, this function returns NULL.
 */
static double*
malloc_row_perl2c_dbl (pTHX_ SV * input, int* np) {

    int i;
    AV* array    = (AV *) SvRV(input);
    const int n  = (int) av_len(array) + 1;
    double* data = malloc(n * sizeof(double)); 
    if (!data) {
        return NULL;
    }

    /* Loop once for each item in the Perl array, and convert
         * it to a C double. 
     */
    for (i=0; i < n; i++) {
        double num;
        SV * mysv = *(av_fetch(array, (I32) i, (I32) 0));
        if(extract_double_from_scalar(aTHX_ mysv,&num) > 0) {    
            data[i] = num;
        } else {
            /* Error reading data */
            if (warnings_enabled(aTHX))
                Perl_warn(aTHX_ 
                    "Error parsing array: item %d is not a number\n", i);      
            free(data);
            return NULL;
        }
    }
    if(np) *np = n;
    return data;
}

/* -------------------------------------------------
 * Convert a Perl array into an array of ints
 * On errors this function returns NULL.
 */
static int*
malloc_row_perl2c_int (pTHX_ SV * input) {

    int i;

    AV* array = (AV *) SvRV(input);
    const int n = (int) av_len(array) + 1;
    int* data = malloc(n*sizeof(int)); 
    if (!data) {
        return NULL;
    }

    /* Loop once for each item in the Perl array,
     * and convert it to a C double. 
     */
    for (i=0; i < n; i++) {
        double num;
        SV * mysv = *(av_fetch(array, (I32) i, (I32) 0));
        if(extract_double_from_scalar(aTHX_ mysv,&num) > 0) {    
            data[i] = (int) num;
        } else {
            /* Check if the item is numeric */
            if (warnings_enabled(aTHX))
                Perl_warn(aTHX_ "Error when parsing array: item %d is"
                    " not a number, skipping\n", i);      
            free(data);
            return NULL;
        }
    }

    return data;
}

/* -------------------------------------------------
 * Copy a Perl array into an array of ints.
 * If an error occurs, return 0; otherwise return 1.
 */
static int
copy_row_perl2c_int (pTHX_ SV * input, int* output) {

    int i;

    AV* array = (AV *) SvRV(input);
    const int n = (int) av_len(array) + 1;

    /* Loop once for each item in the Perl array,
     * and convert it to a C double. 
     */
    for (i=0; i < n; i++) {
        double num;
        SV * mysv = *(av_fetch(array, (I32) i, (I32) 0));
        if(extract_double_from_scalar(aTHX_ mysv,&num) > 0) {    
            output[i] = (int) num;
        } else {
            /* Skip any items which are not numeric */
            if (warnings_enabled(aTHX))
                Perl_warn(aTHX_ 
                    "Error when parsing array: item %d is"
                    " not a number\n", i);      
            return 0;
        }
    }
    return 1;
}
/* -------------------------------------------------
 *
 */
static SV *
row_c2perl_dbl(pTHX_ double * row, int ncols) {

    int j;
    AV * row_av = newAV();
    for(j=0; j<ncols; ++j) {
        av_push(row_av, newSVnv(row[j]));
    }
    return newRV_noinc((SV*) row_av);
}

/* -------------------------------------------------
 *
 */
static SV*
row_c2perl_int(pTHX_ int * row, int ncols) {

    int j;
    AV * row_av = newAV();
    for(j=0; j<ncols; ++j) {
        av_push(row_av, newSVnv(row[j]));
    }
    return ( newRV_noinc( (SV*) row_av ) );
}

/* -------------------------------------------------
 *
 */
static SV*
matrix_c2perl_dbl(pTHX_ double ** matrix, int nrows, int ncols) {

    int i;
    AV * matrix_av = newAV();
    SV * row_ref;
    for(i=0; i<nrows; ++i) {
        row_ref = row_c2perl_dbl(aTHX_ matrix[i], ncols);
        av_push(matrix_av, row_ref);
    }
    return ( newRV_noinc( (SV*) matrix_av ) );
}

/* -------------------------------------------------
 *
 */
static SV*
matrix_c2perl_int(pTHX_ int ** matrix, int nrows, int ncols) {

    int i;
    AV * matrix_av = newAV();
    SV * row_ref;
    for(i=0; i<nrows; ++i) {
        row_ref = row_c2perl_int(aTHX_ matrix[i], ncols);
        av_push(matrix_av, row_ref);
    }
    return ( newRV_noinc( (SV*) matrix_av ) );
}

/* -------------------------------------------------
 *
 */
static SV*
ragged_matrix_c2perl_dbl(pTHX_ double ** matrix, int nobjects) {

    int i;
    AV * matrix_av = newAV();
    SV * row_ref;
    for(i=0; i<nobjects; ++i) {
        row_ref = row_c2perl_dbl(aTHX_ matrix[i], i);
        av_push(matrix_av, row_ref);
    }
    return ( newRV_noinc( (SV*) matrix_av ) );
}

/* -------------------------------------------------
 * Check if the data matrix is a distance matrix, or
 * a raw distance matrix.
 */
static int
is_distance_matrix(pTHX_ SV * data_ref)
{
    /* We don't check data_ref because we expect the caller to check it 
     */
    AV * matrix_av  = (AV *) SvRV(data_ref);
    SV * row_ref    = *(av_fetch(matrix_av, (I32) 0, 0)); 
    AV * row_av     = (AV *) SvRV(row_ref);
    const int ncols = (int) av_len(row_av) + 1;
    if (ncols==0) return 1;

    return 0;
}


/* -------------------------------------------------
 * Convert the 'data' and 'mask' matrices and the 'weight' array
 * from C to Perl.  Also check for errors, and bail out if there are any.
 */
static int
malloc_matrices(pTHX_
    SV *  weight_ref, double  ** weight, int nweights, 
    SV *  data_ref,   double *** matrix,
    SV *  mask_ref,   int    *** mask,
    int   nrows,      int        ncols
) {

    if(SvROK(mask_ref) && SvTYPE(SvRV(mask_ref)) == SVt_PVAV) { 
        *mask = parse_mask(aTHX_ mask_ref);
        if(*mask==NULL) return 0;
    } else {
        int i,j;
        int** p = malloc(nrows*sizeof(int*));
        if(!p) return 0;
        for (i = 0; i < nrows; ++i) { 
            p[i] = malloc(ncols*sizeof(int));
            if(!p[i]) {
                while(--i >= 0) free(p[i]);
                free(p);
                return 0;
            }
            for (j = 0; j < ncols; j++) p[i][j] = 1;
        }
        *mask = p;
    }

    /* We don't check data_ref because we expect the caller to check it 
     */
    *matrix = parse_data(aTHX_ data_ref, *mask);
    if(*matrix==NULL) {
        free_matrix_int(*mask,     nrows);
        return 0;
    }

    if(weight_ref==NULL) return 1; /* Weights not needed */
    if(SvROK(weight_ref) && SvTYPE(SvRV(weight_ref)) == SVt_PVAV) { 
        *weight = malloc_row_perl2c_dbl(aTHX_ weight_ref, NULL);
    } else {
        *weight = malloc_row_dbl(aTHX_ nweights,1.0);
    }

    if(!(*weight)) {
        free_matrix_int(*mask,     nrows);
        free_matrix_dbl(*matrix,   nrows);
        return 0;
    }

    return 1;
}

static double**
parse_distance(pTHX_ SV* matrix_ref, int nobjects)
{
    int i,j;

    AV* matrix_av  = (AV *) SvRV(matrix_ref);
    double** matrix = malloc(nobjects*sizeof(double*));
    if (!matrix) {
        return NULL;
    }

    matrix[0] = NULL;
    for (i=1; i < nobjects; i++) { 
        SV* row_ref = *(av_fetch(matrix_av, (I32) i, 0)); 
        AV* row_av  = (AV *) SvRV(row_ref);
        matrix[i] = malloc(i * sizeof(double));
        if (!matrix[i]) {
            break;
        }
        /* Loop once for each cell in the row. */
        for (j=0; j < i; j++) { 
            double num;
            SV* cell = *(av_fetch(row_av, (I32) j, 0)); 
            if(extract_double_from_scalar(aTHX_ cell,&num) > 0) {    
                matrix[i][j] = num;
            } else {
                if(warnings_enabled(aTHX))
                    Perl_warn(aTHX_ 
                        "Row %d col %d: Value is not "
                                                "a number.\n", i, j);
                break;
            }
        }
    }

    if (i < nobjects) {
        nobjects = i+1;
        for (i = 1; i < nobjects; i++) free(matrix[i]);
        free(matrix);
        matrix = NULL;
    }

    return matrix;
}

/******************************************************************************/
/**                                                                          **/
/** XS code begins here                                                      **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

#line 712 "Cluster.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 856 "Cluster.c"

XS_EUPXS(XS_Algorithm__Cluster__Node_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Node_new)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "class, left, right, distance");
    {
	char*	class = (char *)SvPV_nolen(ST(0))
;
	int	left = (int)SvIV(ST(1))
;
	int	right = (int)SvIV(ST(2))
;
	double	distance = (double)SvNV(ST(3))
;
#line 712 "Cluster.xs"
    Node* node;
    SV* obj;
#line 876 "Cluster.c"
	SV *	RETVAL;
#line 715 "Cluster.xs"
    node = malloc(sizeof(Node));
    RETVAL = newSViv(0);
    obj = newSVrv(RETVAL, class);
    node->left = left;
    node->right = right;
    node->distance = distance;

    sv_setiv(obj, PTR2IV(node));
    SvREADONLY_on(obj);
#line 888 "Cluster.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__Node_left); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Node_left)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV*	obj = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 732 "Cluster.xs"
    RETVAL = (INT2PTR(Node*,SvIV(SvRV(obj))))->left;
#line 909 "Cluster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__Node_right); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Node_right)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV*	obj = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 740 "Cluster.xs"
    RETVAL = (INT2PTR(Node*,SvIV(SvRV(obj))))->right;
#line 929 "Cluster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__Node_distance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Node_distance)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV*	obj = ST(0)
;
	double	RETVAL;
	dXSTARG;
#line 748 "Cluster.xs"
    RETVAL = (INT2PTR(Node*,SvIV(SvRV(obj))))->distance;
#line 949 "Cluster.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__Node_set_left); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Node_set_left)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, left");
    {
	SV*	obj = ST(0)
;
	int	left = (int)SvIV(ST(1))
;
#line 757 "Cluster.xs"
    Node* node;
#line 969 "Cluster.c"
#line 759 "Cluster.xs"
    if (!sv_isa(obj, "Algorithm::Cluster::Node")) {
        croak("set_left should be applied to an Algorithm::Cluster::Node object");
    }
    node = INT2PTR(Node*,SvIV(SvRV(obj)));
    node->left = left;
#line 976 "Cluster.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Algorithm__Cluster__Node_set_right); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Node_set_right)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, right");
    {
	SV*	obj = ST(0)
;
	int	right = (int)SvIV(ST(1))
;
#line 770 "Cluster.xs"
    Node* node;
#line 995 "Cluster.c"
#line 772 "Cluster.xs"
    if (!sv_isa(obj, "Algorithm::Cluster::Node")) {
        croak("set_right should be applied to an Algorithm::Cluster::Node object");
    }
    node = INT2PTR(Node*,SvIV(SvRV(obj)));
    node->right = right;
#line 1002 "Cluster.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Algorithm__Cluster__Node_set_distance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Node_set_distance)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, distance");
    {
	SV*	obj = ST(0)
;
	double	distance = (double)SvNV(ST(1))
;
#line 783 "Cluster.xs"
    Node* node;
#line 1021 "Cluster.c"
#line 785 "Cluster.xs"
    if (!sv_isa(obj, "Algorithm::Cluster::Node")) {
        croak("set_distance should be applied to an Algorithm::Cluster::Node object");
    }
    node = INT2PTR(Node*,SvIV(SvRV(obj)));
    node->distance = distance;
#line 1028 "Cluster.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Algorithm__Cluster__Node_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Node_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	obj = ST(0)
;
#line 794 "Cluster.xs"
    I32* temp;
    Node* node;
#line 1048 "Cluster.c"
#line 797 "Cluster.xs"
    temp = PL_markstack_ptr++;
    node = INT2PTR(Node*, SvIV(SvRV(obj)));
    free(node);
    if (PL_markstack_ptr != temp) {
        /* truly void, because dXSARGS not invoked */
        PL_markstack_ptr = temp;
        XSRETURN_EMPTY;
        /* return empty stack */
    }  /* must have used dXSARGS; list context implied */
    return;  /* assume stack size is correct */
#line 1060 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Algorithm__Cluster__Tree_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Tree_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "class, nodes");
    {
	char*	class = (char *)SvPV_nolen(ST(0))
;
	SV*	nodes = ST(1)
;
#line 818 "Cluster.xs"
    Tree* tree;
    SV* obj;
        int i;
    int n;
    AV* array;
    int* flag;

#line 1086 "Cluster.c"
	SV *	RETVAL;
#line 826 "Cluster.xs"
    if(!SvROK(nodes) || SvTYPE(SvRV(nodes)) != SVt_PVAV) { 
        croak("Algorithm::Cluster::Tree::new expects an array of nodes\n");
    }
    array = (AV *) SvRV(nodes);
    n = (int) av_len(array) + 1;
    tree = malloc(sizeof(Tree));
    if (tree) {
        tree->n = n;
        tree->nodes = malloc(n*sizeof(Node));
    }
    if (! tree || !tree->nodes) {
        if (tree) free(tree);
        croak("Algorithm::Cluster::Tree::new memory error\n");
    }

        for (i = 0; i < n; i++) {
        Node* node;
        SV* node_ref = *(av_fetch(array, (I32) i, 0)); 
        if (!sv_isa(node_ref, "Algorithm::Cluster::Node")) break;
        node = INT2PTR(Node*,SvIV(SvRV(node_ref)));
        tree->nodes[i].left = node->left;
        tree->nodes[i].right = node->right;
        tree->nodes[i].distance = node->distance;
    }

    if (i < n) {
        /* break encountered */
        free(tree->nodes);
        free(tree);
        croak("Algorithm::Cluster::Tree::new expects an array of nodes\n");
    }

    flag = malloc((2*n+1)*sizeof(int));
    if(flag) {
         int j;
        for (i = 0; i < 2*n+1; i++) flag[i] = 0;
        for (i = 0; i < n; i++) {
            j = tree->nodes[i].left;
            if (j < 0) {
                j = -j-1;
                if (j>=i) break;
            }
            else j+=n;
            if (flag[j]) break;
            flag[j] = 1;
            j = tree->nodes[i].right;
            if (j < 0) {
                j = -j-1;
                if (j>=i) break;
            }
            else j+=n;
            if (flag[j]) break;
            flag[j] = 1;
        }
        free(flag);
    }

    if (!flag || i < n) {
        /* break encountered */
        free(tree->nodes);
        free(tree);
        croak("the array of nodes passed to Algorithm::Cluster::Tree::new does not represent a valid tree\n");
    }

    RETVAL = newSViv(0);
    obj = newSVrv(RETVAL, class);
    sv_setiv(obj, PTR2IV(tree));
    SvREADONLY_on(obj);

#line 1158 "Cluster.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__Tree_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Tree_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV*	obj = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 902 "Cluster.xs"
    RETVAL = (INT2PTR(Tree*,SvIV(SvRV(obj))))->n;
#line 1179 "Cluster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__Tree_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Tree_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, index");
    {
	SV*	obj = ST(0)
;
	int	index = (int)SvIV(ST(1))
;
#line 912 "Cluster.xs"
    Tree* tree;
    Node* node;
    SV* scalar;
#line 1201 "Cluster.c"
	SV *	RETVAL;
#line 916 "Cluster.xs"
    tree = INT2PTR(Tree*,SvIV(SvRV(obj)));
    if (index < 0 || index >= tree->n) {
        croak("Index out of bounds in Algorithm::Cluster::Tree::get\n");
    }
    RETVAL = newSViv(0);
    scalar = newSVrv(RETVAL, "Algorithm::Cluster::Node");
    node = malloc(sizeof(Node));
    node->left = tree->nodes[index].left;
    node->right = tree->nodes[index].right;
    node->distance = tree->nodes[index].distance;
    sv_setiv(scalar, PTR2IV(node));
    SvREADONLY_on(scalar);
#line 1216 "Cluster.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__Tree_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Tree_scale)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV*	obj = ST(0)
;
#line 935 "Cluster.xs"
    int i;
    int n;
    Tree* tree;
    Node* nodes;
    double maximum;
#line 1239 "Cluster.c"
#line 941 "Cluster.xs"
    if (!sv_isa(obj, "Algorithm::Cluster::Tree")) {
        croak("scale can only be applied to an Algorithm::Cluster::Tree object");
    }
    tree = INT2PTR(Tree*,SvIV(SvRV(obj)));
    n = tree->n;
    nodes = tree->nodes;
    maximum = DBL_MIN;
    for (i = 0; i < n; i++) {
        double distance = nodes[i].distance;
        if (distance > maximum) maximum = distance;
    }
    if (maximum!=0.0) {
        for (i = 0; i < n; i++) nodes[i].distance /= maximum;
    }
#line 1255 "Cluster.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Algorithm__Cluster__Tree_cut); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Tree_cut)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, nclusters");
    {
	SV*	obj = ST(0)
;
	int	nclusters = (int)SvIV(ST(1))
;
#line 961 "Cluster.xs"
    int i;
    int n;
    Tree* tree;
    int* clusterid;
#line 1277 "Cluster.c"
	AV *	RETVAL;
#line 966 "Cluster.xs"
    if (!sv_isa(obj, "Algorithm::Cluster::Tree")) {
        croak("cut can only be applied to an Algorithm::Cluster::Tree object");
    }
    tree = INT2PTR(Tree*,SvIV(SvRV(obj)));
    n = tree->n + 1;
    if (nclusters < 1) {
        croak("cut: Requested number of clusters should be positive");
    }
    if (nclusters > n) {
        croak("cut: More clusters requested than items available");
    }
    clusterid = malloc(n*sizeof(int));
    if (!clusterid) {
        croak("cut: Insufficient memory");
    }
        /* --------------------------------------------------------------- */
    cuttree(n, tree->nodes, nclusters, clusterid);
    /* -- Check for errors flagged by the C routine ------------------ */
    if (clusterid[0]==-1) {
        free(clusterid);
        croak("cut: Error in the cuttree routine");
    }
    RETVAL = newAV();
    for(i=0; i<n; i++) {
        av_push(RETVAL, newSVnv(clusterid[i]));
    }
    free(clusterid);
    sv_2mortal((SV*)RETVAL);
#line 1308 "Cluster.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__Tree_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__Tree_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV*	obj = ST(0)
;
#line 1001 "Cluster.xs"
    I32* temp;
    Tree* tree;
#line 1334 "Cluster.c"
#line 1004 "Cluster.xs"
    temp = PL_markstack_ptr++;
    tree = INT2PTR(Tree*, SvIV(SvRV(obj)));
    free(tree->nodes);
    free(tree);
    if (PL_markstack_ptr != temp) {
        /* truly void, because dXSARGS not invoked */
        PL_markstack_ptr = temp;
        XSRETURN_EMPTY;
        /* return empty stack */
    }  /* must have used dXSARGS; list context implied */
    return;  /* assume stack size is correct */
#line 1347 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Algorithm__Cluster__version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__version)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 1024 "Cluster.xs"
    RETVAL = newSVpv( CLUSTERVERSION , 0);

#line 1365 "Cluster.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__mean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__mean)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input");
    {
	SV *	input = ST(0)
;
#line 1036 "Cluster.xs"
    int array_length;
    double * data;  /* one-dimensional array of doubles */

#line 1386 "Cluster.c"
	SV *	RETVAL;
#line 1040 "Cluster.xs"
    if(SvTYPE(SvRV(input)) != SVt_PVAV) { 
        XSRETURN_UNDEF;
    }

    data = malloc_row_perl2c_dbl (aTHX_ input, &array_length);
    if (data) {
        RETVAL = newSVnv( mean(array_length, data) );
        free(data);
    } else {
        croak("memory allocation failure in _mean\n");
    }

#line 1401 "Cluster.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__median); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__median)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input");
    {
	SV *	input = ST(0)
;
#line 1061 "Cluster.xs"
    int array_length;
    double * data;  /* one-dimensional array of doubles */

#line 1422 "Cluster.c"
	SV *	RETVAL;
#line 1065 "Cluster.xs"
    if(SvTYPE(SvRV(input)) != SVt_PVAV) { 
        XSRETURN_UNDEF;
    }

    data = malloc_row_perl2c_dbl (aTHX_ input, &array_length);
    if (data) {
        RETVAL = newSVnv( median(array_length, data) );
        free(data);
    } else {
        croak("memory allocation failure in _median\n");
    }

#line 1437 "Cluster.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__treecluster); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__treecluster)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "nrows, ncols, data_ref, mask_ref, weight_ref, transpose, dist, method");
    {
	int	nrows = (int)SvIV(ST(0))
;
	int	ncols = (int)SvIV(ST(1))
;
	SV *	data_ref = ST(2)
;
	SV *	mask_ref = ST(3)
;
	SV *	weight_ref = ST(4)
;
	int	transpose = (int)SvIV(ST(5))
;
	char *	dist = (char *)SvPV_nolen(ST(6))
;
	char *	method = (char *)SvPV_nolen(ST(7))
;
#line 1093 "Cluster.xs"
    Node*    nodes;

    double  * weight = NULL;
    double ** matrix = NULL;
    int    ** mask   = NULL;
    double ** distancematrix = NULL;
    const int ndata = transpose ? nrows : ncols;
    const int nelements = transpose ? ncols : nrows;

#line 1478 "Cluster.c"
	SV *	RETVAL;
#line 1103 "Cluster.xs"
    /* ------------------------
     * Don't check the parameters, because we rely on the Perl
     * caller to check most paramters.
     */
    /* ------------------------
     * Convert data and mask matrices and the weight array
     * from C to Perl.  Also check for errors, and ignore the
     * mask or the weight array if there are any errors. 
     */
    if (is_distance_matrix(aTHX_ data_ref)) {
        distancematrix = parse_distance(aTHX_ data_ref, nelements);
        if (!distancematrix) {
                croak("memory allocation failure in _treecluster\n");
        }
    } else {
        int ok;
        ok = malloc_matrices(aTHX_ weight_ref, &weight, ndata, 
                    data_ref,   &matrix,
                    mask_ref,   &mask,  
                    nrows,      ncols);
        if (!ok) {
            croak("failed to read input data for _treecluster\n");
        }
        }

    /* ------------------------
     * Run the library function
     */
    nodes = treecluster(nrows, ncols, matrix, mask, weight, transpose,
                dist[0], method[0], distancematrix);

    /* ------------------------
     * Check result to make sure we didn't run into memory problems
     */
    if(!nodes) {
        /* treecluster failed due to insufficient memory */
        if (matrix) {
            free_matrix_int(mask,     nrows);
            free_matrix_dbl(matrix,   nrows);
            free(weight);
        } else {
            free_ragged_matrix_dbl(distancematrix, nelements);
        }
        croak("memory allocation failure in treecluster\n");
    }
    else {

        /* ------------------------
          * Convert generated C matrices to Perl matrices
          */
        const int n = nelements-1;
        int i;
        SV* obj;
        Tree* tree;
        RETVAL = newSViv(0);
        obj = newSVrv(RETVAL, "Algorithm::Cluster::Tree");
        tree = malloc(sizeof(Tree));
        tree->n = n;
        tree->nodes = malloc(n*sizeof(Node));
        sv_setiv(obj, PTR2IV(tree));
        SvREADONLY_on(obj);
        for(i=0; i<n; i++) {
            tree->nodes[i].left = nodes[i].left;
            tree->nodes[i].right = nodes[i].right;
            tree->nodes[i].distance = nodes[i].distance;
        }
        free(nodes);
    }

    /* ------------------------
     * Free what we've malloc'ed 
     */
    if (matrix) {
        free_matrix_int(mask,     nrows);
        free_matrix_dbl(matrix,   nrows);
        free(weight);
    } else {
        free_ragged_matrix_dbl(distancematrix, nelements);
    }

    /* Finished _treecluster() */
#line 1562 "Cluster.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__kcluster); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__kcluster)
{
    dVAR; dXSARGS;
    if (items != 11)
       croak_xs_usage(cv,  "nclusters, nrows, ncols, data_ref, mask_ref, weight_ref, transpose, npass, method, dist, initialid_ref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	nclusters = (int)SvIV(ST(0))
;
	int	nrows = (int)SvIV(ST(1))
;
	int	ncols = (int)SvIV(ST(2))
;
	SV *	data_ref = ST(3)
;
	SV *	mask_ref = ST(4)
;
	SV *	weight_ref = ST(5)
;
	int	transpose = (int)SvIV(ST(6))
;
	int	npass = (int)SvIV(ST(7))
;
	char *	method = (char *)SvPV_nolen(ST(8))
;
	char *	dist = (char *)SvPV_nolen(ST(9))
;
	SV *	initialid_ref = ST(10)
;
#line 1203 "Cluster.xs"
    SV  *    clusterid_ref;
    int *    clusterid;
    int      nobjects;
    int      ndata;
    double   error;
    int      ifound;
    int      ok;

    double  * weight;
    double ** matrix;
    int    ** mask;


#line 1615 "Cluster.c"
#line 1217 "Cluster.xs"
    /* ------------------------
     * Don't check the parameters, because we rely on the Perl
     * caller to check most parameters.
     */

    /* ------------------------
     * Malloc space for the return values from the library function
     */
    if (transpose==0) {
        nobjects = nrows;
        ndata = ncols;
    } else {
        nobjects = ncols;
        ndata = nrows;
    }
        clusterid = malloc(nobjects * sizeof(int) );
        if (!clusterid) {
        croak("memory allocation failure in _kcluster\n");
    }

    /* ------------------------
     * Convert data and mask matrices and the weight array
     * from C to Perl.  Also check for errors, and ignore the
     * mask or the weight array if there are any errors. 
     */
    ok = malloc_matrices( aTHX_ weight_ref, &weight, ndata, 
                data_ref,   &matrix,
                mask_ref,   &mask,  
                nrows,      ncols);
        if (!ok) {
        free(clusterid);
            croak("failed to read input data for _kcluster\n");
    }

    /* ------------------------
     * Copy initialid to clusterid, if needed
     */

    if (npass==0) {
        copy_row_perl2c_int(aTHX_ initialid_ref, clusterid);
    }

    /* ------------------------
     * Run the library function
     */
    kcluster( 
        nclusters, nrows, ncols, 
        matrix, mask, weight, transpose,
        npass, method[0], dist[0], clusterid,  &error, &ifound

    );

    /* ------------------------
     * Convert generated C matrices to Perl matrices
     */
    clusterid_ref =    row_c2perl_int(aTHX_ clusterid, nobjects);

    /* ------------------------
     * Push the new Perl matrices onto the return stack
     */
    XPUSHs(sv_2mortal( clusterid_ref   ));
    XPUSHs(sv_2mortal( newSVnv(error) ));
    XPUSHs(sv_2mortal( newSViv(ifound) ));

    /* ------------------------
     * Free what we've malloc'ed 
     */
    free(clusterid);
    free_matrix_int(mask,     nrows);
    free_matrix_dbl(matrix,   nrows);
    free(weight);

    /* Finished _kcluster() */
#line 1690 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Algorithm__Cluster__kmedoids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__kmedoids)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "nclusters, nobjects, distancematrix_ref, npass, initialid_ref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	nclusters = (int)SvIV(ST(0))
;
	int	nobjects = (int)SvIV(ST(1))
;
	SV *	distancematrix_ref = ST(2)
;
	int	npass = (int)SvIV(ST(3))
;
	SV *	initialid_ref = ST(4)
;
#line 1303 "Cluster.xs"
    double** distancematrix;
    SV  *    clusterid_ref;
    int *    clusterid;
    double   error;
    int      ifound;



#line 1725 "Cluster.c"
#line 1312 "Cluster.xs"
    /* ------------------------
     * Don't check the parameters, because we rely on the Perl
     * caller to check most parameters.
     */

    /* ------------------------
     * Malloc space for the return values from the library function
     */
    clusterid = malloc(nobjects * sizeof(int) );
        if (!clusterid) {
            croak("memory allocation failure in _kmedoids\n");
    }

    /* ------------------------
     * Convert data and mask matrices and the weight array
     * from C to Perl.  Also check for errors, and ignore the
     * mask or the weight array if there are any errors. 
     */
    distancematrix = parse_distance(aTHX_ distancematrix_ref, nobjects);
    if (!distancematrix) {
        free(clusterid);
            croak("failed to allocate memory for distance matrix in _kmedoids\n");
    }

    /* ------------------------
     * Copy initialid to clusterid, if needed
     */

    if (npass==0) {
        copy_row_perl2c_int(aTHX_ initialid_ref, clusterid);
    }

    /* ------------------------
     * Run the library function
     */
    kmedoids( 
        nclusters, nobjects, 
        distancematrix, npass, clusterid, 
        &error, &ifound
    );

    if(ifound==-1) {
        free(clusterid);
        free_ragged_matrix_dbl(distancematrix, nobjects);
            croak("memory allocation failure in _kmedoids\n");
    }
    else if(ifound==0) {
        free(clusterid);
        free_ragged_matrix_dbl(distancematrix, nobjects);
            croak("error in input arguments in kmedoids\n");
    }
    else {

        /* ------------------------
         * Convert generated C matrices to Perl matrices
         */
        clusterid_ref =    row_c2perl_int(aTHX_ clusterid, nobjects);

        /* ------------------------
         * Push the new Perl matrices onto the return stack
         */
        XPUSHs(sv_2mortal( clusterid_ref   ));
        XPUSHs(sv_2mortal( newSVnv(error) ));
        XPUSHs(sv_2mortal( newSViv(ifound) ));

    }
    /* ------------------------
     * Free what we've malloc'ed 
     */
    free(clusterid);
    free_ragged_matrix_dbl(distancematrix, nobjects);

    /* Finished _kmedoids() */
#line 1800 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Algorithm__Cluster__clusterdistance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__clusterdistance)
{
    dVAR; dXSARGS;
    if (items != 12)
       croak_xs_usage(cv,  "nrows, ncols, data_ref, mask_ref, weight_ref, cluster1_len, cluster2_len, cluster1_ref, cluster2_ref, dist, method, transpose");
    {
	int	nrows = (int)SvIV(ST(0))
;
	int	ncols = (int)SvIV(ST(1))
;
	SV *	data_ref = ST(2)
;
	SV *	mask_ref = ST(3)
;
	SV *	weight_ref = ST(4)
;
	int	cluster1_len = (int)SvIV(ST(5))
;
	int	cluster2_len = (int)SvIV(ST(6))
;
	SV *	cluster1_ref = ST(7)
;
	SV *	cluster2_ref = ST(8)
;
	char *	dist = (char *)SvPV_nolen(ST(9))
;
	char *	method = (char *)SvPV_nolen(ST(10))
;
	int	transpose = (int)SvIV(ST(11))
;
#line 1404 "Cluster.xs"
    int   nweights;

    int     * cluster1;
    int     * cluster2;

    double  * weight;
    double ** matrix;
    int    ** mask;

    double distance;

    int ok;

#line 1852 "Cluster.c"
	double	RETVAL;
	dXSTARG;
#line 1419 "Cluster.xs"
    /* ------------------------
     * Don't check the parameters, because we rely on the Perl
     * caller to check most paramters.
     */

    /* ------------------------
     * Convert cluster index Perl arrays to C arrays
     */
    cluster1 = malloc_row_perl2c_int(aTHX_ cluster1_ref);
    cluster2 = malloc_row_perl2c_int(aTHX_ cluster2_ref);
    if (!cluster1 || !cluster2) {
        if (cluster1) free(cluster1);
        if (cluster2) free(cluster2);
        croak("memory allocation failure in _clusterdistance\n");
    }

    /* ------------------------
     * Convert data and mask matrices and the weight array
     * from C to Perl.  Also check for errors, and ignore the
     * mask or the weight array if there are any errors. 
     * Set nweights to the correct number of weights.
     */
    nweights = (transpose==0) ? ncols : nrows;
    ok = malloc_matrices( aTHX_ weight_ref, &weight, nweights, 
                data_ref,   &matrix,
                mask_ref,   &mask,  
                nrows,      ncols);
    if (!ok) {
        free(cluster1);
        free(cluster2);
            croak("failed to read input data for _clusterdistance\n");
    }

    /* ------------------------
     * Run the library function
     */
    distance = clusterdistance( 
        nrows, ncols, 
        matrix, mask, weight,
        cluster1_len, cluster2_len, cluster1, cluster2,
        dist[0], method[0], transpose
    );

    RETVAL = distance;

    /* ------------------------
     * Free what we've malloc'ed 
     */
    free_matrix_int(mask,     nrows);
    free_matrix_dbl(matrix,   nrows);
    free(weight);
    free(cluster1);
    free(cluster2);

    /* Finished _clusterdistance() */

#line 1912 "Cluster.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Algorithm__Cluster__clustercentroids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__clustercentroids)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "nclusters, nrows, ncols, data_ref, mask_ref, clusterid_ref, transpose, method");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	nclusters = (int)SvIV(ST(0))
;
	int	nrows = (int)SvIV(ST(1))
;
	int	ncols = (int)SvIV(ST(2))
;
	SV *	data_ref = ST(3)
;
	SV *	mask_ref = ST(4)
;
	SV *	clusterid_ref = ST(5)
;
	int	transpose = (int)SvIV(ST(6))
;
	char *	method = (char *)SvPV_nolen(ST(7))
;
#line 1492 "Cluster.xs"
    SV  *    cdata_ref;
    SV  *    cmask_ref;
    int     * clusterid;

    double ** matrix;
    int    ** mask;

    double ** cdata;
    int    ** cmask;
    int       cnrows = 0; /* Initialize to make the compiler shut up */
    int       cncols = 0; /* Initialize to make the compiler shut up */

    int i;
    int ok;

#line 1960 "Cluster.c"
#line 1509 "Cluster.xs"
    /* ------------------------
     * Don't check the parameters, because we rely on the Perl
     * caller to check most paramters.
     */
        if (transpose==0)
        {    cnrows = nclusters;
             cncols = ncols;
        }
        else if (transpose==1)
        {    cnrows = nrows;
             cncols = nclusters;
        }

    /* ------------------------
     * Convert cluster index Perl arrays to C arrays
     */
    clusterid = malloc_row_perl2c_int(aTHX_ clusterid_ref);
    if (!clusterid) {
        croak("memory allocation failure in _clustercentroids\n");
    }

    /* ------------------------
     * Convert data and mask matrices and the weight array
     * from C to Perl.  Also check for errors, and ignore the
     * mask or the weight array if there are any errors. 
     * Set nweights to the correct number of weights.
     */
    ok = malloc_matrices( aTHX_ NULL, NULL, 0, 
                data_ref,   &matrix,
                mask_ref,   &mask,  
                nrows,      ncols);
    if (!ok) {
        free(clusterid);
            croak("failed to read input data for _clustercentroids\n");
    }


    /* ------------------------
     * Create the output variables cdata and cmask.
     */
    i = 0;
    cdata = malloc(cnrows * sizeof(double*));
    cmask = malloc(cnrows * sizeof(int*));
    if (cdata && cmask) {
        for ( ; i < cnrows; i++) {
            cdata[i] = malloc(cncols*sizeof(double));
            cmask[i] = malloc(cncols*sizeof(int));
            if (!cdata[i] || !cmask[i]) break;
        }
    }
    if (i < cnrows)
    {
        if (cdata[i]) free(cdata[i]);
        if (cmask[i]) free(cmask[i]);
        while (--i >= 0) {
            free(cdata[i]);
            free(cmask[i]);
        }
        if (cdata) free(cdata);
        if (cmask) free(cmask);
        free(clusterid);
        free_matrix_int(mask,     nrows);
        free_matrix_dbl(matrix,   nrows);
        croak("memory allocation failure in _clustercentroids\n");
    }

    /* ------------------------
     * Run the library function
     */
    ok = getclustercentroids(
               nclusters, nrows, ncols,
               matrix, mask, clusterid,
               cdata, cmask, transpose, method[0]);

    if (ok) {
            /* ------------------------
             * Convert generated C matrices to Perl matrices
             */
            cdata_ref = matrix_c2perl_dbl(aTHX_ cdata, cnrows, cncols);
            cmask_ref = matrix_c2perl_int(aTHX_ cmask, cnrows, cncols);

            /* ------------------------
             * Push the new Perl matrices onto the return stack
             */
            XPUSHs(sv_2mortal( cdata_ref   ));
            XPUSHs(sv_2mortal( cmask_ref   ));
    }

    /* ------------------------
     * Free what we've malloc'ed 
     */
    free_matrix_int(mask,     nrows);
    free_matrix_dbl(matrix,   nrows);
    free_matrix_int(cmask,    cnrows);
    free_matrix_dbl(cdata,    cnrows);
    free(clusterid);

    if (!ok) {
        croak("memory allocation failure in _clustercentroids\n");
    }
    /* Finished _clustercentroids() */
#line 2063 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Algorithm__Cluster__distancematrix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__distancematrix)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "nrows, ncols, data_ref, mask_ref, weight_ref, transpose, dist");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	nrows = (int)SvIV(ST(0))
;
	int	ncols = (int)SvIV(ST(1))
;
	SV *	data_ref = ST(2)
;
	SV *	mask_ref = ST(3)
;
	SV *	weight_ref = ST(4)
;
	int	transpose = (int)SvIV(ST(5))
;
	char *	dist = (char *)SvPV_nolen(ST(6))
;
#line 1622 "Cluster.xs"
    SV  *    matrix_ref;
    int      nobjects;
    int      ndata;

    double ** data;
    int    ** mask;
    double  * weight;
    double ** matrix;

    int       ok;


#line 2106 "Cluster.c"
#line 1635 "Cluster.xs"
    /* ------------------------
     * Don't check the parameters, because we rely on the Perl
     * caller to check most parameters.
     */

    /* ------------------------
     * Malloc space for the return values from the library function
     */
        if (transpose==0) {
        nobjects = nrows;
        ndata = ncols;
    } else {
        nobjects = ncols;
        ndata = nrows;
    }

    /* ------------------------
     * Convert data and mask matrices and the weight array
     * from C to Perl.  Also check for errors, and ignore the
     * mask or the weight array if there are any errors. 
     */
    ok = malloc_matrices( aTHX_
        weight_ref, &weight, ndata, 
        data_ref,   &data,
        mask_ref,   &mask,  
        nrows,      ncols
    );
    if (!ok) {
            croak("failed to read input data for _distancematrix");
    }

    /* ------------------------
     * Run the library function
     */
        matrix = distancematrix (nrows,
                                 ncols,
                                 data,
                                 mask,
                                 weight,
                                 dist[0],
                                 transpose);

    /* ------------------------
     * Convert generated C matrices to Perl matrices
     */
    matrix_ref  = ragged_matrix_c2perl_dbl(aTHX_ matrix,  nobjects);

    /* ------------------------
     * Push the new Perl matrices onto the return stack
     */
    XPUSHs(sv_2mortal(matrix_ref));

    /* ------------------------
     * Free what we've malloc'ed 
     */
    free_ragged_matrix_dbl(matrix, nobjects);
    free_matrix_int(mask, nrows);
    free_matrix_dbl(data, nrows);
    free(weight);

    /* Finished _distancematrix() */
#line 2169 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Algorithm__Cluster__somcluster); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__somcluster)
{
    dVAR; dXSARGS;
    if (items != 11)
       croak_xs_usage(cv,  "nrows, ncols, data_ref, mask_ref, weight_ref, transpose, nxgrid, nygrid, inittau, niter, dist");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	nrows = (int)SvIV(ST(0))
;
	int	ncols = (int)SvIV(ST(1))
;
	SV *	data_ref = ST(2)
;
	SV *	mask_ref = ST(3)
;
	SV *	weight_ref = ST(4)
;
	int	transpose = (int)SvIV(ST(5))
;
	int	nxgrid = (int)SvIV(ST(6))
;
	int	nygrid = (int)SvIV(ST(7))
;
	double	inittau = (double)SvNV(ST(8))
;
	int	niter = (int)SvIV(ST(9))
;
	char *	dist = (char *)SvPV_nolen(ST(10))
;
#line 1713 "Cluster.xs"
    int      (*clusterid)[2];
    SV *  clusterid_ref;
    double*** celldata;

    double  * weight;
    double ** matrix;
    int    ** mask;

    int ok;

    int i;
    AV * matrix_av;
    const int ndata = transpose ? nrows : ncols;
    const int nelements = transpose ? ncols : nrows;

#line 2223 "Cluster.c"
#line 1729 "Cluster.xs"
    /* ------------------------
     * Don't check the parameters, because we rely on the Perl
     * caller to check most paramters.
     */

    /* ------------------------
     * Allocate space for clusterid[][2]. 
     */
    clusterid = malloc(nelements*sizeof(int[2]));
    if (!clusterid) {
        croak("memory allocation failure in _somcluster\n");
    }
    celldata  =  0;
    /* Don't return celldata, for now at least */


    /* ------------------------
     * Convert data and mask matrices and the weight array
     * from C to Perl.  Also check for errors, and ignore the
     * mask or the weight array if there are any errors. 
     * Set nweights to the correct number of weights.
     */
    ok = malloc_matrices( aTHX_ weight_ref, &weight, ndata, 
                data_ref,   &matrix,
                mask_ref,   &mask,  
                nrows,      ncols);
    if (!ok) {
            croak("failed to read input data for _somcluster\n");
    }

    /* ------------------------
     * Run the library function
     */
    somcluster( 
        nrows, ncols, 
        matrix, mask, weight,
        transpose, nxgrid, nygrid, inittau, niter,
        dist[0], celldata, clusterid
    );

    /* ------------------------
     * Convert generated C matrices to Perl matrices
     */
    matrix_av = newAV();
    for(i=0; i<nelements; ++i) {
        SV* row_ref;
        AV* row_av = newAV();
        av_push(row_av, newSViv(clusterid[i][0]));
        av_push(row_av, newSViv(clusterid[i][1]));
        row_ref = newRV((SV*)row_av);
        av_push(matrix_av, row_ref);
    }
    clusterid_ref = newRV_noinc((SV*)matrix_av);

    /* ------------------------
     * Push the new Perl matrices onto the return stack
     */
    XPUSHs(sv_2mortal( clusterid_ref   ));

    /* ------------------------
     * Free what we've malloc'ed 
     */
    free_matrix_int(mask,     nrows);
    free_matrix_dbl(matrix,   nrows);
    free(weight);
    free(clusterid);

    /* Finished _somcluster() */
#line 2293 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Algorithm__Cluster__pca); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Algorithm__Cluster__pca)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "nrows, ncols, data_ref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	nrows = (int)SvIV(ST(0))
;
	int	ncols = (int)SvIV(ST(1))
;
	SV *	data_ref = ST(2)
;
#line 1806 "Cluster.xs"
    double** u;
    double** v;
    double* w;
    double* m;
    int i;
    int j;
    int nmin;
    int error;
    SV * mean_ref;
    SV * coordinates_ref;
    SV * pc_ref;
    SV * eigenvalues_ref;

#line 2329 "Cluster.c"
#line 1820 "Cluster.xs"
    if(SvTYPE(SvRV(data_ref)) != SVt_PVAV) { 
        croak("argument to _pca is not an array reference\n");
    }
    nmin = nrows < ncols ? nrows : ncols;
    /* -- Create the output variables -------------------------------------- */
    u = parse_data(aTHX_ data_ref, NULL);
    w = malloc(nmin*sizeof(double));
    v = malloc(nmin*sizeof(double*));
    m = malloc(ncols*sizeof(double));
    if (v) {
        for (i = 0; i < nmin; i++) {
            v[i] = malloc(nmin*sizeof(double));
            if (!v[i]) break;
        }
        if (i < nmin) { /* then we encountered the break */
            while (i-- > 0) free(v[i]);
            free(v);
            v = NULL;
        }
    }
    if (!u || !v || !w || !m) {
        if (u) free(u);
        if (v) free(v);
        if (w) free(w);
        if (m) free(m);
        croak("memory allocation failure in _pca\n");
    }
    /* -- Calculate the mean of each column ------------------------------ */
    for (j = 0; j < ncols; j++) {
        m[j] = 0.0;
        for (i = 0; i < nrows; i++) m[j] += u[i][j];
        m[j] /= nrows;
    }
    /* -- Subtract the mean of each column ------------------------------- */
    for (i = 0; i < nrows; i++)
        for (j = 0; j < ncols; j++)
            u[i][j] -= m[j];
    error = pca(nrows, ncols, u, v, w);
    if (error==0) {
        /* Convert the C variables to Perl variables */
        mean_ref = row_c2perl_dbl(aTHX_ m, ncols);
        if (nrows >= ncols) {
            coordinates_ref = matrix_c2perl_dbl(aTHX_ u, nrows, ncols);
            pc_ref = matrix_c2perl_dbl(aTHX_ v, nmin, nmin);
        }
        else /* nrows < ncols */ {
            pc_ref = matrix_c2perl_dbl(aTHX_ u, nrows, ncols);
            coordinates_ref = matrix_c2perl_dbl(aTHX_ v, nmin, nmin);
        }
        eigenvalues_ref = row_c2perl_dbl(aTHX_ w, nmin);
    }
    for (i = 0; i < nrows; i++) free(u[i]);
    for (i = 0; i < nmin; i++) free(v[i]);
    free(u);
    free(v);
    free(w);
    free(m);
    if (error==-1)
        croak("Insufficient memory for principal components analysis");
    if (error > 0)
        croak("Singular value decomposition failed to converge");
    /* ------------------------
     * Push the new Perl matrices onto the return stack
     */
    XPUSHs(sv_2mortal(mean_ref));
    XPUSHs(sv_2mortal(coordinates_ref));
    XPUSHs(sv_2mortal(pc_ref));
    XPUSHs(sv_2mortal(eigenvalues_ref));
#line 2399 "Cluster.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Algorithm__Cluster); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Algorithm__Cluster)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Algorithm::Cluster::Node::new", XS_Algorithm__Cluster__Node_new, file, "$$$$");
        (void)newXSproto_portable("Algorithm::Cluster::Node::left", XS_Algorithm__Cluster__Node_left, file, "$");
        (void)newXSproto_portable("Algorithm::Cluster::Node::right", XS_Algorithm__Cluster__Node_right, file, "$");
        (void)newXSproto_portable("Algorithm::Cluster::Node::distance", XS_Algorithm__Cluster__Node_distance, file, "$");
        (void)newXSproto_portable("Algorithm::Cluster::Node::set_left", XS_Algorithm__Cluster__Node_set_left, file, "$$");
        (void)newXSproto_portable("Algorithm::Cluster::Node::set_right", XS_Algorithm__Cluster__Node_set_right, file, "$$");
        (void)newXSproto_portable("Algorithm::Cluster::Node::set_distance", XS_Algorithm__Cluster__Node_set_distance, file, "$$");
        (void)newXSproto_portable("Algorithm::Cluster::Node::DESTROY", XS_Algorithm__Cluster__Node_DESTROY, file, "$");
        (void)newXSproto_portable("Algorithm::Cluster::Tree::new", XS_Algorithm__Cluster__Tree_new, file, "$$");
        (void)newXSproto_portable("Algorithm::Cluster::Tree::length", XS_Algorithm__Cluster__Tree_length, file, "$");
        (void)newXSproto_portable("Algorithm::Cluster::Tree::get", XS_Algorithm__Cluster__Tree_get, file, "$$");
        (void)newXSproto_portable("Algorithm::Cluster::Tree::scale", XS_Algorithm__Cluster__Tree_scale, file, "$");
        (void)newXSproto_portable("Algorithm::Cluster::Tree::cut", XS_Algorithm__Cluster__Tree_cut, file, "$$");
        (void)newXSproto_portable("Algorithm::Cluster::Tree::DESTROY", XS_Algorithm__Cluster__Tree_DESTROY, file, "$");
        (void)newXSproto_portable("Algorithm::Cluster::_version", XS_Algorithm__Cluster__version, file, "");
        (void)newXSproto_portable("Algorithm::Cluster::_mean", XS_Algorithm__Cluster__mean, file, "$");
        (void)newXSproto_portable("Algorithm::Cluster::_median", XS_Algorithm__Cluster__median, file, "$");
        (void)newXSproto_portable("Algorithm::Cluster::_treecluster", XS_Algorithm__Cluster__treecluster, file, "$$$$$$$$");
        (void)newXSproto_portable("Algorithm::Cluster::_kcluster", XS_Algorithm__Cluster__kcluster, file, "$$$$$$$$$$$");
        (void)newXSproto_portable("Algorithm::Cluster::_kmedoids", XS_Algorithm__Cluster__kmedoids, file, "$$$$$");
        (void)newXSproto_portable("Algorithm::Cluster::_clusterdistance", XS_Algorithm__Cluster__clusterdistance, file, "$$$$$$$$$$$$");
        (void)newXSproto_portable("Algorithm::Cluster::_clustercentroids", XS_Algorithm__Cluster__clustercentroids, file, "$$$$$$$$");
        (void)newXSproto_portable("Algorithm::Cluster::_distancematrix", XS_Algorithm__Cluster__distancematrix, file, "$$$$$$$");
        (void)newXSproto_portable("Algorithm::Cluster::_somcluster", XS_Algorithm__Cluster__somcluster, file, "$$$$$$$$$$$");
        (void)newXSproto_portable("Algorithm::Cluster::_pca", XS_Algorithm__Cluster__pca, file, "$$$");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

